// Advanced Generics and Type System Demo
println("ðŸ”¬ Advanced Type System & Generics Demo")
println("========================================")

// Generic function definitions with type parameters
function map<T, R>(items: Array<T>, transform: Function<T, R>): Array<R> {
    let result: Array<R> = []
    for item in items {
        result.push(transform(item))
    }
    return result
}

function filter<T>(items: Array<T>, predicate: Function<T, Boolean>): Array<T> {
    let result: Array<T> = []
    for item in items {
        if predicate(item) {
            result.push(item)
        }
    }
    return result
}

// Generic class definition
class Container<T> {
    private value: T
    
    constructor(initialValue: T) {
        this.value = initialValue
    }
    
    getValue(): T {
        return this.value
    }
    
    setValue(newValue: T): void {
        this.value = newValue
    }
    
    transform<R>(transformer: Function<T, R>): Container<R> {
        return new Container<R>(transformer(this.value))
    }
}

// Type inference demonstration
let numbers = [1, 2, 3, 4, 5] // Inferred as Array<Number>
let strings = ["hello", "world"] // Inferred as Array<String>

// Advanced language-specific implementations
@lang typescript {
    interface DataProcessor<T, R> {
        process(input: T): R;
        validate(input: T): boolean;
    }
    
    class NumberProcessor implements DataProcessor<number, string> {
        process(input: number): string {
            return `Processed: ${input * 2}`;
        }
        
        validate(input: number): boolean {
            return input > 0;
        }
    }
    
    class ArrayProcessor<T> implements DataProcessor<T[], T[]> {
        constructor(private transformer: (item: T) => T) {}
        
        process(input: T[]): T[] {
            return input.map(this.transformer);
        }
        
        validate(input: T[]): boolean {
            return Array.isArray(input) && input.length > 0;
        }
    }
}

@lang rust {
    use std::collections::HashMap;
    
    trait Processor<T, R> {
        fn process(&self, input: T) -> R;
        fn validate(&self, input: &T) -> bool;
    }
    
    struct StringProcessor;
    
    impl Processor<String, usize> for StringProcessor {
        fn process(&self, input: String) -> usize {
            input.len()
        }
        
        fn validate(&self, input: &String) -> bool {
            !input.is_empty()
        }
    }
    
    struct MapProcessor<K, V> 
    where 
        K: std::hash::Hash + Eq + Clone,
        V: Clone,
    {
        default_value: V,
    }
    
    impl<K, V> MapProcessor<K, V> 
    where 
        K: std::hash::Hash + Eq + Clone,
        V: Clone,
    {
        fn new(default: V) -> Self {
            Self { default_value: default }
        }
    }
    
    impl<K, V> Processor<HashMap<K, V>, Vec<V>> for MapProcessor<K, V>
    where 
        K: std::hash::Hash + Eq + Clone,
        V: Clone,
    {
        fn process(&self, input: HashMap<K, V>) -> Vec<V> {
            input.values().cloned().collect()
        }
        
        fn validate(&self, input: &HashMap<K, V>) -> bool {
            !input.is_empty()
        }
    }
}

@lang python {
from typing import TypeVar, Generic, List, Optional, Callable, Protocol

T = TypeVar('T')
R = TypeVar('R')

class DataProcessor(Protocol[T, R]):
    def process(self, input_data: T) -> R: ...
    def validate(self, input_data: T) -> bool: ...

class ListProcessor(Generic[T]):
    def __init__(self, transformer: Callable[[T], T]):
        self.transformer = transformer
    
    def process(self, input_data: List[T]) -> List[T]:
        return [self.transformer(item) for item in input_data]
    
    def validate(self, input_data: List[T]) -> bool:
        return isinstance(input_data, list) and len(input_data) > 0

class OptionalProcessor(Generic[T]):
    def process(self, input_data: Optional[T]) -> T:
        if input_data is None:
            raise ValueError("Cannot process None value")
        return input_data
    
    def validate(self, input_data: Optional[T]) -> bool:
        return input_data is not None

def advanced_map(items: List[T], func: Callable[[T], R]) -> List[R]:
    return [func(item) for item in items]

def safe_get(data: dict, key: str, default: T) -> T:
    return data.get(key, default)
}

// Cross-language generic workflow
println("Testing cross-language generic operations...")

// Create generic containers
let numberContainer = new Container<Number>(42)
let stringContainer = new Container<String>("Hello, Generics!")

// Type-safe transformations
let doubledContainer = numberContainer.transform<Number>((x: Number) => x * 2)
let upperContainer = stringContainer.transform<String>((s: String) => s.toUpperCase())

println("Number container:", numberContainer.getValue())
println("Doubled container:", doubledContainer.getValue())
println("String container:", stringContainer.getValue())
println("Upper container:", upperContainer.getValue())

// Advanced type inference and processing
let processedNumbers = typescript::NumberProcessor::process(123)
let rustStringLength = rust::StringProcessor::process("Type System")
let pythonProcessedList = python::advanced_map([1, 2, 3], (x) => x * x)

println("TypeScript processed:", processedNumbers)
println("Rust string length:", rustStringLength)
println("Python mapped list:", pythonProcessedList)

// Generic array operations with type inference
let doubledNumbers = map<Number, Number>(numbers, (x: Number) => x * 2)
let stringLengths = map<String, Number>(strings, (s: String) => s.length)
let evenNumbers = filter<Number>(numbers, (x: Number) => x % 2 == 0)

println("Original numbers:", numbers)
println("Doubled numbers:", doubledNumbers)
println("String lengths:", stringLengths)
println("Even numbers:", evenNumbers)

// Advanced error handling with optional types
function safeDivide(a: Number, b: Number): Optional<Number> {
    if b == 0 {
        return None
    }
    return Some(a / b)
}

let division1 = safeDivide(10, 2)
let division2 = safeDivide(10, 0)

println("Safe division 10/2:", division1)
println("Safe division 10/0:", division2)

println("âœ… Advanced type system demo complete!")
println("ðŸŽ¯ Generics, type inference, and cross-language compatibility verified!")
println("ðŸš€ Production-ready type safety achieved!") 