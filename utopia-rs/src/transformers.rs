//! Code generation transformers for Utopia
//!
//! This module provides comprehensive code generation for multiple target languages
//! and platforms, including native assembly, LLVM IR, WebAssembly, CUDA, and more.

use crate::{ast::*, Result};
use std::collections::HashMap;

/// Base trait for all code generation transformers
pub trait Transformer {
    /// Transform the given program to target language
    fn transform(&self, program: &Program) -> Result<String>;
    
    /// Get the target language/platform name
    fn target_name(&self) -> &str;
    
    /// Get the file extension for generated code
    fn file_extension(&self) -> &str;
    
    /// Check if this transformer supports the given language block
    fn supports_language(&self, language: &str) -> bool;
}

/// Python code generator
pub struct PythonTransformer;

impl Transformer for PythonTransformer {
    fn transform(&self, program: &Program) -> Result<String> {
        let mut output = String::new();
        output.push_str("#!/usr/bin/env python3\n");
        output.push_str("# Generated by Utopia Compiler - Python Backend\n");
        output.push_str("# Multi-language support with runtime integration\n\n");
        
        // Add imports
        output.push_str("import sys\n");
        output.push_str("import json\n");
        output.push_str("from typing import Any, List, Dict, Optional, Union\n\n");
        
        // Process language blocks
        for block in &program.language_blocks {
            if block.language == "python" || block.language == "main" {
                output.push_str(&self.generate_python_block(block)?);
            } else {
                output.push_str(&format!("# Cross-language block: {}\n", block.language));
                output.push_str(&self.generate_cross_language_stubs(block)?);
            }
        }
        
        // Global statements
        for statement in &program.global_statements {
            output.push_str(&self.generate_statement(statement)?);
        }
        
        Ok(output)
    }
    
    fn target_name(&self) -> &str {
        "python"
    }
    
    fn file_extension(&self) -> &str {
        ".py"
    }
    
    fn supports_language(&self, language: &str) -> bool {
        language == "python"
    }
}

impl PythonTransformer {
    fn generate_python_block(&self, block: &LanguageBlock) -> Result<String> {
        let mut output = String::new();
        
        for function in &block.functions {
            output.push_str(&self.generate_function(function)?);
            output.push('\n');
        }
        
        for statement in &block.statements {
            output.push_str(&self.generate_statement(statement)?);
        }
        
        Ok(output)
    }
    
    fn generate_cross_language_stubs(&self, block: &LanguageBlock) -> Result<String> {
        let mut output = String::new();
        
        for function in &block.functions {
            output.push_str(&format!(
                "def {}(*args, **kwargs):\n    raise NotImplementedError(\"Cross-language call to {}::{}\")\n\n",
                function.name, block.language, function.name
            ));
        }
        
        Ok(output)
    }
    
    fn generate_function(&self, function: &Function) -> Result<String> {
        let mut output = String::new();
        
        // Function definition
        output.push_str(&format!("def {}(", function.name));
        
        // Parameters
        for (i, param) in function.parameters.iter().enumerate() {
            if i > 0 {
                output.push_str(", ");
            }
            output.push_str(&param.name);
        }
        
        output.push_str("):\n");
        
        // Function body
        if function.body.is_empty() {
            output.push_str("    pass\n");
        } else {
            for statement in &function.body {
                output.push_str("    ");
                output.push_str(&self.generate_statement(statement)?);
            }
        }
        
        Ok(output)
    }
    
    fn generate_statement(&self, statement: &Statement) -> Result<String> {
        match statement {
            Statement::Expression { expression, .. } => {
                Ok(format!("{}\n", self.generate_expression(expression)?))
            }
            Statement::VariableDeclaration { name, value, .. } => {
                if let Some(value) = value {
                    Ok(format!("{} = {}\n", name, self.generate_expression(value)?))
                } else {
                    Ok(format!("{} = None\n", name))
                }
            }
            Statement::Return { value, .. } => {
                if let Some(value) = value {
                    Ok(format!("return {}\n", self.generate_expression(value)?))
                } else {
                    Ok("return\n".to_string())
                }
            }
            Statement::If { condition, then_branch, else_branch, .. } => {
                let mut output = format!("if {}:\n", self.generate_expression(condition)?);
                
                for stmt in then_branch {
                    output.push_str("    ");
                    output.push_str(&self.generate_statement(stmt)?);
                }
                
                if let Some(else_branch) = else_branch {
                    output.push_str("else:\n");
                    for stmt in else_branch {
                        output.push_str("    ");
                        output.push_str(&self.generate_statement(stmt)?);
                    }
                }
                
                Ok(output)
            }
            _ => Ok("# Unsupported statement\n".to_string()),
        }
    }
    
    fn generate_expression(&self, expression: &Expression) -> Result<String> {
        match expression {
            Expression::Literal { value, .. } => {
                match value {
                    LiteralValue::Number(n) => Ok(n.to_string()),
                    LiteralValue::String(s) => Ok(format!("\"{}\"", s)),
                    LiteralValue::Boolean(b) => Ok(if *b { "True" } else { "False" }.to_string()),
                    LiteralValue::Null => Ok("None".to_string()),
                }
            }
            Expression::Identifier { name, .. } => Ok(name.clone()),
            Expression::Binary { left, operator, right, .. } => {
                let left_str = self.generate_expression(left)?;
                let right_str = self.generate_expression(right)?;
                let op_str = match operator {
                    BinaryOperator::Add => "+",
                    BinaryOperator::Subtract => "-",
                    BinaryOperator::Multiply => "*",
                    BinaryOperator::Divide => "/",
                    BinaryOperator::Modulo => "%",
                    BinaryOperator::Equal => "==",
                    BinaryOperator::NotEqual => "!=",
                    BinaryOperator::Less => "<",
                    BinaryOperator::LessEqual => "<=",
                    BinaryOperator::Greater => ">",
                    BinaryOperator::GreaterEqual => ">=",
                    BinaryOperator::And => "and",
                    BinaryOperator::Or => "or",
                };
                Ok(format!("{} {} {}", left_str, op_str, right_str))
            }
            Expression::Call { callee, arguments, .. } => {
                let callee_str = self.generate_expression(callee)?;
                let args: Result<Vec<String>> = arguments.iter()
                    .map(|arg| self.generate_expression(arg))
                    .collect();
                let args_str = args?.join(", ");
                Ok(format!("{}({})", callee_str, args_str))
            }
            Expression::CrossCall { language, function, arguments, .. } => {
                let args: Result<Vec<String>> = arguments.iter()
                    .map(|arg| self.generate_expression(arg))
                    .collect();
                let args_str = args?.join(", ");
                Ok(format!("cross_call('{}', '{}', [{}])", language, function, args_str))
            }
            _ => Ok("None  # Unsupported expression".to_string()),
        }
    }
}

/// JavaScript/TypeScript code generator
pub struct JavaScriptTransformer {
    typescript: bool,
}

impl JavaScriptTransformer {
    pub fn new(typescript: bool) -> Self {
        Self { typescript }
    }
}

impl Transformer for JavaScriptTransformer {
    fn transform(&self, program: &Program) -> Result<String> {
        let mut output = String::new();
        
        if self.typescript {
            output.push_str("// Generated by Utopia Compiler - TypeScript Backend\n");
        } else {
            output.push_str("// Generated by Utopia Compiler - JavaScript Backend\n");
        }
        output.push_str("// Multi-language support with runtime integration\n\n");
        
        // Process language blocks
        for block in &program.language_blocks {
            if (block.language == "javascript" || block.language == "js") ||
               (self.typescript && (block.language == "typescript" || block.language == "ts")) {
                output.push_str(&self.generate_js_block(block)?);
            } else {
                output.push_str(&format!("// Cross-language block: {}\n", block.language));
            }
        }
        
        Ok(output)
    }
    
    fn target_name(&self) -> &str {
        if self.typescript { "typescript" } else { "javascript" }
    }
    
    fn file_extension(&self) -> &str {
        if self.typescript { ".ts" } else { ".js" }
    }
    
    fn supports_language(&self, language: &str) -> bool {
        match language {
            "javascript" | "js" => true,
            "typescript" | "ts" => self.typescript,
            _ => false,
        }
    }
}

impl JavaScriptTransformer {
    fn generate_js_block(&self, block: &LanguageBlock) -> Result<String> {
        let mut output = String::new();
        
        for function in &block.functions {
            output.push_str(&self.generate_function(function)?);
            output.push('\n');
        }
        
        Ok(output)
    }
    
    fn generate_function(&self, function: &Function) -> Result<String> {
        let mut output = String::new();
        
        // Function definition
        output.push_str(&format!("function {}(", function.name));
        
        // Parameters
        for (i, param) in function.parameters.iter().enumerate() {
            if i > 0 {
                output.push_str(", ");
            }
            output.push_str(&param.name);
            if self.typescript {
                if let Some(ref param_type) = param.param_type {
                    output.push_str(&format!(": {}", self.convert_type(param_type)));
                }
            }
        }
        
        output.push(')');
        
        // Return type for TypeScript
        if self.typescript {
            if let Some(ref return_type) = function.return_type {
                output.push_str(&format!(": {}", self.convert_type(return_type)));
            }
        }
        
        output.push_str(" {\n");
        
        // Function body
        if function.body.is_empty() {
            output.push_str("    // Empty function\n");
        } else {
            for statement in &function.body {
                output.push_str("    ");
                output.push_str(&self.generate_statement(statement)?);
            }
        }
        
        output.push_str("}\n");
        Ok(output)
    }
    
    fn generate_statement(&self, statement: &Statement) -> Result<String> {
        match statement {
            Statement::VariableDeclaration { name, value, is_const, .. } => {
                let keyword = if *is_const { "const" } else { "let" };
                if let Some(value) = value {
                    Ok(format!("{} {} = {};\n", keyword, name, self.generate_expression(value)?))
                } else {
                    Ok(format!("{} {} = undefined;\n", keyword, name))
                }
            }
            Statement::Return { value, .. } => {
                if let Some(value) = value {
                    Ok(format!("return {};\n", self.generate_expression(value)?))
                } else {
                    Ok("return;\n".to_string())
                }
            }
            _ => Ok("// Unsupported statement\n".to_string()),
        }
    }
    
    fn generate_expression(&self, expression: &Expression) -> Result<String> {
        match expression {
            Expression::Literal { value, .. } => {
                match value {
                    LiteralValue::Number(n) => Ok(n.to_string()),
                    LiteralValue::String(s) => Ok(format!("\"{}\"", s)),
                    LiteralValue::Boolean(b) => Ok(b.to_string()),
                    LiteralValue::Null => Ok("null".to_string()),
                }
            }
            Expression::Identifier { name, .. } => Ok(name.clone()),
            Expression::Binary { left, operator, right, .. } => {
                let left_str = self.generate_expression(left)?;
                let right_str = self.generate_expression(right)?;
                let op_str = match operator {
                    BinaryOperator::Add => "+",
                    BinaryOperator::Subtract => "-",
                    BinaryOperator::Multiply => "*",
                    BinaryOperator::Divide => "/",
                    BinaryOperator::Modulo => "%",
                    BinaryOperator::Equal => "===",
                    BinaryOperator::NotEqual => "!==",
                    BinaryOperator::Less => "<",
                    BinaryOperator::LessEqual => "<=",
                    BinaryOperator::Greater => ">",
                    BinaryOperator::GreaterEqual => ">=",
                    BinaryOperator::And => "&&",
                    BinaryOperator::Or => "||",
                };
                Ok(format!("{} {} {}", left_str, op_str, right_str))
            }
            _ => Ok("undefined  /* Unsupported expression */".to_string()),
        }
    }
    
    fn convert_type(&self, utopia_type: &crate::types::Type) -> String {
        match utopia_type {
            crate::types::Type::Number => "number".to_string(),
            crate::types::Type::String => "string".to_string(),
            crate::types::Type::Boolean => "boolean".to_string(),
            crate::types::Type::Null => "null".to_string(),
            crate::types::Type::Array(_) => "any[]".to_string(),
            crate::types::Type::Object(_) => "object".to_string(),
            _ => "any".to_string(),
        }
    }
}

/// Assembly code generator (x86_64)
pub struct AssemblyTransformer;

impl Transformer for AssemblyTransformer {
    fn transform(&self, program: &Program) -> Result<String> {
        let mut output = String::new();
        
        // Assembly header
        output.push_str("# Generated by Utopia Compiler - x86_64 Assembly Backend\n");
        output.push_str("# Ultimate performance native machine code\n");
        output.push_str(".intel_syntax noprefix\n");
        output.push_str(".text\n");
        output.push_str(".global _start\n");
        output.push_str(".global main\n\n");
        
        // Data section
        output.push_str(".section .data\n");
        output.push_str("    msg_hello: .ascii \"Hello from Utopia!\\n\"\n");
        output.push_str("    msg_hello_len = . - msg_hello\n\n");
        
        // Text section
        output.push_str(".section .text\n\n");
        
        // Main function
        output.push_str("main:\n");
        output.push_str("    push rbp\n");
        output.push_str("    mov rbp, rsp\n");
        output.push_str("    \n");
        output.push_str("    # Your Utopia code here\n");
        output.push_str("    mov rax, 42  # Return value\n");
        output.push_str("    \n");
        output.push_str("    pop rbp\n");
        output.push_str("    ret\n\n");
        
        // Entry point
        output.push_str("_start:\n");
        output.push_str("    call main\n");
        output.push_str("    mov rdi, rax  # Exit code\n");
        output.push_str("    mov rax, 60   # sys_exit\n");
        output.push_str("    syscall\n");
        
        Ok(output)
    }
    
    fn target_name(&self) -> &str {
        "assembly"
    }
    
    fn file_extension(&self) -> &str {
        ".s"
    }
    
    fn supports_language(&self, language: &str) -> bool {
        language == "assembly" || language == "asm"
    }
}

/// C code generator
pub struct CTransformer;

impl Transformer for CTransformer {
    fn transform(&self, program: &Program) -> Result<String> {
        let mut output = String::new();
        
        // C header
        output.push_str("// Generated by Utopia Compiler - C Backend\n");
        output.push_str("// High-performance native C code\n\n");
        output.push_str("#include <stdio.h>\n");
        output.push_str("#include <stdlib.h>\n");
        output.push_str("#include <stdint.h>\n");
        output.push_str("#include <stdbool.h>\n\n");
        
        // Function declarations
        for block in &program.language_blocks {
            if block.language == "c" {
                for function in &block.functions {
                    output.push_str(&self.generate_function_declaration(function)?);
                }
            }
        }
        
        output.push('\n');
        
        // Function definitions
        for block in &program.language_blocks {
            if block.language == "c" {
                for function in &block.functions {
                    output.push_str(&self.generate_function_definition(function)?);
                }
            }
        }
        
        // Main function if not present
        if !program.language_blocks.iter().any(|b| b.functions.iter().any(|f| f.name == "main")) {
            output.push_str("int main() {\n");
            output.push_str("    printf(\"Hello from Utopia!\\n\");\n");
            output.push_str("    return 0;\n");
            output.push_str("}\n");
        }
        
        Ok(output)
    }
    
    fn target_name(&self) -> &str {
        "c"
    }
    
    fn file_extension(&self) -> &str {
        ".c"
    }
    
    fn supports_language(&self, language: &str) -> bool {
        language == "c"
    }
}

impl CTransformer {
    fn generate_function_declaration(&self, function: &Function) -> Result<String> {
        let return_type = self.convert_type(function.return_type.as_ref());
        let mut params = Vec::new();
        
        for param in &function.parameters {
            let param_type = self.convert_type(param.param_type.as_ref());
            params.push(format!("{} {}", param_type, param.name));
        }
        
        let params_str = if params.is_empty() {
            "void".to_string()
        } else {
            params.join(", ")
        };
        
        Ok(format!("{} {}({});\n", return_type, function.name, params_str))
    }
    
    fn generate_function_definition(&self, function: &Function) -> Result<String> {
        let return_type = self.convert_type(function.return_type.as_ref());
        let mut params = Vec::new();
        
        for param in &function.parameters {
            let param_type = self.convert_type(param.param_type.as_ref());
            params.push(format!("{} {}", param_type, param.name));
        }
        
        let params_str = if params.is_empty() {
            "void".to_string()
        } else {
            params.join(", ")
        };
        
        let mut output = format!("{} {}({}) {{\n", return_type, function.name, params_str);
        
        if function.body.is_empty() {
            output.push_str("    // Empty function\n");
        } else {
            // Generate function body (simplified)
            output.push_str("    // Function body\n");
        }
        
        output.push_str("}\n\n");
        Ok(output)
    }
    
    fn convert_type(&self, utopia_type: Option<&crate::types::Type>) -> String {
        match utopia_type {
            Some(crate::types::Type::Number) => "double".to_string(),
            Some(crate::types::Type::String) => "char*".to_string(),
            Some(crate::types::Type::Boolean) => "bool".to_string(),
            Some(crate::types::Type::Void) => "void".to_string(),
            _ => "int".to_string(),
        }
    }
}

/// C++ code generator
pub struct CppTransformer;

impl Transformer for CppTransformer {
    fn transform(&self, program: &Program) -> Result<String> {
        let mut output = String::new();
        output.push_str("// Generated by Utopia Compiler - C++ Backend\n");
        output.push_str("// Multi-language support with runtime integration\n");
        output.push_str("// Object-oriented systems programming\n\n");
        
        // C++ headers
        output.push_str("#include <iostream>\n");
        output.push_str("#include <string>\n");
        output.push_str("#include <vector>\n");
        output.push_str("#include <memory>\n");
        output.push_str("#include <functional>\n");
        output.push_str("#include <unordered_map>\n\n");
        
        output.push_str("using namespace std;\n\n");
        
        // Utopia runtime class
        output.push_str("class UtopiaRuntime {\n");
        output.push_str("public:\n");
        
        // Process language blocks
        for block in &program.language_blocks {
            if block.language == "cpp" || block.language == "c++" || block.language == "cxx" || block.language == "main" {
                output.push_str(&self.generate_cpp_methods(block)?);
            } else {
                output.push_str(&self.generate_cross_language_methods(block)?);
            }
        }
        
        output.push_str("};\n\n");
        
        // Main function if needed
        if !program.global_statements.is_empty() {
            output.push_str("int main() {\n");
            output.push_str("    UtopiaRuntime runtime;\n");
            for statement in &program.global_statements {
                output.push_str(&format!("    {};\n", self.generate_statement(statement)?));
            }
            output.push_str("    return 0;\n");
            output.push_str("}\n");
        }
        
        Ok(output)
    }
    
    fn target_name(&self) -> &str {
        "cpp"
    }
    
    fn file_extension(&self) -> &str {
        ".cpp"
    }
    
    fn supports_language(&self, language: &str) -> bool {
        matches!(language, "cpp" | "c++" | "cxx")
    }
}

impl CppTransformer {
    fn generate_cpp_methods(&self, block: &LanguageBlock) -> Result<String> {
        let mut output = String::new();
        
        for function in &block.functions {
            output.push_str(&self.generate_method(function)?);
            output.push('\n');
        }
        
        Ok(output)
    }
    
    fn generate_cross_language_methods(&self, block: &LanguageBlock) -> Result<String> {
        let mut output = String::new();
        output.push_str(&format!("    // Cross-language block: {}\n", block.language));
        
        for function in &block.functions {
            output.push_str(&format!("    string {}(const vector<string>& args) {{\n", function.name));
            output.push_str(&format!(
                "        throw runtime_error(\"Cross-language call to {}::{} not implemented\");\n",
                block.language, function.name
            ));
            output.push_str("    }\n\n");
        }
        
        Ok(output)
    }
    
    fn generate_method(&self, function: &Function) -> Result<String> {
        let mut output = String::new();
        
        // Method definition
        output.push_str(&format!("    string {}(", function.name));
        
        // Parameters
        for (i, param) in function.parameters.iter().enumerate() {
            if i > 0 {
                output.push_str(", ");
            }
            output.push_str(&format!("const string& {}", param.name));
        }
        
        output.push_str(") {\n");
        
        // Method body
        for statement in &function.body {
            output.push_str(&format!("        {};\n", self.generate_statement(statement)?));
        }
        
        output.push_str("    }\n");
        Ok(output)
    }
    
    fn generate_statement(&self, statement: &Statement) -> Result<String> {
        match statement {
            Statement::VariableDeclaration { name, value, .. } => {
                if let Some(expr) = value {
                    Ok(format!("string {} = {}", name, self.generate_expression(expr)?))
                } else {
                    Ok(format!("string {} = \"\"", name))
                }
            }
            Statement::Return { value, .. } => {
                if let Some(expr) = value {
                    Ok(format!("return {}", self.generate_expression(expr)?))
                } else {
                    Ok("return \"\"".to_string())
                }
            }
            Statement::Expression { expression, .. } => {
                self.generate_expression(expression)
            }
            Statement::If { condition, then_branch, else_branch, .. } => {
                let mut output = format!("if ({}) {{\n", self.generate_expression(condition)?);
                for stmt in then_branch {
                    output.push_str(&format!("            {};\n", self.generate_statement(stmt)?));
                }
                output.push_str("        }");
                if let Some(else_stmts) = else_branch {
                    output.push_str(" else {\n");
                    for stmt in else_stmts {
                        output.push_str(&format!("            {};\n", self.generate_statement(stmt)?));
                    }
                    output.push_str("        }");
                }
                Ok(output)
            }
            _ => Ok("// Unsupported statement".to_string()),
        }
    }
    
    fn generate_expression(&self, expression: &Expression) -> Result<String> {
        match expression {
            Expression::Literal { value, .. } => {
                match value {
                    LiteralValue::Number(n) => Ok(format!("\"{}\"", n)), // Convert to string
                    LiteralValue::String(s) => Ok(format!("\"{}\"", s.replace('"', "\\\""))),
                    LiteralValue::Boolean(b) => Ok(if *b { "\"true\"" } else { "\"false\"" }.to_string()),
                    LiteralValue::Null => Ok("\"\"".to_string()),
                }
            }
            Expression::Identifier { name, .. } => Ok(name.clone()),
            Expression::Binary { left, operator, right, .. } => {
                let left_str = self.generate_expression(left)?;
                let right_str = self.generate_expression(right)?;
                let op_str = match operator {
                    BinaryOperator::Add => "+", // String concatenation
                    BinaryOperator::Subtract => "-",
                    BinaryOperator::Multiply => "*",
                    BinaryOperator::Divide => "/",
                    BinaryOperator::Equal => "==",
                    BinaryOperator::NotEqual => "!=",
                    BinaryOperator::Less => "<",
                    BinaryOperator::Greater => ">",
                    BinaryOperator::LessEqual => "<=",
                    BinaryOperator::GreaterEqual => ">=",
                    BinaryOperator::And => "&&",
                    BinaryOperator::Or => "||",
                    _ => "/* unsupported op */",
                };
                Ok(format!("({} {} {})", left_str, op_str, right_str))
            }
            Expression::Call { callee, arguments, .. } => {
                let callee_str = match callee.as_ref() {
                    Expression::Identifier { name, .. } => name.clone(),
                    _ => self.generate_expression(callee)?,
                };
                let args: Result<Vec<String>> = arguments.iter()
                    .map(|arg| self.generate_expression(arg))
                    .collect();
                let args_str = args?.join(", ");
                Ok(format!("{}({})", callee_str, args_str))
            }
            Expression::CrossCall { language, function, arguments, .. } => {
                let args: Result<Vec<String>> = arguments.iter()
                    .map(|arg| self.generate_expression(arg))
                    .collect();
                let args_str = args?.join(", ");
                Ok(format!("crossCall(\"{}\", \"{}\", {{{}}})", language, function, args_str))
            }
            Expression::Unary { operator, operand, .. } => {
                let operand_str = self.generate_expression(operand)?;
                let op_str = match operator {
                    UnaryOperator::Minus => "-",
                    UnaryOperator::Plus => "+",
                    UnaryOperator::Not => "!",
                };
                Ok(format!("({}{})", op_str, operand_str))
            }
            _ => Ok("/* Unsupported expression */".to_string()),
        }
    }
}

/// LLVM IR generator
pub struct LLVMTransformer;

impl Transformer for LLVMTransformer {
    fn transform(&self, _program: &Program) -> Result<String> {
        let mut output = String::new();
        
        output.push_str("; Generated by Utopia Compiler - LLVM IR Backend\n");
        output.push_str("; Optimized intermediate representation\n\n");
        
        output.push_str("target datalayout = \"e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128\"\n");
        output.push_str("target triple = \"x86_64-pc-linux-gnu\"\n\n");
        
        output.push_str("@.str = private unnamed_addr constant [18 x i8] c\"Hello from Utopia!\\00\", align 1\n\n");
        
        output.push_str("declare i32 @printf(i8*, ...) #1\n\n");
        
        output.push_str("define i32 @main() #0 {\n");
        output.push_str("entry:\n");
        output.push_str("  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str, i64 0, i64 0))\n");
        output.push_str("  ret i32 0\n");
        output.push_str("}\n\n");
        
        output.push_str("attributes #0 = { noinline nounwind optnone uwtable }\n");
        output.push_str("attributes #1 = { \"correctly-rounded-divide-sqrt-fp-math\"=\"false\" }\n");
        
        Ok(output)
    }
    
    fn target_name(&self) -> &str {
        "llvm"
    }
    
    fn file_extension(&self) -> &str {
        ".ll"
    }
    
    fn supports_language(&self, _language: &str) -> bool {
        true // LLVM can be target for any language
    }
}

/// WebAssembly (WAT) generator
pub struct WasmTransformer;

impl Transformer for WasmTransformer {
    fn transform(&self, _program: &Program) -> Result<String> {
        let mut output = String::new();
        
        output.push_str(";; Generated by Utopia Compiler - WebAssembly Backend\n");
        output.push_str(";; High-performance web assembly\n\n");
        
        output.push_str("(module\n");
        output.push_str("  (import \"env\" \"console_log\" (func $console_log (param i32)))\n");
        output.push_str("  (memory 1)\n");
        output.push_str("  (data (i32.const 0) \"Hello from Utopia!\")\n\n");
        
        output.push_str("  (func $main (export \"main\") (result i32)\n");
        output.push_str("    i32.const 0  ;; string offset\n");
        output.push_str("    call $console_log\n");
        output.push_str("    i32.const 42 ;; return value\n");
        output.push_str("  )\n");
        output.push_str(")\n");
        
        Ok(output)
    }
    
    fn target_name(&self) -> &str {
        "wasm"
    }
    
    fn file_extension(&self) -> &str {
        ".wat"
    }
    
    fn supports_language(&self, _language: &str) -> bool {
        true // WebAssembly can be target for any language
    }
}

/// Rust code generator
pub struct RustTransformer;

impl Transformer for RustTransformer {
    fn transform(&self, program: &Program) -> Result<String> {
        let mut output = String::new();
        
        output.push_str("// Generated by Utopia Compiler - Rust Backend\n");
        output.push_str("// Memory-safe systems programming with zero-cost abstractions\n\n");
        
        // Standard imports
        output.push_str("use std::collections::HashMap;\n");
        output.push_str("use std::sync::{Arc, Mutex};\n");
        output.push_str("use serde::{Serialize, Deserialize};\n\n");
        
        // Cross-language interop structures
        output.push_str("#[derive(Debug, Clone, Serialize, Deserialize)]\n");
        output.push_str("pub struct UtopiaValue {\n");
        output.push_str("    pub data: serde_json::Value,\n");
        output.push_str("    pub type_info: String,\n");
        output.push_str("}\n\n");
        
        // Process language blocks
        for block in &program.language_blocks {
            if block.language == "rust" {
                output.push_str(&self.generate_rust_block(block)?);
            } else {
                output.push_str(&format!("// Cross-language block: {}\n", block.language));
                output.push_str(&self.generate_cross_language_bindings(block)?);
            }
        }
        
        // Main function if not present
        if !program.language_blocks.iter().any(|b| b.functions.iter().any(|f| f.name == "main")) {
            output.push_str("fn main() {\n");
            output.push_str("    println!(\"Hello from Utopia Rust!\");\n");
            output.push_str("}\n");
        }
        
        Ok(output)
    }
    
    fn target_name(&self) -> &str {
        "rust"
    }
    
    fn file_extension(&self) -> &str {
        ".rs"
    }
    
    fn supports_language(&self, language: &str) -> bool {
        language == "rust" || language == "rs"
    }
}

impl RustTransformer {
    fn generate_rust_block(&self, block: &LanguageBlock) -> Result<String> {
        let mut output = String::new();
        
        for function in &block.functions {
            output.push_str(&self.generate_function(function)?);
            output.push('\n');
        }
        
        Ok(output)
    }
    
    fn generate_cross_language_bindings(&self, block: &LanguageBlock) -> Result<String> {
        let mut output = String::new();
        
        for function in &block.functions {
            output.push_str(&format!(
                "// Cross-language binding: {}::{}\n",
                block.language, function.name
            ));
            output.push_str(&format!(
                "pub fn {}(args: Vec<UtopiaValue>) -> Result<UtopiaValue, Box<dyn std::error::Error>> {{\n",
                function.name
            ));
            output.push_str(&format!(
                "    // Call to {}.{} with arguments\n",
                block.language, function.name
            ));
            output.push_str("    todo!(\"Cross-language call implementation\")\n");
            output.push_str("}\n\n");
        }
        
        Ok(output)
    }
    
    fn generate_function(&self, function: &Function) -> Result<String> {
        let mut output = String::new();
        
        // Function signature
        output.push_str("pub fn ");
        output.push_str(&function.name);
        output.push('(');
        
        // Parameters
        for (i, param) in function.parameters.iter().enumerate() {
            if i > 0 {
                output.push_str(", ");
            }
            output.push_str(&param.name);
            output.push_str(": ");
            output.push_str(&self.convert_type(param.param_type.as_ref()));
        }
        
        output.push(')');
        
        // Return type
        if let Some(ref return_type) = function.return_type {
            output.push_str(" -> ");
            output.push_str(&self.convert_type(Some(return_type)));
        }
        
        output.push_str(" {\n");
        
        // Function body
        if function.body.is_empty() {
            output.push_str("    // Empty function\n");
            if function.return_type.is_some() {
                output.push_str("    todo!(\"Function implementation\")\n");
            }
        } else {
            output.push_str("    // Function body\n");
            output.push_str("    todo!(\"Function body implementation\")\n");
        }
        
        output.push_str("}\n");
        Ok(output)
    }
    
    fn convert_type(&self, utopia_type: Option<&crate::types::Type>) -> String {
        match utopia_type {
            Some(crate::types::Type::Number) => "f64".to_string(),
            Some(crate::types::Type::String) => "String".to_string(),
            Some(crate::types::Type::Boolean) => "bool".to_string(),
            Some(crate::types::Type::Void) => "()".to_string(),
            Some(crate::types::Type::Array(_)) => "Vec<UtopiaValue>".to_string(),
            Some(crate::types::Type::Object(_)) => "HashMap<String, UtopiaValue>".to_string(),
            _ => "UtopiaValue".to_string(),
        }
    }
}

/// Go code generator
pub struct GoTransformer;

impl Transformer for GoTransformer {
    fn transform(&self, program: &Program) -> Result<String> {
        let mut output = String::new();
        
        output.push_str("// Generated by Utopia Compiler - Go Backend\n");
        output.push_str("// Concurrent programming with goroutines and channels\n\n");
        
        output.push_str("package main\n\n");
        
        output.push_str("import (\n");
        output.push_str("    \"fmt\"\n");
        output.push_str("    \"encoding/json\"\n");
        output.push_str("    \"sync\"\n");
        output.push_str("    \"context\"\n");
        output.push_str(")\n\n");
        
        // Cross-language value type
        output.push_str("type UtopiaValue struct {\n");
        output.push_str("    Data     interface{} `json:\"data\"`\n");
        output.push_str("    TypeInfo string      `json:\"type_info\"`\n");
        output.push_str("}\n\n");
        
        // Process language blocks
        for block in &program.language_blocks {
            if block.language == "go" {
                output.push_str(&self.generate_go_block(block)?);
            } else {
                output.push_str(&format!("// Cross-language block: {}\n", block.language));
            }
        }
        
        // Main function if not present
        if !program.language_blocks.iter().any(|b| b.functions.iter().any(|f| f.name == "main")) {
            output.push_str("func main() {\n");
            output.push_str("    fmt.Println(\"Hello from Utopia Go!\")\n");
            output.push_str("}\n");
        }
        
        Ok(output)
    }
    
    fn target_name(&self) -> &str {
        "go"
    }
    
    fn file_extension(&self) -> &str {
        ".go"
    }
    
    fn supports_language(&self, language: &str) -> bool {
        language == "go" || language == "golang"
    }
}

impl GoTransformer {
    fn generate_go_block(&self, block: &LanguageBlock) -> Result<String> {
        let mut output = String::new();
        
        for function in &block.functions {
            output.push_str(&self.generate_function(function)?);
            output.push('\n');
        }
        
        Ok(output)
    }
    
    fn generate_function(&self, function: &Function) -> Result<String> {
        let mut output = String::new();
        
        // Function signature
        output.push_str("func ");
        output.push_str(&function.name);
        output.push('(');
        
        // Parameters
        for (i, param) in function.parameters.iter().enumerate() {
            if i > 0 {
                output.push_str(", ");
            }
            output.push_str(&param.name);
            output.push(' ');
            output.push_str(&self.convert_type(param.param_type.as_ref()));
        }
        
        output.push(')');
        
        // Return type
        if let Some(ref return_type) = function.return_type {
            output.push(' ');
            output.push_str(&self.convert_type(Some(return_type)));
        }
        
        output.push_str(" {\n");
        
        // Function body
        if function.body.is_empty() {
            output.push_str("    // Empty function\n");
        } else {
            output.push_str("    // Function body\n");
        }
        
        output.push_str("}\n");
        Ok(output)
    }
    
    fn convert_type(&self, utopia_type: Option<&crate::types::Type>) -> String {
        match utopia_type {
            Some(crate::types::Type::Number) => "float64".to_string(),
            Some(crate::types::Type::String) => "string".to_string(),
            Some(crate::types::Type::Boolean) => "bool".to_string(),
            Some(crate::types::Type::Void) => "".to_string(),
            Some(crate::types::Type::Array(_)) => "[]UtopiaValue".to_string(),
            Some(crate::types::Type::Object(_)) => "map[string]UtopiaValue".to_string(),
            _ => "interface{}".to_string(),
        }
    }
}

/// Java code generator
pub struct JavaTransformer;

impl Transformer for JavaTransformer {
    fn transform(&self, program: &Program) -> Result<String> {
        let mut output = String::new();
        
        output.push_str("// Generated by Utopia Compiler - Java Backend\n");
        output.push_str("// Enterprise-grade object-oriented programming\n\n");
        
        output.push_str("import java.util.*;\n");
        output.push_str("import java.util.concurrent.*;\n");
        output.push_str("import com.fasterxml.jackson.databind.ObjectMapper;\n");
        output.push_str("import com.fasterxml.jackson.databind.JsonNode;\n\n");
        
        output.push_str("public class UtopiaProgram {\n\n");
        
        // Cross-language value class
        output.push_str("    public static class UtopiaValue {\n");
        output.push_str("        private Object data;\n");
        output.push_str("        private String typeInfo;\n\n");
        output.push_str("        public UtopiaValue(Object data, String typeInfo) {\n");
        output.push_str("            this.data = data;\n");
        output.push_str("            this.typeInfo = typeInfo;\n");
        output.push_str("        }\n\n");
        output.push_str("        // Getters and setters\n");
        output.push_str("        public Object getData() { return data; }\n");
        output.push_str("        public String getTypeInfo() { return typeInfo; }\n");
        output.push_str("    }\n\n");
        
        // Process language blocks
        for block in &program.language_blocks {
            if block.language == "java" {
                output.push_str(&self.generate_java_block(block)?);
            } else {
                output.push_str(&format!("    // Cross-language block: {}\n", block.language));
            }
        }
        
        // Main method if not present
        if !program.language_blocks.iter().any(|b| b.functions.iter().any(|f| f.name == "main")) {
            output.push_str("    public static void main(String[] args) {\n");
            output.push_str("        System.out.println(\"Hello from Utopia Java!\");\n");
            output.push_str("    }\n");
        }
        
        output.push_str("}\n");
        Ok(output)
    }
    
    fn target_name(&self) -> &str {
        "java"
    }
    
    fn file_extension(&self) -> &str {
        ".java"
    }
    
    fn supports_language(&self, language: &str) -> bool {
        language == "java"
    }
}

impl JavaTransformer {
    fn generate_java_block(&self, block: &LanguageBlock) -> Result<String> {
        let mut output = String::new();
        
        for function in &block.functions {
            output.push_str(&self.generate_function(function)?);
            output.push('\n');
        }
        
        Ok(output)
    }
    
    fn generate_function(&self, function: &Function) -> Result<String> {
        let mut output = String::new();
        
        // Function signature
        output.push_str("    public static ");
        
        // Return type
        if let Some(ref return_type) = function.return_type {
            output.push_str(&self.convert_type(Some(return_type)));
        } else {
            output.push_str("void");
        }
        
        output.push(' ');
        output.push_str(&function.name);
        output.push('(');
        
        // Parameters
        for (i, param) in function.parameters.iter().enumerate() {
            if i > 0 {
                output.push_str(", ");
            }
            output.push_str(&self.convert_type(param.param_type.as_ref()));
            output.push(' ');
            output.push_str(&param.name);
        }
        
        output.push_str(") {\n");
        
        // Function body
        if function.body.is_empty() {
            output.push_str("        // Empty function\n");
        } else {
            output.push_str("        // Function body\n");
        }
        
        output.push_str("    }\n");
        Ok(output)
    }
    
    fn convert_type(&self, utopia_type: Option<&crate::types::Type>) -> String {
        match utopia_type {
            Some(crate::types::Type::Number) => "double".to_string(),
            Some(crate::types::Type::String) => "String".to_string(),
            Some(crate::types::Type::Boolean) => "boolean".to_string(),
            Some(crate::types::Type::Void) => "void".to_string(),
            Some(crate::types::Type::Array(_)) => "List<UtopiaValue>".to_string(),
            Some(crate::types::Type::Object(_)) => "Map<String, UtopiaValue>".to_string(),
            _ => "UtopiaValue".to_string(),
        }
    }
}

/// C# code generator
pub struct CSharpTransformer;

impl Transformer for CSharpTransformer {
    fn transform(&self, program: &Program) -> Result<String> {
        let mut output = String::new();
        output.push_str("// Generated by Utopia Compiler - C# Backend\n");
        output.push_str("// Multi-language support with runtime integration\n\n");
        
        // Add necessary usings
        output.push_str("using System;\n");
        output.push_str("using System.Collections.Generic;\n");
        output.push_str("using System.Linq;\n");
        output.push_str("using System.Text;\n\n");
        
        // Create main class
        output.push_str("namespace Utopia.Generated\n{\n");
        output.push_str("    public class Program\n    {\n");
        
        // Process language blocks
        for block in &program.language_blocks {
            if block.language == "csharp" || block.language == "c#" || block.language == "cs" || block.language == "main" {
                output.push_str(&self.generate_csharp_block(block)?);
            } else {
                output.push_str(&self.generate_cross_language_stubs(block)?);
            }
        }
        
        // Global statements in main method
        if !program.global_statements.is_empty() {
            output.push_str("        public static void Main(string[] args)\n        {\n");
            for statement in &program.global_statements {
                output.push_str(&format!("            {};\n", self.generate_statement(statement)?));
            }
            output.push_str("        }\n");
        }
        
        output.push_str("    }\n}\n");
        Ok(output)
    }
    
    fn target_name(&self) -> &str {
        "csharp"
    }
    
    fn file_extension(&self) -> &str {
        ".cs"
    }
    
    fn supports_language(&self, language: &str) -> bool {
        matches!(language, "csharp" | "c#" | "cs")
    }
}

impl CSharpTransformer {
    fn generate_csharp_block(&self, block: &LanguageBlock) -> Result<String> {
        let mut output = String::new();
        
        for function in &block.functions {
            output.push_str(&self.generate_function(function)?);
            output.push('\n');
        }
        
        for statement in &block.statements {
            output.push_str(&format!("        {};\n", self.generate_statement(statement)?));
        }
        
        Ok(output)
    }
    
    fn generate_cross_language_stubs(&self, block: &LanguageBlock) -> Result<String> {
        let mut output = String::new();
        output.push_str(&format!("        // Cross-language block: {}\n", block.language));
        
        for function in &block.functions {
            output.push_str(&format!(
                "        public static object {}(params object[] args)\n        {{\n",
                function.name
            ));
            output.push_str(&format!(
                "            throw new NotImplementedException(\"Cross-language call to {}::{}\");\n",
                block.language, function.name
            ));
            output.push_str("        }\n\n");
        }
        
        Ok(output)
    }
    
    fn generate_function(&self, function: &Function) -> Result<String> {
        let mut output = String::new();
        
        // Function definition
        output.push_str("        public static ");
        output.push_str(&self.convert_return_type(&function.return_type));
        output.push_str(&format!(" {}(", function.name));
        
        // Parameters
        for (i, param) in function.parameters.iter().enumerate() {
            if i > 0 {
                output.push_str(", ");
            }
            output.push_str(&self.convert_type(param.param_type.as_ref()));
            output.push(' ');
            output.push_str(&param.name);
        }
        
        output.push_str(")\n        {\n");
        
        // Function body
        for statement in &function.body {
            output.push_str(&format!("            {};\n", self.generate_statement(statement)?));
        }
        
        output.push_str("        }\n");
        Ok(output)
    }
    
    fn generate_statement(&self, statement: &Statement) -> Result<String> {
        match statement {
            Statement::VariableDeclaration { name, value, .. } => {
                if let Some(expr) = value {
                    Ok(format!("var {} = {}", name, self.generate_expression(expr)?))
                } else {
                    Ok(format!("object {};", name))
                }
            }
            Statement::Return { value, .. } => {
                if let Some(expr) = value {
                    Ok(format!("return {}", self.generate_expression(expr)?))
                } else {
                    Ok("return".to_string())
                }
            }
            Statement::Expression { expression, .. } => {
                self.generate_expression(expression)
            }
            Statement::If { condition, then_branch, else_branch, .. } => {
                let mut output = format!("if ({})\n            {{\n", self.generate_expression(condition)?);
                for stmt in then_branch {
                    output.push_str(&format!("                {};\n", self.generate_statement(stmt)?));
                }
                output.push_str("            }");
                if let Some(else_stmts) = else_branch {
                    output.push_str("\n            else\n            {\n");
                    for stmt in else_stmts {
                        output.push_str(&format!("                {};\n", self.generate_statement(stmt)?));
                    }
                    output.push_str("            }");
                }
                Ok(output)
            }
            _ => Ok("// Unsupported statement".to_string()),
        }
    }
    
    fn generate_expression(&self, expression: &Expression) -> Result<String> {
        match expression {
            Expression::Literal { value, .. } => {
                match value {
                    LiteralValue::Number(n) => Ok(n.to_string()),
                    LiteralValue::String(s) => Ok(format!("\"{}\"", s.replace('"', "\\\""))),
                    LiteralValue::Boolean(b) => Ok(if *b { "true" } else { "false" }.to_string()),
                    LiteralValue::Null => Ok("null".to_string()),
                }
            }
            Expression::Identifier { name, .. } => Ok(name.clone()),
            Expression::Binary { left, operator, right, .. } => {
                let left_str = self.generate_expression(left)?;
                let right_str = self.generate_expression(right)?;
                let op_str = match operator {
                    BinaryOperator::Add => "+",
                    BinaryOperator::Subtract => "-",
                    BinaryOperator::Multiply => "*",
                    BinaryOperator::Divide => "/",
                    BinaryOperator::Equal => "==",
                    BinaryOperator::NotEqual => "!=",
                    BinaryOperator::Less => "<",
                    BinaryOperator::Greater => ">",
                    BinaryOperator::LessEqual => "<=",
                    BinaryOperator::GreaterEqual => ">=",
                    BinaryOperator::And => "&&",
                    BinaryOperator::Or => "||",
                    _ => "/* unsupported op */",
                };
                Ok(format!("({} {} {})", left_str, op_str, right_str))
            }
            Expression::Call { callee, arguments, .. } => {
                let callee_str = self.generate_expression(callee)?;
                let args: Result<Vec<String>> = arguments.iter()
                    .map(|arg| self.generate_expression(arg))
                    .collect();
                let args_str = args?.join(", ");
                Ok(format!("{}({})", callee_str, args_str))
            }
            Expression::CrossCall { language, function, arguments, .. } => {
                let args: Result<Vec<String>> = arguments.iter()
                    .map(|arg| self.generate_expression(arg))
                    .collect();
                let args_str = args?.join(", ");
                Ok(format!("CrossCall(\"{}\", \"{}\", new object[] {{ {} }})", language, function, args_str))
            }
            _ => Ok("/* Unsupported expression */".to_string()),
        }
    }
    
    fn convert_return_type(&self, return_type: &Option<crate::types::Type>) -> String {
        match return_type {
            Some(crate::types::Type::Number) => "double",
            Some(crate::types::Type::String) => "string",
            Some(crate::types::Type::Boolean) => "bool",
            Some(crate::types::Type::Void) => "void",
            Some(crate::types::Type::Array(_)) => "object[]",
            Some(crate::types::Type::Object(_)) => "Dictionary<string, object>",
            _ => "object",
        }.to_string()
    }
    
    fn convert_type(&self, utopia_type: Option<&crate::types::Type>) -> String {
        match utopia_type {
            Some(crate::types::Type::Number) => "double".to_string(),
            Some(crate::types::Type::String) => "string".to_string(),
            Some(crate::types::Type::Boolean) => "bool".to_string(),
            Some(crate::types::Type::Array(_)) => "object[]".to_string(),
            Some(crate::types::Type::Object(_)) => "Dictionary<string, object>".to_string(),
            _ => "object".to_string(),
        }
    }
}

/// Visual Basic .NET code generator
pub struct VisualBasicTransformer;

impl Transformer for VisualBasicTransformer {
    fn transform(&self, program: &Program) -> Result<String> {
        let mut output = String::new();
        output.push_str("' Generated by Utopia Compiler - Visual Basic .NET Backend\n");
        output.push_str("' Multi-language support with runtime integration\n\n");
        
        // Add necessary imports
        output.push_str("Imports System\n");
        output.push_str("Imports System.Collections.Generic\n");
        output.push_str("Imports System.Linq\n\n");
        
        // Create main module
        output.push_str("Namespace Utopia.Generated\n");
        output.push_str("    Public Module Program\n");
        
        // Process language blocks
        for block in &program.language_blocks {
            if block.language == "visualbasic" || block.language == "vb" || block.language == "vbnet" || block.language == "main" {
                output.push_str(&self.generate_vb_block(block)?);
            } else {
                output.push_str(&self.generate_cross_language_stubs(block)?);
            }
        }
        
        // Global statements in main method
        if !program.global_statements.is_empty() {
            output.push_str("        Public Sub Main()\n");
            for statement in &program.global_statements {
                output.push_str(&format!("            {}\n", self.generate_statement(statement)?));
            }
            output.push_str("        End Sub\n");
        }
        
        output.push_str("    End Module\nEnd Namespace\n");
        Ok(output)
    }
    
    fn target_name(&self) -> &str {
        "visualbasic"
    }
    
    fn file_extension(&self) -> &str {
        ".vb"
    }
    
    fn supports_language(&self, language: &str) -> bool {
        matches!(language, "visualbasic" | "vb" | "vbnet")
    }
}

impl VisualBasicTransformer {
    fn generate_vb_block(&self, block: &LanguageBlock) -> Result<String> {
        let mut output = String::new();
        
        for function in &block.functions {
            output.push_str(&self.generate_function(function)?);
            output.push('\n');
        }
        
        for statement in &block.statements {
            output.push_str(&format!("        {}\n", self.generate_statement(statement)?));
        }
        
        Ok(output)
    }
    
    fn generate_cross_language_stubs(&self, block: &LanguageBlock) -> Result<String> {
        let mut output = String::new();
        output.push_str(&format!("        ' Cross-language block: {}\n", block.language));
        
        for function in &block.functions {
            output.push_str(&format!(
                "        Public Function {}(ParamArray args() As Object) As Object\n",
                function.name
            ));
            output.push_str(&format!(
                "            Throw New NotImplementedException(\"Cross-language call to {}::{}\")\n",
                block.language, function.name
            ));
            output.push_str("        End Function\n\n");
        }
        
        Ok(output)
    }
    
    fn generate_function(&self, function: &Function) -> Result<String> {
        let mut output = String::new();
        
        // Function definition
        output.push_str("        Public Function ");
        output.push_str(&function.name);
        output.push_str("(");
        
        // Parameters
        for (i, param) in function.parameters.iter().enumerate() {
            if i > 0 {
                output.push_str(", ");
            }
            output.push_str(&param.name);
            output.push_str(" As ");
            output.push_str(&self.convert_type(param.param_type.as_ref()));
        }
        
        output.push_str(") As ");
        output.push_str(&self.convert_return_type(&function.return_type));
        output.push('\n');
        
        // Function body
        for statement in &function.body {
            output.push_str(&format!("            {}\n", self.generate_statement(statement)?));
        }
        
        output.push_str("        End Function\n");
        Ok(output)
    }
    
    fn generate_statement(&self, statement: &Statement) -> Result<String> {
        match statement {
            Statement::VariableDeclaration { name, value, .. } => {
                if let Some(expr) = value {
                    Ok(format!("Dim {} = {}", name, self.generate_expression(expr)?))
                } else {
                    Ok(format!("Dim {} As Object", name))
                }
            }
            Statement::Return { value, .. } => {
                if let Some(expr) = value {
                    Ok(format!("Return {}", self.generate_expression(expr)?))
                } else {
                    Ok("Return Nothing".to_string())
                }
            }
            Statement::Expression { expression, .. } => {
                self.generate_expression(expression)
            }
            Statement::If { condition, then_branch, else_branch, .. } => {
                let mut output = format!("If {} Then\n", self.generate_expression(condition)?);
                for stmt in then_branch {
                    output.push_str(&format!("                {}\n", self.generate_statement(stmt)?));
                }
                if let Some(else_stmts) = else_branch {
                    output.push_str("            Else\n");
                    for stmt in else_stmts {
                        output.push_str(&format!("                {}\n", self.generate_statement(stmt)?));
                    }
                }
                output.push_str("            End If");
                Ok(output)
            }
            _ => Ok("' Unsupported statement".to_string()),
        }
    }
    
    fn generate_expression(&self, expression: &Expression) -> Result<String> {
        match expression {
            Expression::Literal { value, .. } => {
                match value {
                    LiteralValue::Number(n) => Ok(n.to_string()),
                    LiteralValue::String(s) => Ok(format!("\"{}\"", s.replace('"', "\"\""))),
                    LiteralValue::Boolean(b) => Ok(if *b { "True" } else { "False" }.to_string()),
                    LiteralValue::Null => Ok("Nothing".to_string()),
                }
            }
            Expression::Identifier { name, .. } => Ok(name.clone()),
            Expression::Binary { left, operator, right, .. } => {
                let left_str = self.generate_expression(left)?;
                let right_str = self.generate_expression(right)?;
                let op_str = match operator {
                    BinaryOperator::Add => "+",
                    BinaryOperator::Subtract => "-",
                    BinaryOperator::Multiply => "*",
                    BinaryOperator::Divide => "/",
                    BinaryOperator::Equal => "=",
                    BinaryOperator::NotEqual => "<>",
                    BinaryOperator::Less => "<",
                    BinaryOperator::Greater => ">",
                    BinaryOperator::LessEqual => "<=",
                    BinaryOperator::GreaterEqual => ">=",
                    BinaryOperator::And => "And",
                    BinaryOperator::Or => "Or",
                    _ => "' unsupported op '",
                };
                Ok(format!("({} {} {})", left_str, op_str, right_str))
            }
            Expression::Call { callee, arguments, .. } => {
                let callee_str = self.generate_expression(callee)?;
                let args: Result<Vec<String>> = arguments.iter()
                    .map(|arg| self.generate_expression(arg))
                    .collect();
                let args_str = args?.join(", ");
                Ok(format!("{}({})", callee_str, args_str))
            }
            Expression::CrossCall { language, function, arguments, .. } => {
                let args: Result<Vec<String>> = arguments.iter()
                    .map(|arg| self.generate_expression(arg))
                    .collect();
                let args_str = args?.join(", ");
                Ok(format!("CrossCall(\"{}\", \"{}\", New Object() {{ {} }})", language, function, args_str))
            }
            _ => Ok("' Unsupported expression '".to_string()),
        }
    }
    
    fn convert_return_type(&self, return_type: &Option<crate::types::Type>) -> String {
        match return_type {
            Some(crate::types::Type::Number) => "Double",
            Some(crate::types::Type::String) => "String",
            Some(crate::types::Type::Boolean) => "Boolean",
            Some(crate::types::Type::Void) => "Object",
            Some(crate::types::Type::Array(_)) => "Object()",
            Some(crate::types::Type::Object(_)) => "Dictionary(Of String, Object)",
            _ => "Object",
        }.to_string()
    }
    
    fn convert_type(&self, utopia_type: Option<&crate::types::Type>) -> String {
        match utopia_type {
            Some(crate::types::Type::Number) => "Double".to_string(),
            Some(crate::types::Type::String) => "String".to_string(),
            Some(crate::types::Type::Boolean) => "Boolean".to_string(),
            Some(crate::types::Type::Array(_)) => "Object()".to_string(),
            Some(crate::types::Type::Object(_)) => "Dictionary(Of String, Object)".to_string(),
            _ => "Object".to_string(),
        }
    }
}

/// Perl code generator
pub struct PerlTransformer;

impl Transformer for PerlTransformer {
    fn transform(&self, program: &Program) -> Result<String> {
        let mut output = String::new();
        output.push_str("#!/usr/bin/perl\n");
        output.push_str("# Generated by Utopia Compiler - Perl Backend\n");
        output.push_str("# Multi-language support with runtime integration\n\n");
        
        output.push_str("use strict;\n");
        output.push_str("use warnings;\n");
        output.push_str("use Data::Dumper;\n\n");
        
        // Process language blocks
        for block in &program.language_blocks {
            if block.language == "perl" || block.language == "pl" || block.language == "main" {
                output.push_str(&self.generate_perl_block(block)?);
            } else {
                output.push_str(&self.generate_cross_language_stubs(block)?);
            }
        }
        
        // Global statements
        if !program.global_statements.is_empty() {
            output.push_str("# Main execution\n");
            for statement in &program.global_statements {
                output.push_str(&format!("{};\n", self.generate_statement(statement)?));
            }
        }
        
        Ok(output)
    }
    
    fn target_name(&self) -> &str {
        "perl"
    }
    
    fn file_extension(&self) -> &str {
        ".pl"
    }
    
    fn supports_language(&self, language: &str) -> bool {
        matches!(language, "perl" | "pl")
    }
}

impl PerlTransformer {
    fn generate_perl_block(&self, block: &LanguageBlock) -> Result<String> {
        let mut output = String::new();
        
        for function in &block.functions {
            output.push_str(&self.generate_function(function)?);
            output.push('\n');
        }
        
        Ok(output)
    }
    
    fn generate_cross_language_stubs(&self, block: &LanguageBlock) -> Result<String> {
        let mut output = String::new();
        output.push_str(&format!("# Cross-language block: {}\n", block.language));
        
        for function in &block.functions {
            output.push_str(&format!("sub {} {{\n", function.name));
            output.push_str(&format!(
                "    die \"Cross-language call to {}::{} not implemented\";\n",
                block.language, function.name
            ));
            output.push_str("}\n\n");
        }
        
        Ok(output)
    }
    
    fn generate_function(&self, function: &Function) -> Result<String> {
        let mut output = String::new();
        
        output.push_str(&format!("sub {} {{\n", function.name));
        
        // Parameters
        if !function.parameters.is_empty() {
            output.push_str("    my (");
            for (i, param) in function.parameters.iter().enumerate() {
                if i > 0 {
                    output.push_str(", ");
                }
                output.push_str(&format!("${}", param.name));
            }
            output.push_str(") = @_;\n");
        }
        
        // Function body
        for statement in &function.body {
            output.push_str(&format!("    {};\n", self.generate_statement(statement)?));
        }
        
        output.push_str("}\n");
        Ok(output)
    }
    
    fn generate_statement(&self, statement: &Statement) -> Result<String> {
        match statement {
            Statement::VariableDeclaration { name, value, .. } => {
                if let Some(expr) = value {
                    Ok(format!("my ${} = {}", name, self.generate_expression(expr)?))
                } else {
                    Ok(format!("my ${};", name))
                }
            }
            Statement::Return { value, .. } => {
                if let Some(expr) = value {
                    Ok(format!("return {}", self.generate_expression(expr)?))
                } else {
                    Ok("return".to_string())
                }
            }
            Statement::Expression { expression, .. } => {
                self.generate_expression(expression)
            }
            _ => Ok("# Unsupported statement".to_string()),
        }
    }
    
    fn generate_expression(&self, expression: &Expression) -> Result<String> {
        match expression {
            Expression::Literal { value, .. } => {
                match value {
                    LiteralValue::Number(n) => Ok(n.to_string()),
                    LiteralValue::String(s) => Ok(format!("\"{}\"", s.replace('"', "\\\""))),
                    LiteralValue::Boolean(b) => Ok(if *b { "1" } else { "0" }.to_string()),
                    LiteralValue::Null => Ok("undef".to_string()),
                }
            }
            Expression::Identifier { name, .. } => Ok(format!("${}", name)),
            Expression::Binary { left, operator, right, .. } => {
                let left_str = self.generate_expression(left)?;
                let right_str = self.generate_expression(right)?;
                let op_str = match operator {
                    BinaryOperator::Add => "+",
                    BinaryOperator::Subtract => "-",
                    BinaryOperator::Multiply => "*",
                    BinaryOperator::Divide => "/",
                    BinaryOperator::Equal => "==",
                    BinaryOperator::NotEqual => "!=",
                    BinaryOperator::Less => "<",
                    BinaryOperator::Greater => ">",
                    BinaryOperator::LessEqual => "<=",
                    BinaryOperator::GreaterEqual => ">=",
                    BinaryOperator::And => "&&",
                    BinaryOperator::Or => "||",
                    _ => "# unsupported op #",
                };
                Ok(format!("({} {} {})", left_str, op_str, right_str))
            }
            Expression::Call { callee, arguments, .. } => {
                let callee_str = match callee.as_ref() {
                    Expression::Identifier { name, .. } => name.clone(),
                    _ => self.generate_expression(callee)?,
                };
                let args: Result<Vec<String>> = arguments.iter()
                    .map(|arg| self.generate_expression(arg))
                    .collect();
                let args_str = args?.join(", ");
                Ok(format!("{}({})", callee_str, args_str))
            }
            Expression::CrossCall { language, function, arguments, .. } => {
                let args: Result<Vec<String>> = arguments.iter()
                    .map(|arg| self.generate_expression(arg))
                    .collect();
                let args_str = args?.join(", ");
                Ok(format!("cross_call('{}', '{}', {})", language, function, args_str))
            }
            _ => Ok("# Unsupported expression #".to_string()),
        }
    }
}

/// PHP code generator
pub struct PHPTransformer;

impl Transformer for PHPTransformer {
    fn transform(&self, program: &Program) -> Result<String> {
        let mut output = String::new();
        output.push_str("<?php\n");
        output.push_str("// Generated by Utopia Compiler - PHP Backend\n");
        output.push_str("// Multi-language support with runtime integration\n\n");
        
        // Process language blocks
        for block in &program.language_blocks {
            if block.language == "php" || block.language == "main" {
                output.push_str(&self.generate_php_block(block)?);
            } else {
                output.push_str(&self.generate_cross_language_stubs(block)?);
            }
        }
        
        // Global statements
        if !program.global_statements.is_empty() {
            output.push_str("// Main execution\n");
            for statement in &program.global_statements {
                output.push_str(&format!("{};\n", self.generate_statement(statement)?));
            }
        }
        
        Ok(output)
    }
    
    fn target_name(&self) -> &str {
        "php"
    }
    
    fn file_extension(&self) -> &str {
        ".php"
    }
    
    fn supports_language(&self, language: &str) -> bool {
        language == "php"
    }
}

impl PHPTransformer {
    fn generate_php_block(&self, block: &LanguageBlock) -> Result<String> {
        let mut output = String::new();
        
        for function in &block.functions {
            output.push_str(&self.generate_function(function)?);
            output.push('\n');
        }
        
        Ok(output)
    }
    
    fn generate_cross_language_stubs(&self, block: &LanguageBlock) -> Result<String> {
        let mut output = String::new();
        output.push_str(&format!("// Cross-language block: {}\n", block.language));
        
        for function in &block.functions {
            output.push_str(&format!("function {}(...$args) {{\n", function.name));
            output.push_str(&format!(
                "    throw new Exception('Cross-language call to {}::{} not implemented');\n",
                block.language, function.name
            ));
            output.push_str("}\n\n");
        }
        
        Ok(output)
    }
    
    fn generate_function(&self, function: &Function) -> Result<String> {
        let mut output = String::new();
        
        output.push_str(&format!("function {}(", function.name));
        
        // Parameters
        for (i, param) in function.parameters.iter().enumerate() {
            if i > 0 {
                output.push_str(", ");
            }
            output.push_str(&format!("${}", param.name));
        }
        
        output.push_str(") {\n");
        
        // Function body
        for statement in &function.body {
            output.push_str(&format!("    {};\n", self.generate_statement(statement)?));
        }
        
        output.push_str("}\n");
        Ok(output)
    }
    
    fn generate_statement(&self, statement: &Statement) -> Result<String> {
        match statement {
            Statement::VariableDeclaration { name, value, .. } => {
                if let Some(expr) = value {
                    Ok(format!("${} = {}", name, self.generate_expression(expr)?))
                } else {
                    Ok(format!("${} = null;", name))
                }
            }
            Statement::Return { value, .. } => {
                if let Some(expr) = value {
                    Ok(format!("return {}", self.generate_expression(expr)?))
                } else {
                    Ok("return".to_string())
                }
            }
            Statement::Expression { expression, .. } => {
                self.generate_expression(expression)
            }
            _ => Ok("// Unsupported statement".to_string()),
        }
    }
    
    fn generate_expression(&self, expression: &Expression) -> Result<String> {
        match expression {
            Expression::Literal { value, .. } => {
                match value {
                    LiteralValue::Number(n) => Ok(n.to_string()),
                    LiteralValue::String(s) => Ok(format!("\"{}\"", s.replace('"', "\\\""))),
                    LiteralValue::Boolean(b) => Ok(if *b { "true" } else { "false" }.to_string()),
                    LiteralValue::Null => Ok("null".to_string()),
                }
            }
            Expression::Identifier { name, .. } => Ok(format!("${}", name)),
            Expression::Binary { left, operator, right, .. } => {
                let left_str = self.generate_expression(left)?;
                let right_str = self.generate_expression(right)?;
                let op_str = match operator {
                    BinaryOperator::Add => "+",
                    BinaryOperator::Subtract => "-",
                    BinaryOperator::Multiply => "*",
                    BinaryOperator::Divide => "/",
                    BinaryOperator::Equal => "==",
                    BinaryOperator::NotEqual => "!=",
                    BinaryOperator::Less => "<",
                    BinaryOperator::Greater => ">",
                    BinaryOperator::LessEqual => "<=",
                    BinaryOperator::GreaterEqual => ">=",
                    BinaryOperator::And => "&&",
                    BinaryOperator::Or => "||",
                    _ => "/* unsupported op */",
                };
                Ok(format!("({} {} {})", left_str, op_str, right_str))
            }
            Expression::Call { callee, arguments, .. } => {
                let callee_str = match callee.as_ref() {
                    Expression::Identifier { name, .. } => name.clone(),
                    _ => self.generate_expression(callee)?,
                };
                let args: Result<Vec<String>> = arguments.iter()
                    .map(|arg| self.generate_expression(arg))
                    .collect();
                let args_str = args?.join(", ");
                Ok(format!("{}({})", callee_str, args_str))
            }
            Expression::CrossCall { language, function, arguments, .. } => {
                let args: Result<Vec<String>> = arguments.iter()
                    .map(|arg| self.generate_expression(arg))
                    .collect();
                let args_str = args?.join(", ");
                Ok(format!("cross_call('{}', '{}', [{}])", language, function, args_str))
            }
            _ => Ok("/* Unsupported expression */".to_string()),
        }
    }
}

/// Ada code generator
pub struct AdaTransformer;

impl Transformer for AdaTransformer {
    fn transform(&self, program: &Program) -> Result<String> {
        let mut output = String::new();
        output.push_str("-- Generated by Utopia Compiler - Ada Backend\n");
        output.push_str("-- Multi-language support with runtime integration\n\n");
        
        // Add necessary with clauses
        output.push_str("with Ada.Text_IO;\n");
        output.push_str("with Ada.Integer_Text_IO;\n");
        output.push_str("with Ada.Float_Text_IO;\n");
        output.push_str("with Ada.Strings.Unbounded;\n");
        output.push_str("use Ada.Text_IO;\n");
        output.push_str("use Ada.Strings.Unbounded;\n\n");
        
        // Create main package
        output.push_str("package Utopia_Generated is\n\n");
        
        // Process language blocks for specifications
        for block in &program.language_blocks {
            if block.language == "ada" || block.language == "main" {
                output.push_str(&self.generate_ada_spec(block)?);
            } else {
                output.push_str(&self.generate_cross_language_specs(block)?);
            }
        }
        
        output.push_str("end Utopia_Generated;\n\n");
        
        // Package body
        output.push_str("package body Utopia_Generated is\n\n");
        
        // Process language blocks for implementations
        for block in &program.language_blocks {
            if block.language == "ada" || block.language == "main" {
                output.push_str(&self.generate_ada_body(block)?);
            } else {
                output.push_str(&self.generate_cross_language_bodies(block)?);
            }
        }
        
        // Main procedure if needed
        if !program.global_statements.is_empty() {
            output.push_str("   procedure Main is\n");
            for statement in &program.global_statements {
                output.push_str(&format!("      {};\n", self.generate_statement(statement)?));
            }
            output.push_str("   end Main;\n\n");
        }
        
        output.push_str("end Utopia_Generated;\n");
        Ok(output)
    }
    
    fn target_name(&self) -> &str {
        "ada"
    }
    
    fn file_extension(&self) -> &str {
        ".adb"
    }
    
    fn supports_language(&self, language: &str) -> bool {
        language == "ada"
    }
}

impl AdaTransformer {
    fn generate_ada_spec(&self, block: &LanguageBlock) -> Result<String> {
        let mut output = String::new();
        
        for function in &block.functions {
            output.push_str(&self.generate_function_spec(function)?);
        }
        
        Ok(output)
    }
    
    fn generate_ada_body(&self, block: &LanguageBlock) -> Result<String> {
        let mut output = String::new();
        
        for function in &block.functions {
            output.push_str(&self.generate_function_body(function)?);
            output.push('\n');
        }
        
        Ok(output)
    }
    
    fn generate_cross_language_specs(&self, block: &LanguageBlock) -> Result<String> {
        let mut output = String::new();
        output.push_str(&format!("   -- Cross-language block: {}\n", block.language));
        
        for function in &block.functions {
            output.push_str(&format!(
                "   function {} return String;\n",
                function.name
            ));
        }
        output.push('\n');
        
        Ok(output)
    }
    
    fn generate_cross_language_bodies(&self, block: &LanguageBlock) -> Result<String> {
        let mut output = String::new();
        output.push_str(&format!("   -- Cross-language block: {}\n", block.language));
        
        for function in &block.functions {
            output.push_str(&format!(
                "   function {} return String is\n",
                function.name
            ));
            output.push_str("   begin\n");
            output.push_str(&format!(
                "      raise Program_Error with \"Cross-language call to {}::{} not implemented\";\n",
                block.language, function.name
            ));
            output.push_str(&format!("   end {};\n\n", function.name));
        }
        
        Ok(output)
    }
    
    fn generate_function_spec(&self, function: &Function) -> Result<String> {
        let mut output = String::new();
        
        if function.parameters.is_empty() {
            output.push_str(&format!("   function {}", function.name));
        } else {
            output.push_str(&format!("   function {} (", function.name));
            for (i, param) in function.parameters.iter().enumerate() {
                if i > 0 {
                    output.push_str("; ");
                }
                output.push_str(&format!("{} : {}", param.name, self.convert_type(param.param_type.as_ref())));
            }
            output.push(')');
        }
        
        output.push_str(&format!(" return {};\n", self.convert_return_type(&function.return_type)));
        Ok(output)
    }
    
    fn generate_function_body(&self, function: &Function) -> Result<String> {
        let mut output = String::new();
        
        if function.parameters.is_empty() {
            output.push_str(&format!("   function {} return {} is\n", function.name, self.convert_return_type(&function.return_type)));
        } else {
            output.push_str(&format!("   function {} (", function.name));
            for (i, param) in function.parameters.iter().enumerate() {
                if i > 0 {
                    output.push_str("; ");
                }
                output.push_str(&format!("{} : {}", param.name, self.convert_type(param.param_type.as_ref())));
            }
            output.push_str(&format!(") return {} is\n", self.convert_return_type(&function.return_type)));
        }
        
        output.push_str("   begin\n");
        
        // Function body
        for statement in &function.body {
            output.push_str(&format!("      {};\n", self.generate_statement(statement)?));
        }
        
        output.push_str(&format!("   end {};\n", function.name));
        Ok(output)
    }
    
    fn generate_statement(&self, statement: &Statement) -> Result<String> {
        match statement {
            Statement::VariableDeclaration { name, value, .. } => {
                if let Some(expr) = value {
                    Ok(format!("{} : constant := {}", name, self.generate_expression(expr)?))
                } else {
                    Ok(format!("{} : String;", name))
                }
            }
            Statement::Return { value, .. } => {
                if let Some(expr) = value {
                    Ok(format!("return {}", self.generate_expression(expr)?))
                } else {
                    Ok("return".to_string())
                }
            }
            Statement::Expression { expression, .. } => {
                self.generate_expression(expression)
            }
            Statement::If { condition, then_branch, else_branch, .. } => {
                let mut output = format!("if {} then\n", self.generate_expression(condition)?);
                for stmt in then_branch {
                    output.push_str(&format!("         {};\n", self.generate_statement(stmt)?));
                }
                if let Some(else_stmts) = else_branch {
                    output.push_str("      else\n");
                    for stmt in else_stmts {
                        output.push_str(&format!("         {};\n", self.generate_statement(stmt)?));
                    }
                }
                output.push_str("      end if");
                Ok(output)
            }
            _ => Ok("-- Unsupported statement".to_string()),
        }
    }
    
    fn generate_expression(&self, expression: &Expression) -> Result<String> {
        match expression {
            Expression::Literal { value, .. } => {
                match value {
                    LiteralValue::Number(n) => Ok(n.to_string()),
                    LiteralValue::String(s) => Ok(format!("\"{}\"", s.replace('"', "\"\""))),
                    LiteralValue::Boolean(b) => Ok(if *b { "True" } else { "False" }.to_string()),
                    LiteralValue::Null => Ok("null".to_string()),
                }
            }
            Expression::Identifier { name, .. } => Ok(name.clone()),
            Expression::Binary { left, operator, right, .. } => {
                let left_str = self.generate_expression(left)?;
                let right_str = self.generate_expression(right)?;
                let op_str = match operator {
                    BinaryOperator::Add => "+",
                    BinaryOperator::Subtract => "-",
                    BinaryOperator::Multiply => "*",
                    BinaryOperator::Divide => "/",
                    BinaryOperator::Equal => "=",
                    BinaryOperator::NotEqual => "/=",
                    BinaryOperator::Less => "<",
                    BinaryOperator::Greater => ">",
                    BinaryOperator::LessEqual => "<=",
                    BinaryOperator::GreaterEqual => ">=",
                    BinaryOperator::And => "and",
                    BinaryOperator::Or => "or",
                    _ => "-- unsupported op --",
                };
                Ok(format!("({} {} {})", left_str, op_str, right_str))
            }
            Expression::Call { callee, arguments, .. } => {
                let callee_str = match callee.as_ref() {
                    Expression::Identifier { name, .. } => name.clone(),
                    _ => self.generate_expression(callee)?,
                };
                let args: Result<Vec<String>> = arguments.iter()
                    .map(|arg| self.generate_expression(arg))
                    .collect();
                let args_str = args?.join(", ");
                Ok(format!("{}({})", callee_str, args_str))
            }
            Expression::CrossCall { language, function, arguments, .. } => {
                let args: Result<Vec<String>> = arguments.iter()
                    .map(|arg| self.generate_expression(arg))
                    .collect();
                let args_str = args?.join(", ");
                Ok(format!("Cross_Call(\"{}\", \"{}\", ({}))", language, function, args_str))
            }
            _ => Ok("-- Unsupported expression --".to_string()),
        }
    }
    
    fn convert_return_type(&self, return_type: &Option<crate::types::Type>) -> String {
        match return_type {
            Some(crate::types::Type::Number) => "Float",
            Some(crate::types::Type::String) => "String",
            Some(crate::types::Type::Boolean) => "Boolean",
            Some(crate::types::Type::Void) => "String",
            Some(crate::types::Type::Array(_)) => "String", // Simplified
            Some(crate::types::Type::Object(_)) => "String", // Simplified
            _ => "String",
        }.to_string()
    }
    
    fn convert_type(&self, utopia_type: Option<&crate::types::Type>) -> String {
        match utopia_type {
            Some(crate::types::Type::Number) => "Float".to_string(),
            Some(crate::types::Type::String) => "String".to_string(),
            Some(crate::types::Type::Boolean) => "Boolean".to_string(),
            Some(crate::types::Type::Array(_)) => "String".to_string(), // Simplified
            Some(crate::types::Type::Object(_)) => "String".to_string(), // Simplified
            _ => "String".to_string(),
        }
    }
}

/// Delphi/Object Pascal code generator
pub struct DelphiTransformer;

impl Transformer for DelphiTransformer {
    fn transform(&self, program: &Program) -> Result<String> {
        let mut output = String::new();
        output.push_str("{ Generated by Utopia Compiler - Delphi/Object Pascal Backend }\n");
        output.push_str("{ Multi-language support with runtime integration }\n\n");
        
        // Create unit
        output.push_str("unit UtopiaGenerated;\n\n");
        output.push_str("interface\n\n");
        
        // Add necessary uses clause
        output.push_str("uses\n");
        output.push_str("  SysUtils, Classes, Variants;\n\n");
        
        // Forward declarations
        for block in &program.language_blocks {
            if block.language == "delphi" || block.language == "pascal" || block.language == "main" {
                output.push_str(&self.generate_delphi_interface(block)?);
            } else {
                output.push_str(&self.generate_cross_language_interface(block)?);
            }
        }
        
        output.push_str("implementation\n\n");
        
        // Process language blocks for implementations
        for block in &program.language_blocks {
            if block.language == "delphi" || block.language == "pascal" || block.language == "main" {
                output.push_str(&self.generate_delphi_implementation(block)?);
            } else {
                output.push_str(&self.generate_cross_language_implementation(block)?);
            }
        }
        
        // Main procedure if needed
        if !program.global_statements.is_empty() {
            output.push_str("procedure Main;\nbegin\n");
            for statement in &program.global_statements {
                output.push_str(&format!("  {};\n", self.generate_statement(statement)?));
            }
            output.push_str("end;\n\n");
        }
        
        output.push_str("end.\n");
        Ok(output)
    }
    
    fn target_name(&self) -> &str {
        "delphi"
    }
    
    fn file_extension(&self) -> &str {
        ".pas"
    }
    
    fn supports_language(&self, language: &str) -> bool {
        matches!(language, "delphi" | "pascal")
    }
}

impl DelphiTransformer {
    fn generate_delphi_interface(&self, block: &LanguageBlock) -> Result<String> {
        let mut output = String::new();
        
        for function in &block.functions {
            output.push_str(&self.generate_function_interface(function)?);
        }
        
        Ok(output)
    }
    
    fn generate_delphi_implementation(&self, block: &LanguageBlock) -> Result<String> {
        let mut output = String::new();
        
        for function in &block.functions {
            output.push_str(&self.generate_function_implementation(function)?);
            output.push('\n');
        }
        
        Ok(output)
    }
    
    fn generate_cross_language_interface(&self, block: &LanguageBlock) -> Result<String> {
        let mut output = String::new();
        output.push_str(&format!("{{ Cross-language block: {} }}\n", block.language));
        
        for function in &block.functions {
            output.push_str(&format!(
                "function {}: string;\n",
                function.name
            ));
        }
        output.push('\n');
        
        Ok(output)
    }
    
    fn generate_cross_language_implementation(&self, block: &LanguageBlock) -> Result<String> {
        let mut output = String::new();
        output.push_str(&format!("{{ Cross-language block: {} }}\n", block.language));
        
        for function in &block.functions {
            output.push_str(&format!(
                "function {}: string;\nbegin\n",
                function.name
            ));
            output.push_str(&format!(
                "  raise Exception.Create('Cross-language call to {}::{} not implemented');\n",
                block.language, function.name
            ));
            output.push_str("end;\n\n");
        }
        
        Ok(output)
    }
    
    fn generate_function_interface(&self, function: &Function) -> Result<String> {
        let mut output = String::new();
        
        if function.parameters.is_empty() {
            output.push_str(&format!("function {}", function.name));
        } else {
            output.push_str(&format!("function {}(", function.name));
            for (i, param) in function.parameters.iter().enumerate() {
                if i > 0 {
                    output.push_str("; ");
                }
                output.push_str(&format!("{}: {}", param.name, self.convert_type(param.param_type.as_ref())));
            }
            output.push(')');
        }
        
        output.push_str(&format!(": {};\n", self.convert_return_type(&function.return_type)));
        Ok(output)
    }
    
    fn generate_function_implementation(&self, function: &Function) -> Result<String> {
        let mut output = String::new();
        
        if function.parameters.is_empty() {
            output.push_str(&format!("function {}: {};\n", function.name, self.convert_return_type(&function.return_type)));
        } else {
            output.push_str(&format!("function {}(", function.name));
            for (i, param) in function.parameters.iter().enumerate() {
                if i > 0 {
                    output.push_str("; ");
                }
                output.push_str(&format!("{}: {}", param.name, self.convert_type(param.param_type.as_ref())));
            }
            output.push_str(&format!("): {};\n", self.convert_return_type(&function.return_type)));
        }
        
        output.push_str("begin\n");
        
        // Function body
        for statement in &function.body {
            output.push_str(&format!("  {};\n", self.generate_statement(statement)?));
        }
        
        output.push_str("end;\n");
        Ok(output)
    }
    
    fn generate_statement(&self, statement: &Statement) -> Result<String> {
        match statement {
            Statement::VariableDeclaration { name, value, .. } => {
                if let Some(expr) = value {
                    Ok(format!("{} := {}", name, self.generate_expression(expr)?))
                } else {
                    Ok(format!("var {}: string;", name))
                }
            }
            Statement::Return { value, .. } => {
                if let Some(expr) = value {
                    Ok(format!("Result := {}", self.generate_expression(expr)?))
                } else {
                    Ok("Exit".to_string())
                }
            }
            Statement::Expression { expression, .. } => {
                self.generate_expression(expression)
            }
            Statement::If { condition, then_branch, else_branch, .. } => {
                let mut output = format!("if {} then\n  begin\n", self.generate_expression(condition)?);
                for stmt in then_branch {
                    output.push_str(&format!("    {};\n", self.generate_statement(stmt)?));
                }
                output.push_str("  end");
                if let Some(else_stmts) = else_branch {
                    output.push_str("\n  else\n  begin\n");
                    for stmt in else_stmts {
                        output.push_str(&format!("    {};\n", self.generate_statement(stmt)?));
                    }
                    output.push_str("  end");
                }
                Ok(output)
            }
            _ => Ok("{{ Unsupported statement }}".to_string()),
        }
    }
    
    fn generate_expression(&self, expression: &Expression) -> Result<String> {
        match expression {
            Expression::Literal { value, .. } => {
                match value {
                    LiteralValue::Number(n) => Ok(n.to_string()),
                    LiteralValue::String(s) => Ok(format!("'{}'", s.replace('\'', "''"))),
                    LiteralValue::Boolean(b) => Ok(if *b { "True" } else { "False" }.to_string()),
                    LiteralValue::Null => Ok("nil".to_string()),
                }
            }
            Expression::Identifier { name, .. } => Ok(name.clone()),
            Expression::Binary { left, operator, right, .. } => {
                let left_str = self.generate_expression(left)?;
                let right_str = self.generate_expression(right)?;
                let op_str = match operator {
                    BinaryOperator::Add => "+",
                    BinaryOperator::Subtract => "-",
                    BinaryOperator::Multiply => "*",
                    BinaryOperator::Divide => "/",
                    BinaryOperator::Equal => "=",
                    BinaryOperator::NotEqual => "<>",
                    BinaryOperator::Less => "<",
                    BinaryOperator::Greater => ">",
                    BinaryOperator::LessEqual => "<=",
                    BinaryOperator::GreaterEqual => ">=",
                    BinaryOperator::And => "and",
                    BinaryOperator::Or => "or",
                    _ => "{{ unsupported op }}",
                };
                Ok(format!("({} {} {})", left_str, op_str, right_str))
            }
            Expression::Call { callee, arguments, .. } => {
                let callee_str = match callee.as_ref() {
                    Expression::Identifier { name, .. } => name.clone(),
                    _ => self.generate_expression(callee)?,
                };
                let args: Result<Vec<String>> = arguments.iter()
                    .map(|arg| self.generate_expression(arg))
                    .collect();
                let args_str = args?.join(", ");
                Ok(format!("{}({})", callee_str, args_str))
            }
            Expression::CrossCall { language, function, arguments, .. } => {
                let args: Result<Vec<String>> = arguments.iter()
                    .map(|arg| self.generate_expression(arg))
                    .collect();
                let args_str = args?.join(", ");
                Ok(format!("CrossCall('{}', '{}', [{}])", language, function, args_str))
            }
            _ => Ok("{{ Unsupported expression }}".to_string()),
        }
    }
    
    fn convert_return_type(&self, return_type: &Option<crate::types::Type>) -> String {
        match return_type {
            Some(crate::types::Type::Number) => "Double",
            Some(crate::types::Type::String) => "string",
            Some(crate::types::Type::Boolean) => "Boolean",
            Some(crate::types::Type::Void) => "string",
            Some(crate::types::Type::Array(_)) => "TArray<Variant>", 
            Some(crate::types::Type::Object(_)) => "Variant",
            _ => "string",
        }.to_string()
    }
    
    fn convert_type(&self, utopia_type: Option<&crate::types::Type>) -> String {
        match utopia_type {
            Some(crate::types::Type::Number) => "Double".to_string(),
            Some(crate::types::Type::String) => "string".to_string(),
            Some(crate::types::Type::Boolean) => "Boolean".to_string(),
            Some(crate::types::Type::Array(_)) => "TArray<Variant>".to_string(),
            Some(crate::types::Type::Object(_)) => "Variant".to_string(),
            _ => "string".to_string(),
        }
    }
}

/// Fortran code generator
pub struct FortranTransformer;

impl Transformer for FortranTransformer {
    fn transform(&self, program: &Program) -> Result<String> {
        let mut output = String::new();
        output.push_str("! Generated by Utopia Compiler - Fortran Backend\n");
        output.push_str("! Multi-language support with runtime integration\n\n");
        
        // Create module
        output.push_str("module utopia_generated\n");
        output.push_str("    implicit none\n\n");
        
        // Module variables if needed
        if !program.global_statements.is_empty() {
            output.push_str("    ! Global variables\n");
            for statement in &program.global_statements {
                if let Statement::VariableDeclaration { name, .. } = statement {
                    output.push_str(&format!("    real :: {}\n", name));
                }
            }
            output.push('\n');
        }
        
        output.push_str("contains\n\n");
        
        // Process language blocks
        for block in &program.language_blocks {
            if block.language == "fortran" || block.language == "f90" || block.language == "f95" || block.language == "main" {
                output.push_str(&self.generate_fortran_procedures(block)?);
            } else {
                output.push_str(&self.generate_cross_language_procedures(block)?);
            }
        }
        
        // Main program if needed
        if !program.global_statements.is_empty() {
            output.push_str("    subroutine main_program()\n");
            for statement in &program.global_statements {
                output.push_str(&format!("        call {}()\n", self.generate_statement(statement)?));
            }
            output.push_str("    end subroutine main_program\n\n");
        }
        
        output.push_str("end module utopia_generated\n\n");
        
        // Main program unit
        output.push_str("program utopia_main\n");
        output.push_str("    use utopia_generated\n");
        output.push_str("    implicit none\n\n");
        if !program.global_statements.is_empty() {
            output.push_str("    call main_program()\n");
        }
        output.push_str("end program utopia_main\n");
        
        Ok(output)
    }
    
    fn target_name(&self) -> &str {
        "fortran"
    }
    
    fn file_extension(&self) -> &str {
        ".f90"
    }
    
    fn supports_language(&self, language: &str) -> bool {
        matches!(language, "fortran" | "f90" | "f95")
    }
}

impl FortranTransformer {
    fn generate_fortran_procedures(&self, block: &LanguageBlock) -> Result<String> {
        let mut output = String::new();
        
        for function in &block.functions {
            output.push_str(&self.generate_function(function)?);
            output.push('\n');
        }
        
        Ok(output)
    }
    
    fn generate_cross_language_procedures(&self, block: &LanguageBlock) -> Result<String> {
        let mut output = String::new();
        output.push_str(&format!("    ! Cross-language block: {}\n", block.language));
        
        for function in &block.functions {
            output.push_str(&format!(
                "    function {}() result(res)\n",
                function.name
            ));
            output.push_str("        character(len=100) :: res\n");
            output.push_str(&format!(
                "        stop 'Cross-language call to {}::{} not implemented'\n",
                block.language, function.name
            ));
            output.push_str(&format!("    end function {}\n\n", function.name));
        }
        
        Ok(output)
    }
    
    fn generate_function(&self, function: &Function) -> Result<String> {
        let mut output = String::new();
        
        // Determine if it's a function or subroutine
        // Functions with return statements are treated as functions
        let has_return_value = function.body.iter().any(|stmt| matches!(stmt, Statement::Return { .. }));
        
        if has_return_value {
            output.push_str(&format!("    function {}(", function.name));
        } else {
            output.push_str(&format!("    subroutine {}(", function.name));
        }
        
        // Parameters
        for (i, param) in function.parameters.iter().enumerate() {
            if i > 0 {
                output.push_str(", ");
            }
            output.push_str(&param.name);
        }
        
        if has_return_value {
            output.push_str(") result(res)\n");
            output.push_str("        implicit none\n");
            
            // Parameter declarations
            for param in &function.parameters {
                output.push_str(&format!("        {} :: {}\n", 
                    self.convert_type(param.param_type.as_ref()), param.name));
            }
            
            // Result variable
            output.push_str(&format!("        {} :: res\n\n", 
                self.convert_return_type(&function.return_type)));
        } else {
            output.push_str(")\n");
            output.push_str("        implicit none\n");
            
            // Parameter declarations
            for param in &function.parameters {
                output.push_str(&format!("        {} :: {}\n", 
                    self.convert_type(param.param_type.as_ref()), param.name));
            }
            output.push('\n');
        }
        
        // Function body
        for statement in &function.body {
            output.push_str(&format!("        {}\n", self.generate_statement(statement)?));
        }
        
        if has_return_value {
            output.push_str(&format!("    end function {}\n", function.name));
        } else {
            output.push_str(&format!("    end subroutine {}\n", function.name));
        }
        
        Ok(output)
    }
    
    fn generate_statement(&self, statement: &Statement) -> Result<String> {
        match statement {
            Statement::VariableDeclaration { name, value, .. } => {
                if let Some(expr) = value {
                    Ok(format!("{} = {}", name, self.generate_expression(expr)?))
                } else {
                    Ok(format!("real :: {}", name))
                }
            }
            Statement::Return { value, .. } => {
                if let Some(expr) = value {
                    Ok(format!("res = {}", self.generate_expression(expr)?))
                } else {
                    Ok("return".to_string())
                }
            }
            Statement::Expression { expression, .. } => {
                self.generate_expression(expression)
            }
            Statement::If { condition, then_branch, else_branch, .. } => {
                let mut output = format!("if ({}) then\n", self.generate_expression(condition)?);
                for stmt in then_branch {
                    output.push_str(&format!("            {}\n", self.generate_statement(stmt)?));
                }
                if let Some(else_stmts) = else_branch {
                    output.push_str("        else\n");
                    for stmt in else_stmts {
                        output.push_str(&format!("            {}\n", self.generate_statement(stmt)?));
                    }
                }
                output.push_str("        end if");
                Ok(output)
            }
            _ => Ok("! Unsupported statement".to_string()),
        }
    }
    
    fn generate_expression(&self, expression: &Expression) -> Result<String> {
        match expression {
            Expression::Literal { value, .. } => {
                match value {
                    LiteralValue::Number(n) => Ok(n.to_string()),
                    LiteralValue::String(s) => Ok(format!("'{}'", s.replace('\'', "''"))),
                    LiteralValue::Boolean(b) => Ok(if *b { ".true." } else { ".false." }.to_string()),
                    LiteralValue::Null => Ok("0.0".to_string()), // Fortran doesn't have null, use zero
                }
            }
            Expression::Identifier { name, .. } => Ok(name.clone()),
            Expression::Binary { left, operator, right, .. } => {
                let left_str = self.generate_expression(left)?;
                let right_str = self.generate_expression(right)?;
                let op_str = match operator {
                    BinaryOperator::Add => "+",
                    BinaryOperator::Subtract => "-",
                    BinaryOperator::Multiply => "*",
                    BinaryOperator::Divide => "/",
                    BinaryOperator::Equal => "==",
                    BinaryOperator::NotEqual => "/=",
                    BinaryOperator::Less => "<",
                    BinaryOperator::Greater => ">",
                    BinaryOperator::LessEqual => "<=",
                    BinaryOperator::GreaterEqual => ">=",
                    BinaryOperator::And => ".and.",
                    BinaryOperator::Or => ".or.",
                    _ => "! unsupported op !",
                };
                Ok(format!("({} {} {})", left_str, op_str, right_str))
            }
            Expression::Call { callee, arguments, .. } => {
                let callee_str = match callee.as_ref() {
                    Expression::Identifier { name, .. } => name.clone(),
                    _ => self.generate_expression(callee)?,
                };
                let args: Result<Vec<String>> = arguments.iter()
                    .map(|arg| self.generate_expression(arg))
                    .collect();
                let args_str = args?.join(", ");
                Ok(format!("{}({})", callee_str, args_str))
            }
            Expression::CrossCall { language, function, arguments, .. } => {
                let args: Result<Vec<String>> = arguments.iter()
                    .map(|arg| self.generate_expression(arg))
                    .collect();
                let args_str = args?.join(", ");
                Ok(format!("cross_call('{}', '{}', [{}])", language, function, args_str))
            }
            _ => Ok("! Unsupported expression !".to_string()),
        }
    }
    
    fn convert_return_type(&self, return_type: &Option<crate::types::Type>) -> String {
        match return_type {
            Some(crate::types::Type::Number) => "real",
            Some(crate::types::Type::String) => "character(len=100)",
            Some(crate::types::Type::Boolean) => "logical",
            Some(crate::types::Type::Void) => "void",
            Some(crate::types::Type::Array(_)) => "real, dimension(:)",
            Some(crate::types::Type::Object(_)) => "character(len=100)",
            _ => "real",
        }.to_string()
    }
    
    fn convert_type(&self, utopia_type: Option<&crate::types::Type>) -> String {
        match utopia_type {
            Some(crate::types::Type::Number) => "real".to_string(),
            Some(crate::types::Type::String) => "character(len=100)".to_string(),
            Some(crate::types::Type::Boolean) => "logical".to_string(),
            Some(crate::types::Type::Array(_)) => "real, dimension(:)".to_string(),
            Some(crate::types::Type::Object(_)) => "character(len=100)".to_string(),
            _ => "real".to_string(),
        }
    }
}

/// SQL code generator
pub struct SQLTransformer;

impl Transformer for SQLTransformer {
    fn transform(&self, program: &Program) -> Result<String> {
        let mut output = String::new();
        output.push_str("-- Generated by Utopia Compiler - SQL Backend\n");
        output.push_str("-- Multi-language support with runtime integration\n\n");
        
        // Create database schema if needed
        output.push_str("-- Database schema and procedures\n");
        output.push_str("-- Note: Adapt connection strings and syntax for your specific RDBMS\n\n");
        
        // Process language blocks
        for block in &program.language_blocks {
            if block.language == "sql" || block.language == "main" {
                output.push_str(&self.generate_sql_procedures(block)?);
            } else {
                output.push_str(&self.generate_cross_language_procedures(block)?);
            }
        }
        
        // Main execution if needed
        if !program.global_statements.is_empty() {
            output.push_str("-- Main execution block\n");
            output.push_str("BEGIN\n");
            for statement in &program.global_statements {
                output.push_str(&format!("    {};\n", self.generate_statement(statement)?));
            }
            output.push_str("END;\n/\n\n");
        }
        
        Ok(output)
    }
    
    fn target_name(&self) -> &str {
        "sql"
    }
    
    fn file_extension(&self) -> &str {
        ".sql"
    }
    
    fn supports_language(&self, language: &str) -> bool {
        language == "sql"
    }
}

impl SQLTransformer {
    fn generate_sql_procedures(&self, block: &LanguageBlock) -> Result<String> {
        let mut output = String::new();
        
        for function in &block.functions {
            output.push_str(&self.generate_function(function)?);
            output.push('\n');
        }
        
        Ok(output)
    }
    
    fn generate_cross_language_procedures(&self, block: &LanguageBlock) -> Result<String> {
        let mut output = String::new();
        output.push_str(&format!("-- Cross-language block: {}\n", block.language));
        
        for function in &block.functions {
            output.push_str(&format!(
                "CREATE OR REPLACE FUNCTION {}() RETURN VARCHAR2\nIS\nBEGIN\n",
                function.name
            ));
            output.push_str(&format!(
                "    RAISE_APPLICATION_ERROR(-20001, 'Cross-language call to {}::{} not implemented');\n",
                block.language, function.name
            ));
            output.push_str("END;\n/\n\n");
        }
        
        Ok(output)
    }
    
    fn generate_function(&self, function: &Function) -> Result<String> {
        let mut output = String::new();
        
        // Determine return type
        let return_type = self.convert_return_type(&function.return_type);
        
        // Function signature
        output.push_str(&format!("CREATE OR REPLACE FUNCTION {}", function.name));
        
        if !function.parameters.is_empty() {
            output.push_str("(\n");
            for (i, param) in function.parameters.iter().enumerate() {
                if i > 0 {
                    output.push_str(",\n");
                }
                output.push_str(&format!("    {} IN {}", 
                    param.name, self.convert_type(param.param_type.as_ref())));
            }
            output.push_str("\n)");
        }
        
        output.push_str(&format!("\nRETURN {}\nIS\n", return_type));
        
        // Local variables if needed
        output.push_str(&format!("    result_value {};\n", return_type));
        output.push_str("BEGIN\n");
        
        // Function body
        for statement in &function.body {
            output.push_str(&format!("    {};\n", self.generate_statement(statement)?));
        }
        
        output.push_str("    RETURN result_value;\n");
        output.push_str("END;\n/\n");
        
        Ok(output)
    }
    
    fn generate_statement(&self, statement: &Statement) -> Result<String> {
        match statement {
            Statement::VariableDeclaration { name, value, .. } => {
                if let Some(expr) = value {
                    Ok(format!("{} := {}", name, self.generate_expression(expr)?))
                } else {
                    Ok(format!("DECLARE {} VARCHAR2(4000);", name))
                }
            }
            Statement::Return { value, .. } => {
                if let Some(expr) = value {
                    Ok(format!("result_value := {}", self.generate_expression(expr)?))
                } else {
                    Ok("RETURN".to_string())
                }
            }
            Statement::Expression { expression, .. } => {
                // For SQL, expressions are often assignments or procedure calls
                match expression {
                    Expression::Call { .. } => {
                        Ok(format!("SELECT {} INTO result_value FROM DUAL", self.generate_expression(expression)?))
                    }
                    _ => self.generate_expression(expression)
                }
            }
            Statement::If { condition, then_branch, else_branch, .. } => {
                let mut output = format!("IF {} THEN\n", self.generate_expression(condition)?);
                for stmt in then_branch {
                    output.push_str(&format!("        {};\n", self.generate_statement(stmt)?));
                }
                if let Some(else_stmts) = else_branch {
                    output.push_str("    ELSE\n");
                    for stmt in else_stmts {
                        output.push_str(&format!("        {};\n", self.generate_statement(stmt)?));
                    }
                }
                output.push_str("    END IF");
                Ok(output)
            }
            _ => Ok("-- Unsupported statement".to_string()),
        }
    }
    
    fn generate_expression(&self, expression: &Expression) -> Result<String> {
        match expression {
            Expression::Literal { value, .. } => {
                match value {
                    LiteralValue::Number(n) => Ok(n.to_string()),
                    LiteralValue::String(s) => Ok(format!("'{}'", s.replace('\'', "''"))),
                    LiteralValue::Boolean(b) => Ok(if *b { "1" } else { "0" }.to_string()),
                    LiteralValue::Null => Ok("NULL".to_string()),
                }
            }
            Expression::Identifier { name, .. } => Ok(name.clone()),
            Expression::Binary { left, operator, right, .. } => {
                let left_str = self.generate_expression(left)?;
                let right_str = self.generate_expression(right)?;
                let op_str = match operator {
                    BinaryOperator::Add => "+",
                    BinaryOperator::Subtract => "-",
                    BinaryOperator::Multiply => "*",
                    BinaryOperator::Divide => "/",
                    BinaryOperator::Equal => "=",
                    BinaryOperator::NotEqual => "!=",
                    BinaryOperator::Less => "<",
                    BinaryOperator::Greater => ">",
                    BinaryOperator::LessEqual => "<=",
                    BinaryOperator::GreaterEqual => ">=",
                    BinaryOperator::And => "AND",
                    BinaryOperator::Or => "OR",
                    _ => "/* unsupported op */",
                };
                Ok(format!("({} {} {})", left_str, op_str, right_str))
            }
            Expression::Call { callee, arguments, .. } => {
                let callee_str = match callee.as_ref() {
                    Expression::Identifier { name, .. } => name.clone(),
                    _ => self.generate_expression(callee)?,
                };
                let args: Result<Vec<String>> = arguments.iter()
                    .map(|arg| self.generate_expression(arg))
                    .collect();
                let args_str = args?.join(", ");
                Ok(format!("{}({})", callee_str, args_str))
            }
            Expression::CrossCall { language, function, arguments, .. } => {
                let args: Result<Vec<String>> = arguments.iter()
                    .map(|arg| self.generate_expression(arg))
                    .collect();
                let args_str = args?.join(", ");
                Ok(format!("CROSS_CALL('{}', '{}', '{}')", language, function, args_str))
            }
            _ => Ok("/* Unsupported expression */".to_string()),
        }
    }
    
    fn convert_return_type(&self, return_type: &Option<crate::types::Type>) -> String {
        match return_type {
            Some(crate::types::Type::Number) => "NUMBER",
            Some(crate::types::Type::String) => "VARCHAR2(4000)",
            Some(crate::types::Type::Boolean) => "NUMBER(1)",
            Some(crate::types::Type::Void) => "VARCHAR2(1)",
            Some(crate::types::Type::Array(_)) => "VARCHAR2(4000)", // JSON representation
            Some(crate::types::Type::Object(_)) => "VARCHAR2(4000)", // JSON representation
            _ => "VARCHAR2(4000)",
        }.to_string()
    }
    
    fn convert_type(&self, utopia_type: Option<&crate::types::Type>) -> String {
        match utopia_type {
            Some(crate::types::Type::Number) => "NUMBER".to_string(),
            Some(crate::types::Type::String) => "VARCHAR2(4000)".to_string(),
            Some(crate::types::Type::Boolean) => "NUMBER(1)".to_string(),
            Some(crate::types::Type::Array(_)) => "VARCHAR2(4000)".to_string(),
            Some(crate::types::Type::Object(_)) => "VARCHAR2(4000)".to_string(),
            _ => "VARCHAR2(4000)".to_string(),
        }
    }
}

/// R code generator
pub struct RTransformer;

impl Transformer for RTransformer {
    fn transform(&self, program: &Program) -> Result<String> {
        let mut output = String::new();
        output.push_str("# Generated by Utopia Compiler - R Backend\n");
        output.push_str("# Multi-language support with runtime integration\n\n");
        
        // Add necessary libraries
        output.push_str("# Load required libraries\n");
        output.push_str("library(jsonlite)\n");
        output.push_str("library(httr)\n\n");
        
        // Process language blocks
        for block in &program.language_blocks {
            if block.language == "r" || block.language == "main" {
                output.push_str(&self.generate_r_functions(block)?);
            } else {
                output.push_str(&self.generate_cross_language_functions(block)?);
            }
        }
        
        // Global statements in main execution
        if !program.global_statements.is_empty() {
            output.push_str("# Main execution\n");
            for statement in &program.global_statements {
                output.push_str(&format!("{};\n", self.generate_statement(statement)?));
            }
        }
        
        Ok(output)
    }
    
    fn target_name(&self) -> &str {
        "r"
    }
    
    fn file_extension(&self) -> &str {
        ".R"
    }
    
    fn supports_language(&self, language: &str) -> bool {
        language == "r"
    }
}

impl RTransformer {
    fn generate_r_functions(&self, block: &LanguageBlock) -> Result<String> {
        let mut output = String::new();
        
        for function in &block.functions {
            output.push_str(&self.generate_function(function)?);
            output.push('\n');
        }
        
        Ok(output)
    }
    
    fn generate_cross_language_functions(&self, block: &LanguageBlock) -> Result<String> {
        let mut output = String::new();
        output.push_str(&format!("# Cross-language block: {}\n", block.language));
        
        for function in &block.functions {
            output.push_str(&format!("{} <- function(...) {{\n", function.name));
            output.push_str(&format!(
                "    stop('Cross-language call to {}::{} not implemented')\n",
                block.language, function.name
            ));
            output.push_str("}\n\n");
        }
        
        Ok(output)
    }
    
    fn generate_function(&self, function: &Function) -> Result<String> {
        let mut output = String::new();
        
        output.push_str(&format!("{} <- function(", function.name));
        
        // Parameters
        for (i, param) in function.parameters.iter().enumerate() {
            if i > 0 {
                output.push_str(", ");
            }
            output.push_str(&param.name);
        }
        
        output.push_str(") {\n");
        
        // Function body
        for statement in &function.body {
            output.push_str(&format!("    {};\n", self.generate_statement(statement)?));
        }
        
        output.push_str("}\n");
        Ok(output)
    }
    
    fn generate_statement(&self, statement: &Statement) -> Result<String> {
        match statement {
            Statement::VariableDeclaration { name, value, .. } => {
                if let Some(expr) = value {
                    Ok(format!("{} <- {}", name, self.generate_expression(expr)?))
                } else {
                    Ok(format!("{} <- NULL", name))
                }
            }
            Statement::Return { value, .. } => {
                if let Some(expr) = value {
                    Ok(format!("return({})", self.generate_expression(expr)?))
                } else {
                    Ok("return()".to_string())
                }
            }
            Statement::Expression { expression, .. } => {
                self.generate_expression(expression)
            }
            Statement::If { condition, then_branch, else_branch, .. } => {
                let mut output = format!("if ({}) {{\n", self.generate_expression(condition)?);
                for stmt in then_branch {
                    output.push_str(&format!("        {};\n", self.generate_statement(stmt)?));
                }
                output.push_str("    }");
                if let Some(else_stmts) = else_branch {
                    output.push_str(" else {\n");
                    for stmt in else_stmts {
                        output.push_str(&format!("        {};\n", self.generate_statement(stmt)?));
                    }
                    output.push_str("    }");
                }
                Ok(output)
            }
            _ => Ok("# Unsupported statement".to_string()),
        }
    }
    
    fn generate_expression(&self, expression: &Expression) -> Result<String> {
        match expression {
            Expression::Literal { value, .. } => {
                match value {
                    LiteralValue::Number(n) => Ok(n.to_string()),
                    LiteralValue::String(s) => Ok(format!("\"{}\"", s.replace('"', "\\\""))),
                    LiteralValue::Boolean(b) => Ok(if *b { "TRUE" } else { "FALSE" }.to_string()),
                    LiteralValue::Null => Ok("NULL".to_string()),
                }
            }
            Expression::Identifier { name, .. } => Ok(name.clone()),
            Expression::Binary { left, operator, right, .. } => {
                let left_str = self.generate_expression(left)?;
                let right_str = self.generate_expression(right)?;
                let op_str = match operator {
                    BinaryOperator::Add => "+",
                    BinaryOperator::Subtract => "-",
                    BinaryOperator::Multiply => "*",
                    BinaryOperator::Divide => "/",
                    BinaryOperator::Equal => "==",
                    BinaryOperator::NotEqual => "!=",
                    BinaryOperator::Less => "<",
                    BinaryOperator::Greater => ">",
                    BinaryOperator::LessEqual => "<=",
                    BinaryOperator::GreaterEqual => ">=",
                    BinaryOperator::And => "&",
                    BinaryOperator::Or => "|",
                    _ => "# unsupported op #",
                };
                Ok(format!("({} {} {})", left_str, op_str, right_str))
            }
            Expression::Call { callee, arguments, .. } => {
                let callee_str = match callee.as_ref() {
                    Expression::Identifier { name, .. } => name.clone(),
                    _ => self.generate_expression(callee)?,
                };
                let args: Result<Vec<String>> = arguments.iter()
                    .map(|arg| self.generate_expression(arg))
                    .collect();
                let args_str = args?.join(", ");
                Ok(format!("{}({})", callee_str, args_str))
            }
            Expression::CrossCall { language, function, arguments, .. } => {
                let args: Result<Vec<String>> = arguments.iter()
                    .map(|arg| self.generate_expression(arg))
                    .collect();
                let args_str = args?.join(", ");
                Ok(format!("cross_call('{}', '{}', list({}))", language, function, args_str))
            }
            _ => Ok("# Unsupported expression #".to_string()),
        }
    }
}

/// MATLAB code generator
pub struct MatlabTransformer;

impl Transformer for MatlabTransformer {
    fn transform(&self, program: &Program) -> Result<String> {
        let mut output = String::new();
        output.push_str("% Generated by Utopia Compiler - MATLAB Backend\n");
        output.push_str("% Multi-language support with runtime integration\n\n");
        
        // Process language blocks
        for block in &program.language_blocks {
            if block.language == "matlab" || block.language == "m" || block.language == "main" {
                output.push_str(&self.generate_matlab_functions(block)?);
            } else {
                output.push_str(&self.generate_cross_language_functions(block)?);
            }
        }
        
        // Global statements in main execution
        if !program.global_statements.is_empty() {
            output.push_str("% Main execution\n");
            for statement in &program.global_statements {
                output.push_str(&format!("{};\n", self.generate_statement(statement)?));
            }
        }
        
        Ok(output)
    }
    
    fn target_name(&self) -> &str {
        "matlab"
    }
    
    fn file_extension(&self) -> &str {
        ".m"
    }
    
    fn supports_language(&self, language: &str) -> bool {
        matches!(language, "matlab" | "m")
    }
}

impl MatlabTransformer {
    fn generate_matlab_functions(&self, block: &LanguageBlock) -> Result<String> {
        let mut output = String::new();
        
        for function in &block.functions {
            output.push_str(&self.generate_function(function)?);
            output.push('\n');
        }
        
        Ok(output)
    }
    
    fn generate_cross_language_functions(&self, block: &LanguageBlock) -> Result<String> {
        let mut output = String::new();
        output.push_str(&format!("% Cross-language block: {}\n", block.language));
        
        for function in &block.functions {
            output.push_str(&format!("function result = {}(varargin)\n", function.name));
            output.push_str(&format!(
                "    error('Cross-language call to {}::{} not implemented');\n",
                block.language, function.name
            ));
            output.push_str("end\n\n");
        }
        
        Ok(output)
    }
    
    fn generate_function(&self, function: &Function) -> Result<String> {
        let mut output = String::new();
        
        // Function signature - MATLAB style
        output.push_str("function ");
        
        // Return value (MATLAB functions can return values)
        let has_return = function.body.iter().any(|stmt| matches!(stmt, Statement::Return { .. }));
        if has_return {
            output.push_str("result = ");
        }
        
        output.push_str(&format!("{}(", function.name));
        
        // Parameters
        for (i, param) in function.parameters.iter().enumerate() {
            if i > 0 {
                output.push_str(", ");
            }
            output.push_str(&param.name);
        }
        
        output.push_str(")\n");
        
        // Function body
        for statement in &function.body {
            output.push_str(&format!("    {};\n", self.generate_statement(statement)?));
        }
        
        output.push_str("end\n");
        Ok(output)
    }
    
    fn generate_statement(&self, statement: &Statement) -> Result<String> {
        match statement {
            Statement::VariableDeclaration { name, value, .. } => {
                if let Some(expr) = value {
                    Ok(format!("{} = {}", name, self.generate_expression(expr)?))
                } else {
                    Ok(format!("{} = [];", name))
                }
            }
            Statement::Return { value, .. } => {
                if let Some(expr) = value {
                    Ok(format!("result = {}", self.generate_expression(expr)?))
                } else {
                    Ok("return".to_string())
                }
            }
            Statement::Expression { expression, .. } => {
                self.generate_expression(expression)
            }
            Statement::If { condition, then_branch, else_branch, .. } => {
                let mut output = format!("if {}\n", self.generate_expression(condition)?);
                for stmt in then_branch {
                    output.push_str(&format!("        {};\n", self.generate_statement(stmt)?));
                }
                if let Some(else_stmts) = else_branch {
                    output.push_str("    else\n");
                    for stmt in else_stmts {
                        output.push_str(&format!("        {};\n", self.generate_statement(stmt)?));
                    }
                }
                output.push_str("    end");
                Ok(output)
            }
            _ => Ok("% Unsupported statement".to_string()),
        }
    }
    
    fn generate_expression(&self, expression: &Expression) -> Result<String> {
        match expression {
            Expression::Literal { value, .. } => {
                match value {
                    LiteralValue::Number(n) => Ok(n.to_string()),
                    LiteralValue::String(s) => Ok(format!("'{}'", s.replace('\'', "''"))),
                    LiteralValue::Boolean(b) => Ok(if *b { "true" } else { "false" }.to_string()),
                    LiteralValue::Null => Ok("[]".to_string()),
                }
            }
            Expression::Identifier { name, .. } => Ok(name.clone()),
            Expression::Binary { left, operator, right, .. } => {
                let left_str = self.generate_expression(left)?;
                let right_str = self.generate_expression(right)?;
                let op_str = match operator {
                    BinaryOperator::Add => "+",
                    BinaryOperator::Subtract => "-",
                    BinaryOperator::Multiply => ".*",  // Element-wise multiplication in MATLAB
                    BinaryOperator::Divide => "./",    // Element-wise division in MATLAB
                    BinaryOperator::Equal => "==",
                    BinaryOperator::NotEqual => "~=",
                    BinaryOperator::Less => "<",
                    BinaryOperator::Greater => ">",
                    BinaryOperator::LessEqual => "<=",
                    BinaryOperator::GreaterEqual => ">=",
                    BinaryOperator::And => "&",
                    BinaryOperator::Or => "|",
                    _ => "% unsupported op %",
                };
                Ok(format!("({} {} {})", left_str, op_str, right_str))
            }
            Expression::Call { callee, arguments, .. } => {
                let callee_str = match callee.as_ref() {
                    Expression::Identifier { name, .. } => name.clone(),
                    _ => self.generate_expression(callee)?,
                };
                let args: Result<Vec<String>> = arguments.iter()
                    .map(|arg| self.generate_expression(arg))
                    .collect();
                let args_str = args?.join(", ");
                Ok(format!("{}({})", callee_str, args_str))
            }
            Expression::CrossCall { language, function, arguments, .. } => {
                let args: Result<Vec<String>> = arguments.iter()
                    .map(|arg| self.generate_expression(arg))
                    .collect();
                let args_str = args?.join(", ");
                Ok(format!("cross_call('{}', '{}', {{{}}})", language, function, args_str))
            }
            Expression::Unary { operator, operand, .. } => {
                let operand_str = self.generate_expression(operand)?;
                let op_str = match operator {
                    UnaryOperator::Minus => "-",
                    UnaryOperator::Plus => "+",
                    UnaryOperator::Not => "~",
                    _ => "% unsupported unary op %",
                };
                Ok(format!("({}{})", op_str, operand_str))
            }
            _ => Ok("% Unsupported expression %".to_string()),
        }
    }
}

/// Kotlin code generator
pub struct KotlinTransformer;

impl Transformer for KotlinTransformer {
    fn transform(&self, program: &Program) -> Result<String> {
        let mut output = String::new();
        output.push_str("// Generated by Utopia Compiler - Kotlin Backend\n");
        output.push_str("// Multi-language support with runtime integration\n\n");
        
        // Package declaration
        output.push_str("package utopia.generated\n\n");
        
        // Imports
        output.push_str("import kotlinx.coroutines.*\n");
        output.push_str("import kotlinx.serialization.*\n");
        output.push_str("import kotlinx.serialization.json.*\n\n");
        
        // Process language blocks
        for block in &program.language_blocks {
            if block.language == "kotlin" || block.language == "kt" || block.language == "main" {
                output.push_str(&self.generate_kotlin_functions(block)?);
            } else {
                output.push_str(&self.generate_cross_language_functions(block)?);
            }
        }
        
        // Main function if needed
        if !program.global_statements.is_empty() {
            output.push_str("fun main() {\n");
            for statement in &program.global_statements {
                output.push_str(&format!("    {}\n", self.generate_statement(statement)?));
            }
            output.push_str("}\n");
        }
        
        Ok(output)
    }
    
    fn target_name(&self) -> &str {
        "kotlin"
    }
    
    fn file_extension(&self) -> &str {
        ".kt"
    }
    
    fn supports_language(&self, language: &str) -> bool {
        matches!(language, "kotlin" | "kt")
    }
}

impl KotlinTransformer {
    fn generate_kotlin_functions(&self, block: &LanguageBlock) -> Result<String> {
        let mut output = String::new();
        
        for function in &block.functions {
            output.push_str(&self.generate_function(function)?);
            output.push('\n');
        }
        
        Ok(output)
    }
    
    fn generate_cross_language_functions(&self, block: &LanguageBlock) -> Result<String> {
        let mut output = String::new();
        output.push_str(&format!("// Cross-language block: {}\n", block.language));
        
        for function in &block.functions {
            output.push_str(&format!("fun {}(vararg args: Any): Any {{\n", function.name));
            output.push_str(&format!(
                "    throw NotImplementedError(\"Cross-language call to {}::{} not implemented\")\n",
                block.language, function.name
            ));
            output.push_str("}\n\n");
        }
        
        Ok(output)
    }
    
    fn generate_function(&self, function: &Function) -> Result<String> {
        let mut output = String::new();
        
        // Function signature
        output.push_str("fun ");
        output.push_str(&function.name);
        output.push_str("(");
        
        // Parameters
        for (i, param) in function.parameters.iter().enumerate() {
            if i > 0 {
                output.push_str(", ");
            }
            output.push_str(&format!("{}: {}", 
                param.name, self.convert_type(param.param_type.as_ref())));
        }
        
        output.push_str(")");
        
        // Return type
        let return_type = self.convert_return_type(&function.return_type);
        if return_type != "Unit" {
            output.push_str(&format!(": {}", return_type));
        }
        
        output.push_str(" {\n");
        
        // Function body
        for statement in &function.body {
            output.push_str(&format!("    {}\n", self.generate_statement(statement)?));
        }
        
        output.push_str("}\n");
        Ok(output)
    }
    
    fn generate_statement(&self, statement: &Statement) -> Result<String> {
        match statement {
            Statement::VariableDeclaration { name, value, .. } => {
                if let Some(expr) = value {
                    Ok(format!("val {} = {}", name, self.generate_expression(expr)?))
                } else {
                    Ok(format!("var {}: Any? = null", name))
                }
            }
            Statement::Return { value, .. } => {
                if let Some(expr) = value {
                    Ok(format!("return {}", self.generate_expression(expr)?))
                } else {
                    Ok("return".to_string())
                }
            }
            Statement::Expression { expression, .. } => {
                self.generate_expression(expression)
            }
            Statement::If { condition, then_branch, else_branch, .. } => {
                let mut output = format!("if ({}) {{\n", self.generate_expression(condition)?);
                for stmt in then_branch {
                    output.push_str(&format!("        {}\n", self.generate_statement(stmt)?));
                }
                output.push_str("    }");
                if let Some(else_stmts) = else_branch {
                    output.push_str(" else {\n");
                    for stmt in else_stmts {
                        output.push_str(&format!("        {}\n", self.generate_statement(stmt)?));
                    }
                    output.push_str("    }");
                }
                Ok(output)
            }
            _ => Ok("// Unsupported statement".to_string()),
        }
    }
    
    fn generate_expression(&self, expression: &Expression) -> Result<String> {
        match expression {
            Expression::Literal { value, .. } => {
                match value {
                    LiteralValue::Number(n) => Ok(n.to_string()),
                    LiteralValue::String(s) => Ok(format!("\"{}\"", s.replace('"', "\\\""))),
                    LiteralValue::Boolean(b) => Ok(b.to_string()),
                    LiteralValue::Null => Ok("null".to_string()),
                }
            }
            Expression::Identifier { name, .. } => Ok(name.clone()),
            Expression::Binary { left, operator, right, .. } => {
                let left_str = self.generate_expression(left)?;
                let right_str = self.generate_expression(right)?;
                let op_str = match operator {
                    BinaryOperator::Add => "+",
                    BinaryOperator::Subtract => "-",
                    BinaryOperator::Multiply => "*",
                    BinaryOperator::Divide => "/",
                    BinaryOperator::Equal => "==",
                    BinaryOperator::NotEqual => "!=",
                    BinaryOperator::Less => "<",
                    BinaryOperator::Greater => ">",
                    BinaryOperator::LessEqual => "<=",
                    BinaryOperator::GreaterEqual => ">=",
                    BinaryOperator::And => "&&",
                    BinaryOperator::Or => "||",
                    _ => "/* unsupported op */",
                };
                Ok(format!("({} {} {})", left_str, op_str, right_str))
            }
            Expression::Call { callee, arguments, .. } => {
                let callee_str = match callee.as_ref() {
                    Expression::Identifier { name, .. } => name.clone(),
                    _ => self.generate_expression(callee)?,
                };
                let args: Result<Vec<String>> = arguments.iter()
                    .map(|arg| self.generate_expression(arg))
                    .collect();
                let args_str = args?.join(", ");
                Ok(format!("{}({})", callee_str, args_str))
            }
            Expression::CrossCall { language, function, arguments, .. } => {
                let args: Result<Vec<String>> = arguments.iter()
                    .map(|arg| self.generate_expression(arg))
                    .collect();
                let args_str = args?.join(", ");
                Ok(format!("crossCall(\"{}\", \"{}\", listOf({}))", language, function, args_str))
            }
            Expression::Unary { operator, operand, .. } => {
                let operand_str = self.generate_expression(operand)?;
                let op_str = match operator {
                    UnaryOperator::Minus => "-",
                    UnaryOperator::Plus => "+",
                    UnaryOperator::Not => "!",
                };
                Ok(format!("({}{})", op_str, operand_str))
            }
            _ => Ok("/* Unsupported expression */".to_string()),
        }
    }
    
    fn convert_return_type(&self, return_type: &Option<crate::types::Type>) -> String {
        match return_type {
            Some(crate::types::Type::Number) => "Double",
            Some(crate::types::Type::String) => "String",
            Some(crate::types::Type::Boolean) => "Boolean",
            Some(crate::types::Type::Void) => "Unit",
            Some(crate::types::Type::Array(_)) => "List<Any>",
            Some(crate::types::Type::Object(_)) => "Map<String, Any>",
            _ => "Any",
        }.to_string()
    }
    
    fn convert_type(&self, utopia_type: Option<&crate::types::Type>) -> String {
        match utopia_type {
            Some(crate::types::Type::Number) => "Double".to_string(),
            Some(crate::types::Type::String) => "String".to_string(),
            Some(crate::types::Type::Boolean) => "Boolean".to_string(),
            Some(crate::types::Type::Array(_)) => "List<Any>".to_string(),
            Some(crate::types::Type::Object(_)) => "Map<String, Any>".to_string(),
            _ => "Any".to_string(),
        }
    }
}

/// Swift code generator
pub struct SwiftTransformer;

impl Transformer for SwiftTransformer {
    fn transform(&self, program: &Program) -> Result<String> {
        let mut output = String::new();
        output.push_str("// Generated by Utopia Compiler - Swift Backend\n");
        output.push_str("// Multi-language support with runtime integration\n\n");
        
        // Imports
        output.push_str("import Foundation\n");
        output.push_str("import UIKit // iOS/macOS development\n");
        output.push_str("import SwiftUI // Modern UI framework\n\n");
        
        // Process language blocks
        for block in &program.language_blocks {
            if block.language == "swift" || block.language == "main" {
                output.push_str(&self.generate_swift_functions(block)?);
            } else {
                output.push_str(&self.generate_cross_language_functions(block)?);
            }
        }
        
        // Main execution if needed
        if !program.global_statements.is_empty() {
            output.push_str("// Main execution\n");
            output.push_str("func main() {\n");
            for statement in &program.global_statements {
                output.push_str(&format!("    {}\n", self.generate_statement(statement)?));
            }
            output.push_str("}\n\n");
            output.push_str("main()\n");
        }
        
        Ok(output)
    }
    
    fn target_name(&self) -> &str {
        "swift"
    }
    
    fn file_extension(&self) -> &str {
        ".swift"
    }
    
    fn supports_language(&self, language: &str) -> bool {
        language == "swift"
    }
}

impl SwiftTransformer {
    fn generate_swift_functions(&self, block: &LanguageBlock) -> Result<String> {
        let mut output = String::new();
        
        for function in &block.functions {
            output.push_str(&self.generate_function(function)?);
            output.push('\n');
        }
        
        Ok(output)
    }
    
    fn generate_cross_language_functions(&self, block: &LanguageBlock) -> Result<String> {
        let mut output = String::new();
        output.push_str(&format!("// Cross-language block: {}\n", block.language));
        
        for function in &block.functions {
            output.push_str(&format!("func {}(_ args: Any...) -> Any {{\n", function.name));
            output.push_str(&format!(
                "    fatalError(\"Cross-language call to {}::{} not implemented\")\n",
                block.language, function.name
            ));
            output.push_str("}\n\n");
        }
        
        Ok(output)
    }
    
    fn generate_function(&self, function: &Function) -> Result<String> {
        let mut output = String::new();
        
        // Function signature
        output.push_str("func ");
        output.push_str(&function.name);
        output.push_str("(");
        
        // Parameters
        for (i, param) in function.parameters.iter().enumerate() {
            if i > 0 {
                output.push_str(", ");
            }
            output.push_str(&format!("_ {}: {}", 
                param.name, self.convert_type(param.param_type.as_ref())));
        }
        
        output.push_str(")");
        
        // Return type
        let return_type = self.convert_return_type(&function.return_type);
        if return_type != "Void" {
            output.push_str(&format!(" -> {}", return_type));
        }
        
        output.push_str(" {\n");
        
        // Function body
        for statement in &function.body {
            output.push_str(&format!("    {}\n", self.generate_statement(statement)?));
        }
        
        output.push_str("}\n");
        Ok(output)
    }
    
    fn generate_statement(&self, statement: &Statement) -> Result<String> {
        match statement {
            Statement::VariableDeclaration { name, value, .. } => {
                if let Some(expr) = value {
                    Ok(format!("let {} = {}", name, self.generate_expression(expr)?))
                } else {
                    Ok(format!("var {}: Any? = nil", name))
                }
            }
            Statement::Return { value, .. } => {
                if let Some(expr) = value {
                    Ok(format!("return {}", self.generate_expression(expr)?))
                } else {
                    Ok("return".to_string())
                }
            }
            Statement::Expression { expression, .. } => {
                self.generate_expression(expression)
            }
            Statement::If { condition, then_branch, else_branch, .. } => {
                let mut output = format!("if {} {{\n", self.generate_expression(condition)?);
                for stmt in then_branch {
                    output.push_str(&format!("        {}\n", self.generate_statement(stmt)?));
                }
                output.push_str("    }");
                if let Some(else_stmts) = else_branch {
                    output.push_str(" else {\n");
                    for stmt in else_stmts {
                        output.push_str(&format!("        {}\n", self.generate_statement(stmt)?));
                    }
                    output.push_str("    }");
                }
                Ok(output)
            }
            _ => Ok("// Unsupported statement".to_string()),
        }
    }
    
    fn generate_expression(&self, expression: &Expression) -> Result<String> {
        match expression {
            Expression::Literal { value, .. } => {
                match value {
                    LiteralValue::Number(n) => Ok(n.to_string()),
                    LiteralValue::String(s) => Ok(format!("\"{}\"", s.replace('"', "\\\""))),
                    LiteralValue::Boolean(b) => Ok(b.to_string()),
                    LiteralValue::Null => Ok("nil".to_string()),
                }
            }
            Expression::Identifier { name, .. } => Ok(name.clone()),
            Expression::Binary { left, operator, right, .. } => {
                let left_str = self.generate_expression(left)?;
                let right_str = self.generate_expression(right)?;
                let op_str = match operator {
                    BinaryOperator::Add => "+",
                    BinaryOperator::Subtract => "-",
                    BinaryOperator::Multiply => "*",
                    BinaryOperator::Divide => "/",
                    BinaryOperator::Equal => "==",
                    BinaryOperator::NotEqual => "!=",
                    BinaryOperator::Less => "<",
                    BinaryOperator::Greater => ">",
                    BinaryOperator::LessEqual => "<=",
                    BinaryOperator::GreaterEqual => ">=",
                    BinaryOperator::And => "&&",
                    BinaryOperator::Or => "||",
                    _ => "/* unsupported op */",
                };
                Ok(format!("({} {} {})", left_str, op_str, right_str))
            }
            Expression::Call { callee, arguments, .. } => {
                let callee_str = match callee.as_ref() {
                    Expression::Identifier { name, .. } => name.clone(),
                    _ => self.generate_expression(callee)?,
                };
                let args: Result<Vec<String>> = arguments.iter()
                    .map(|arg| self.generate_expression(arg))
                    .collect();
                let args_str = args?.join(", ");
                Ok(format!("{}({})", callee_str, args_str))
            }
            Expression::CrossCall { language, function, arguments, .. } => {
                let args: Result<Vec<String>> = arguments.iter()
                    .map(|arg| self.generate_expression(arg))
                    .collect();
                let args_str = args?.join(", ");
                Ok(format!("crossCall(\"{}\", \"{}\", [{}])", language, function, args_str))
            }
            Expression::Unary { operator, operand, .. } => {
                let operand_str = self.generate_expression(operand)?;
                let op_str = match operator {
                    UnaryOperator::Minus => "-",
                    UnaryOperator::Plus => "+",
                    UnaryOperator::Not => "!",
                };
                Ok(format!("({}{})", op_str, operand_str))
            }
            _ => Ok("/* Unsupported expression */".to_string()),
        }
    }
    
    fn convert_return_type(&self, return_type: &Option<crate::types::Type>) -> String {
        match return_type {
            Some(crate::types::Type::Number) => "Double",
            Some(crate::types::Type::String) => "String",
            Some(crate::types::Type::Boolean) => "Bool",
            Some(crate::types::Type::Void) => "Void",
            Some(crate::types::Type::Array(_)) => "[Any]",
            Some(crate::types::Type::Object(_)) => "[String: Any]",
            _ => "Any",
        }.to_string()
    }
    
    fn convert_type(&self, utopia_type: Option<&crate::types::Type>) -> String {
        match utopia_type {
            Some(crate::types::Type::Number) => "Double".to_string(),
            Some(crate::types::Type::String) => "String".to_string(),
            Some(crate::types::Type::Boolean) => "Bool".to_string(),
            Some(crate::types::Type::Array(_)) => "[Any]".to_string(),
            Some(crate::types::Type::Object(_)) => "[String: Any]".to_string(),
            _ => "Any".to_string(),
        }
    }
}

/// COBOL code generator
pub struct CobolTransformer;

impl Transformer for CobolTransformer {
    fn transform(&self, program: &Program) -> Result<String> {
        let mut output = String::new();
        output.push_str("      * Generated by Utopia Compiler - COBOL Backend\n");
        output.push_str("      * Multi-language support with runtime integration\n");
        output.push_str("       IDENTIFICATION DIVISION.\n");
        output.push_str("       PROGRAM-ID. UTOPIA-GENERATED.\n");
        output.push_str("       ENVIRONMENT DIVISION.\n");
        output.push_str("       DATA DIVISION.\n");
        output.push_str("       WORKING-STORAGE SECTION.\n");
        output.push_str("       01  WS-RESULT         PIC X(100).\n");
        output.push_str("       01  WS-TEMP-NUM       PIC 9(10)V99.\n");
        output.push_str("       01  WS-TEMP-STR       PIC X(100).\n");
        output.push_str("       PROCEDURE DIVISION.\n");
        output.push_str("       MAIN-LOGIC.\n");
        
        // Process language blocks
        for block in &program.language_blocks {
            if block.language == "cobol" || block.language == "cob" || block.language == "main" {
                output.push_str(&self.generate_cobol_procedures(block)?);
            } else {
                output.push_str(&self.generate_cross_language_procedures(block)?);
            }
        }
        
        // Global statements in main execution
        if !program.global_statements.is_empty() {
            output.push_str("       PERFORM MAIN-PROCESSING.\n");
            output.push_str("       \n");
            output.push_str("       MAIN-PROCESSING.\n");
            for statement in &program.global_statements {
                output.push_str(&format!("       {}.\n", self.generate_statement(statement)?));
            }
        }
        
        output.push_str("       STOP RUN.\n");
        Ok(output)
    }
    
    fn target_name(&self) -> &str {
        "cobol"
    }
    
    fn file_extension(&self) -> &str {
        ".cob"
    }
    
    fn supports_language(&self, language: &str) -> bool {
        matches!(language, "cobol" | "cob")
    }
}

impl CobolTransformer {
    fn generate_cobol_procedures(&self, block: &LanguageBlock) -> Result<String> {
        let mut output = String::new();
        
        for function in &block.functions {
            output.push_str(&self.generate_function(function)?);
            output.push('\n');
        }
        
        Ok(output)
    }
    
    fn generate_cross_language_procedures(&self, block: &LanguageBlock) -> Result<String> {
        let mut output = String::new();
        output.push_str(&format!("      * Cross-language block: {}\n", block.language));
        
        for function in &block.functions {
            let func_name = function.name.to_uppercase().replace('_', "-");
            output.push_str(&format!("       {}.\n", func_name));
            output.push_str(&format!(
                "           DISPLAY 'Cross-language call to {}::{} not implemented'\n",
                block.language, function.name
            ));
            output.push_str("           EXIT.\n\n");
        }
        
        Ok(output)
    }
    
    fn generate_function(&self, function: &Function) -> Result<String> {
        let mut output = String::new();
        let func_name = function.name.to_uppercase().replace('_', "-");
        
        // Function paragraph
        output.push_str(&format!("       {}.\n", func_name));
        
        // Function body
        for statement in &function.body {
            output.push_str(&format!("           {}\n", self.generate_statement(statement)?));
        }
        
        output.push_str("           EXIT.\n");
        Ok(output)
    }
    
    fn generate_statement(&self, statement: &Statement) -> Result<String> {
        match statement {
            Statement::VariableDeclaration { name, value, .. } => {
                let var_name = name.to_uppercase().replace('_', "-");
                if let Some(expr) = value {
                    Ok(format!("MOVE {} TO WS-{}", self.generate_expression(expr)?, var_name))
                } else {
                    Ok(format!("MOVE SPACES TO WS-{}", var_name))
                }
            }
            Statement::Return { value, .. } => {
                if let Some(expr) = value {
                    Ok(format!("MOVE {} TO WS-RESULT", self.generate_expression(expr)?))
                } else {
                    Ok("MOVE SPACES TO WS-RESULT".to_string())
                }
            }
            Statement::Expression { expression, .. } => {
                match expression {
                    Expression::Call { .. } => {
                        Ok(format!("PERFORM {}", self.generate_expression(expression)?))
                    }
                    _ => self.generate_expression(expression)
                }
            }
            Statement::If { condition, then_branch, else_branch, .. } => {
                let mut output = format!("IF {} THEN\n", self.generate_expression(condition)?);
                for stmt in then_branch {
                    output.push_str(&format!("               {}\n", self.generate_statement(stmt)?));
                }
                if let Some(else_stmts) = else_branch {
                    output.push_str("           ELSE\n");
                    for stmt in else_stmts {
                        output.push_str(&format!("               {}\n", self.generate_statement(stmt)?));
                    }
                }
                output.push_str("           END-IF");
                Ok(output)
            }
            _ => Ok("* Unsupported statement".to_string()),
        }
    }
    
    fn generate_expression(&self, expression: &Expression) -> Result<String> {
        match expression {
            Expression::Literal { value, .. } => {
                match value {
                    LiteralValue::Number(n) => Ok(n.to_string()),
                    LiteralValue::String(s) => Ok(format!("'{}'", s)),
                    LiteralValue::Boolean(b) => Ok(if *b { "'TRUE'" } else { "'FALSE'" }.to_string()),
                    LiteralValue::Null => Ok("SPACES".to_string()),
                }
            }
            Expression::Identifier { name, .. } => {
                let var_name = name.to_uppercase().replace('_', "-");
                Ok(format!("WS-{}", var_name))
            }
            Expression::Binary { left, operator, right, .. } => {
                let left_str = self.generate_expression(left)?;
                let right_str = self.generate_expression(right)?;
                match operator {
                    BinaryOperator::Add => Ok(format!("({} + {})", left_str, right_str)),
                    BinaryOperator::Subtract => Ok(format!("({} - {})", left_str, right_str)),
                    BinaryOperator::Multiply => Ok(format!("({} * {})", left_str, right_str)),
                    BinaryOperator::Divide => Ok(format!("({} / {})", left_str, right_str)),
                    BinaryOperator::Equal => Ok(format!("{} = {}", left_str, right_str)),
                    BinaryOperator::NotEqual => Ok(format!("{} NOT = {}", left_str, right_str)),
                    BinaryOperator::Less => Ok(format!("{} < {}", left_str, right_str)),
                    BinaryOperator::Greater => Ok(format!("{} > {}", left_str, right_str)),
                    BinaryOperator::LessEqual => Ok(format!("{} <= {}", left_str, right_str)),
                    BinaryOperator::GreaterEqual => Ok(format!("{} >= {}", left_str, right_str)),
                    BinaryOperator::And => Ok(format!("{} AND {}", left_str, right_str)),
                    BinaryOperator::Or => Ok(format!("{} OR {}", left_str, right_str)),
                    _ => Ok("* unsupported operation *".to_string()),
                }
            }
            Expression::Call { callee, arguments: _, .. } => {
                let callee_str = match callee.as_ref() {
                    Expression::Identifier { name, .. } => {
                        name.to_uppercase().replace('_', "-")
                    }
                    _ => self.generate_expression(callee)?,
                };
                Ok(callee_str)
            }
            Expression::CrossCall { language, function, arguments: _, .. } => {
                let func_name = function.to_uppercase().replace('_', "-");
                Ok(format!("* Cross-call to {}::{} *", language, func_name))
            }
            Expression::Unary { operator, operand, .. } => {
                let operand_str = self.generate_expression(operand)?;
                let op_str = match operator {
                    UnaryOperator::Minus => "-",
                    UnaryOperator::Plus => "+",
                    UnaryOperator::Not => "NOT",
                };
                Ok(format!("({} {})", op_str, operand_str))
            }
            _ => Ok("* Unsupported expression *".to_string()),
        }
    }
}

/// Ruby code generator
pub struct RubyTransformer;

impl Transformer for RubyTransformer {
    fn transform(&self, program: &Program) -> Result<String> {
        let mut output = String::new();
        output.push_str("# Generated by Utopia Compiler - Ruby Backend\n");
        output.push_str("# Multi-language support with runtime integration\n");
        output.push_str("# Ruby on Rails and web development\n\n");
        
        // Require statements
        output.push_str("require 'json'\n");
        output.push_str("require 'net/http'\n");
        output.push_str("require 'uri'\n\n");
        
        // Process language blocks
        for block in &program.language_blocks {
            if block.language == "ruby" || block.language == "rb" || block.language == "main" {
                output.push_str(&self.generate_ruby_methods(block)?);
            } else {
                output.push_str(&self.generate_cross_language_methods(block)?);
            }
        }
        
        // Global statements in main execution
        if !program.global_statements.is_empty() {
            output.push_str("# Main execution\n");
            for statement in &program.global_statements {
                output.push_str(&format!("{}\n", self.generate_statement(statement)?));
            }
        }
        
        Ok(output)
    }
    
    fn target_name(&self) -> &str {
        "ruby"
    }
    
    fn file_extension(&self) -> &str {
        ".rb"
    }
    
    fn supports_language(&self, language: &str) -> bool {
        matches!(language, "ruby" | "rb")
    }
}

impl RubyTransformer {
    fn generate_ruby_methods(&self, block: &LanguageBlock) -> Result<String> {
        let mut output = String::new();
        
        for function in &block.functions {
            output.push_str(&self.generate_function(function)?);
            output.push('\n');
        }
        
        Ok(output)
    }
    
    fn generate_cross_language_methods(&self, block: &LanguageBlock) -> Result<String> {
        let mut output = String::new();
        output.push_str(&format!("# Cross-language block: {}\n", block.language));
        
        for function in &block.functions {
            output.push_str(&format!("def {}(*args)\n", function.name));
            output.push_str(&format!(
                "  raise NotImplementedError, 'Cross-language call to {}::{} not implemented'\n",
                block.language, function.name
            ));
            output.push_str("end\n\n");
        }
        
        Ok(output)
    }
    
    fn generate_function(&self, function: &Function) -> Result<String> {
        let mut output = String::new();
        
        // Method definition
        output.push_str("def ");
        output.push_str(&function.name);
        
        if !function.parameters.is_empty() {
            output.push_str("(");
            for (i, param) in function.parameters.iter().enumerate() {
                if i > 0 {
                    output.push_str(", ");
                }
                output.push_str(&param.name);
            }
            output.push_str(")");
        }
        
        output.push_str("\n");
        
        // Method body
        for statement in &function.body {
            output.push_str(&format!("  {}\n", self.generate_statement(statement)?));
        }
        
        output.push_str("end\n");
        Ok(output)
    }
    
    fn generate_statement(&self, statement: &Statement) -> Result<String> {
        match statement {
            Statement::VariableDeclaration { name, value, .. } => {
                if let Some(expr) = value {
                    Ok(format!("{} = {}", name, self.generate_expression(expr)?))
                } else {
                    Ok(format!("{} = nil", name))
                }
            }
            Statement::Return { value, .. } => {
                if let Some(expr) = value {
                    Ok(format!("return {}", self.generate_expression(expr)?))
                } else {
                    Ok("return".to_string())
                }
            }
            Statement::Expression { expression, .. } => {
                self.generate_expression(expression)
            }
            Statement::If { condition, then_branch, else_branch, .. } => {
                let mut output = format!("if {}\n", self.generate_expression(condition)?);
                for stmt in then_branch {
                    output.push_str(&format!("    {}\n", self.generate_statement(stmt)?));
                }
                if let Some(else_stmts) = else_branch {
                    output.push_str("  else\n");
                    for stmt in else_stmts {
                        output.push_str(&format!("    {}\n", self.generate_statement(stmt)?));
                    }
                }
                output.push_str("  end");
                Ok(output)
            }
            _ => Ok("# Unsupported statement".to_string()),
        }
    }
    
    fn generate_expression(&self, expression: &Expression) -> Result<String> {
        match expression {
            Expression::Literal { value, .. } => {
                match value {
                    LiteralValue::Number(n) => Ok(n.to_string()),
                    LiteralValue::String(s) => Ok(format!("\"{}\"", s.replace('"', "\\\""))),
                    LiteralValue::Boolean(b) => Ok(b.to_string()),
                    LiteralValue::Null => Ok("nil".to_string()),
                }
            }
            Expression::Identifier { name, .. } => Ok(name.clone()),
            Expression::Binary { left, operator, right, .. } => {
                let left_str = self.generate_expression(left)?;
                let right_str = self.generate_expression(right)?;
                let op_str = match operator {
                    BinaryOperator::Add => "+",
                    BinaryOperator::Subtract => "-",
                    BinaryOperator::Multiply => "*",
                    BinaryOperator::Divide => "/",
                    BinaryOperator::Equal => "==",
                    BinaryOperator::NotEqual => "!=",
                    BinaryOperator::Less => "<",
                    BinaryOperator::Greater => ">",
                    BinaryOperator::LessEqual => "<=",
                    BinaryOperator::GreaterEqual => ">=",
                    BinaryOperator::And => "&&",
                    BinaryOperator::Or => "||",
                    _ => "# unsupported op #",
                };
                Ok(format!("({} {} {})", left_str, op_str, right_str))
            }
            Expression::Call { callee, arguments, .. } => {
                let callee_str = match callee.as_ref() {
                    Expression::Identifier { name, .. } => name.clone(),
                    _ => self.generate_expression(callee)?,
                };
                let args: Result<Vec<String>> = arguments.iter()
                    .map(|arg| self.generate_expression(arg))
                    .collect();
                let args_str = args?.join(", ");
                Ok(format!("{}({})", callee_str, args_str))
            }
            Expression::CrossCall { language, function, arguments, .. } => {
                let args: Result<Vec<String>> = arguments.iter()
                    .map(|arg| self.generate_expression(arg))
                    .collect();
                let args_str = args?.join(", ");
                Ok(format!("cross_call('{}', '{}', [{}])", language, function, args_str))
            }
            Expression::Unary { operator, operand, .. } => {
                let operand_str = self.generate_expression(operand)?;
                let op_str = match operator {
                    UnaryOperator::Minus => "-",
                    UnaryOperator::Plus => "+",
                    UnaryOperator::Not => "!",
                };
                Ok(format!("({}{})", op_str, operand_str))
            }
            _ => Ok("# Unsupported expression #".to_string()),
        }
    }
}

/// Lisp code generator
pub struct LispTransformer;

impl Transformer for LispTransformer {
    fn transform(&self, program: &Program) -> Result<String> {
        let mut output = String::new();
        output.push_str(";; Generated by Utopia Compiler - Lisp Backend\n");
        output.push_str(";; Multi-language support with runtime integration\n");
        output.push_str(";; AI research and academic programming\n\n");
        
        // Common Lisp setup
        output.push_str("(require 'cl-lib)\n");
        output.push_str("(require 'json)\n\n");
        
        // Process language blocks
        for block in &program.language_blocks {
            if block.language == "lisp" || block.language == "cl" || block.language == "main" {
                output.push_str(&self.generate_lisp_functions(block)?);
            } else {
                output.push_str(&self.generate_cross_language_functions(block)?);
            }
        }
        
        // Global statements in main execution
        if !program.global_statements.is_empty() {
            output.push_str(";; Main execution\n");
            output.push_str("(progn\n");
            for statement in &program.global_statements {
                output.push_str(&format!("  {}\n", self.generate_statement(statement)?));
            }
            output.push_str(")\n");
        }
        
        Ok(output)
    }
    
    fn target_name(&self) -> &str {
        "lisp"
    }
    
    fn file_extension(&self) -> &str {
        ".lisp"
    }
    
    fn supports_language(&self, language: &str) -> bool {
        matches!(language, "lisp" | "cl")
    }
}

impl LispTransformer {
    fn generate_lisp_functions(&self, block: &LanguageBlock) -> Result<String> {
        let mut output = String::new();
        
        for function in &block.functions {
            output.push_str(&self.generate_function(function)?);
            output.push('\n');
        }
        
        Ok(output)
    }
    
    fn generate_cross_language_functions(&self, block: &LanguageBlock) -> Result<String> {
        let mut output = String::new();
        output.push_str(&format!(";; Cross-language block: {}\n", block.language));
        
        for function in &block.functions {
            output.push_str(&format!("(defun {} (&rest args)\n", function.name));
            output.push_str(&format!(
                "  (error \"Cross-language call to {}::{} not implemented\"))\n\n",
                block.language, function.name
            ));
        }
        
        Ok(output)
    }
    
    fn generate_function(&self, function: &Function) -> Result<String> {
        let mut output = String::new();
        
        // Function definition
        output.push_str(&format!("(defun {} (", function.name));
        
        // Parameters
        for (i, param) in function.parameters.iter().enumerate() {
            if i > 0 {
                output.push_str(" ");
            }
            output.push_str(&param.name);
        }
        
        output.push_str(")\n");
        
        // Function body
        if function.body.len() == 1 {
            // Single expression
            output.push_str(&format!("  {})", self.generate_statement(&function.body[0])?));
        } else {
            // Multiple statements - use progn
            output.push_str("  (progn\n");
            for statement in &function.body {
                output.push_str(&format!("    {}\n", self.generate_statement(statement)?));
            }
            output.push_str("  ))");
        }
        
        output.push('\n');
        Ok(output)
    }
    
    fn generate_statement(&self, statement: &Statement) -> Result<String> {
        match statement {
            Statement::VariableDeclaration { name, value, .. } => {
                if let Some(expr) = value {
                    Ok(format!("(setq {} {})", name, self.generate_expression(expr)?))
                } else {
                    Ok(format!("(setq {} nil)", name))
                }
            }
            Statement::Return { value, .. } => {
                if let Some(expr) = value {
                    self.generate_expression(expr)
                } else {
                    Ok("nil".to_string())
                }
            }
            Statement::Expression { expression, .. } => {
                self.generate_expression(expression)
            }
            Statement::If { condition, then_branch, else_branch, .. } => {
                let mut output = format!("(if {}\n", self.generate_expression(condition)?);
                
                if then_branch.len() == 1 {
                    output.push_str(&format!("    {}", self.generate_statement(&then_branch[0])?));
                } else {
                    output.push_str("    (progn\n");
                    for stmt in then_branch {
                        output.push_str(&format!("      {}\n", self.generate_statement(stmt)?));
                    }
                    output.push_str("    )");
                }
                
                if let Some(else_stmts) = else_branch {
                    output.push_str("\n");
                    if else_stmts.len() == 1 {
                        output.push_str(&format!("    {}", self.generate_statement(&else_stmts[0])?));
                    } else {
                        output.push_str("    (progn\n");
                        for stmt in else_stmts {
                            output.push_str(&format!("      {}\n", self.generate_statement(stmt)?));
                        }
                        output.push_str("    )");
                    }
                }
                
                output.push_str(")");
                Ok(output)
            }
            _ => Ok(";; Unsupported statement".to_string()),
        }
    }
    
    fn generate_expression(&self, expression: &Expression) -> Result<String> {
        match expression {
            Expression::Literal { value, .. } => {
                match value {
                    LiteralValue::Number(n) => Ok(n.to_string()),
                    LiteralValue::String(s) => Ok(format!("\"{}\"", s.replace('"', "\\\""))),
                    LiteralValue::Boolean(b) => Ok(if *b { "t" } else { "nil" }.to_string()),
                    LiteralValue::Null => Ok("nil".to_string()),
                }
            }
            Expression::Identifier { name, .. } => Ok(name.clone()),
            Expression::Binary { left, operator, right, .. } => {
                let left_str = self.generate_expression(left)?;
                let right_str = self.generate_expression(right)?;
                let op_str = match operator {
                    BinaryOperator::Add => "+",
                    BinaryOperator::Subtract => "-",
                    BinaryOperator::Multiply => "*",
                    BinaryOperator::Divide => "/",
                    BinaryOperator::Equal => "=",
                    BinaryOperator::NotEqual => "/=",
                    BinaryOperator::Less => "<",
                    BinaryOperator::Greater => ">",
                    BinaryOperator::LessEqual => "<=",
                    BinaryOperator::GreaterEqual => ">=",
                    BinaryOperator::And => "and",
                    BinaryOperator::Or => "or",
                    _ => ";; unsupported op ;;",
                };
                Ok(format!("({} {} {})", op_str, left_str, right_str))
            }
            Expression::Call { callee, arguments, .. } => {
                let callee_str = match callee.as_ref() {
                    Expression::Identifier { name, .. } => name.clone(),
                    _ => self.generate_expression(callee)?,
                };
                let args: Result<Vec<String>> = arguments.iter()
                    .map(|arg| self.generate_expression(arg))
                    .collect();
                let args_str = args?.join(" ");
                Ok(format!("({} {})", callee_str, args_str))
            }
            Expression::CrossCall { language, function, arguments, .. } => {
                let args: Result<Vec<String>> = arguments.iter()
                    .map(|arg| self.generate_expression(arg))
                    .collect();
                let args_str = args?.join(" ");
                Ok(format!("(cross-call \"{}\" \"{}\" (list {}))", language, function, args_str))
            }
            Expression::Unary { operator, operand, .. } => {
                let operand_str = self.generate_expression(operand)?;
                let op_str = match operator {
                    UnaryOperator::Minus => "-",
                    UnaryOperator::Plus => "+",
                    UnaryOperator::Not => "not",
                };
                Ok(format!("({} {})", op_str, operand_str))
            }
            _ => Ok(";; Unsupported expression ;;".to_string()),
        }
    }
}

/// Prolog code generator
pub struct PrologTransformer;

impl Transformer for PrologTransformer {
    fn transform(&self, program: &Program) -> Result<String> {
        let mut output = String::new();
        output.push_str("% Generated by Utopia Compiler - Prolog Backend\n");
        output.push_str("% Multi-language support with runtime integration\n");
        output.push_str("% Logic programming and AI applications\n\n");
        
        // Prolog directives
        output.push_str(":- use_module(library(lists)).\n");
        output.push_str(":- use_module(library(clpfd)).\n");
        output.push_str(":- use_module(library(dcg/basics)).\n\n");
        
        // Process language blocks
        for block in &program.language_blocks {
            if block.language == "prolog" || block.language == "pl" || block.language == "main" {
                output.push_str(&self.generate_prolog_predicates(block)?);
            } else {
                output.push_str(&self.generate_cross_language_predicates(block)?);
            }
        }
        
        // Global statements as facts/rules
        if !program.global_statements.is_empty() {
            output.push_str("% Main execution facts\n");
            for statement in &program.global_statements {
                output.push_str(&format!("{}.\n", self.generate_statement(statement)?));
            }
        }
        
        Ok(output)
    }
    
    fn target_name(&self) -> &str {
        "prolog"
    }
    
    fn file_extension(&self) -> &str {
        ".pl"
    }
    
    fn supports_language(&self, language: &str) -> bool {
        matches!(language, "prolog" | "pl")
    }
}

impl PrologTransformer {
    fn generate_prolog_predicates(&self, block: &LanguageBlock) -> Result<String> {
        let mut output = String::new();
        
        for function in &block.functions {
            output.push_str(&self.generate_function(function)?);
            output.push('\n');
        }
        
        Ok(output)
    }
    
    fn generate_cross_language_predicates(&self, block: &LanguageBlock) -> Result<String> {
        let mut output = String::new();
        output.push_str(&format!("% Cross-language block: {}\n", block.language));
        
        for function in &block.functions {
            output.push_str(&format!("{}(_) :-\n", function.name));
            output.push_str(&format!(
                "    format('Cross-language call to {}::{} not implemented~n', []).\n\n",
                block.language, function.name
            ));
        }
        
        Ok(output)
    }
    
    fn generate_function(&self, function: &Function) -> Result<String> {
        let mut output = String::new();
        
        // Predicate definition - Prolog style
        output.push_str(&format!("{}(", function.name));
        
        // Parameters
        for (i, param) in function.parameters.iter().enumerate() {
            if i > 0 {
                output.push_str(", ");
            }
            // Capitalize first letter for Prolog variables
            let param_name = format!("{}{}", 
                param.name.chars().next().unwrap().to_uppercase(),
                param.name.chars().skip(1).collect::<String>()
            );
            output.push_str(&param_name);
        }
        
        // Add result parameter if function has return type
        let has_return = function.body.iter().any(|stmt| matches!(stmt, Statement::Return { .. }));
        if has_return {
            if !function.parameters.is_empty() {
                output.push_str(", ");
            }
            output.push_str("Result");
        }
        
        output.push_str(") :-\n");
        
        // Function body as Prolog clauses
        for statement in &function.body {
            output.push_str(&format!("    {},\n", self.generate_statement(statement)?));
        }
        
        // Remove last comma and newline, add period
        if output.ends_with(",\n") {
            output.pop();
            output.pop();
            output.push_str(".\n");
        } else {
            output.push_str("    true.\n");
        }
        
        Ok(output)
    }
    
    fn generate_statement(&self, statement: &Statement) -> Result<String> {
        match statement {
            Statement::VariableDeclaration { name, value, .. } => {
                let var_name = format!("{}{}", 
                    name.chars().next().unwrap().to_uppercase(),
                    name.chars().skip(1).collect::<String>()
                );
                if let Some(expr) = value {
                    Ok(format!("{} = {}", var_name, self.generate_expression(expr)?))
                } else {
                    Ok(format!("var({})", var_name))
                }
            }
            Statement::Return { value, .. } => {
                if let Some(expr) = value {
                    Ok(format!("Result = {}", self.generate_expression(expr)?))
                } else {
                    Ok("Result = true".to_string())
                }
            }
            Statement::Expression { expression, .. } => {
                self.generate_expression(expression)
            }
            Statement::If { condition, then_branch, else_branch, .. } => {
                let mut output = format!("({} ->", self.generate_expression(condition)?);
                
                if then_branch.len() == 1 {
                    output.push_str(&format!(" {} ", self.generate_statement(&then_branch[0])?));
                } else {
                    output.push_str(" (");
                    for (i, stmt) in then_branch.iter().enumerate() {
                        if i > 0 {
                            output.push_str(", ");
                        }
                        output.push_str(&self.generate_statement(stmt)?);
                    }
                    output.push_str(") ");
                }
                
                if let Some(else_stmts) = else_branch {
                    output.push_str("; ");
                    if else_stmts.len() == 1 {
                        output.push_str(&self.generate_statement(&else_stmts[0])?);
                    } else {
                        output.push_str("(");
                        for (i, stmt) in else_stmts.iter().enumerate() {
                            if i > 0 {
                                output.push_str(", ");
                            }
                            output.push_str(&self.generate_statement(stmt)?);
                        }
                        output.push_str(")");
                    }
                } else {
                    output.push_str("; true");
                }
                
                output.push_str(")");
                Ok(output)
            }
            _ => Ok("% Unsupported statement".to_string()),
        }
    }
    
    fn generate_expression(&self, expression: &Expression) -> Result<String> {
        match expression {
            Expression::Literal { value, .. } => {
                match value {
                    LiteralValue::Number(n) => Ok(n.to_string()),
                    LiteralValue::String(s) => Ok(format!("'{}'", s.replace('\'', "''"))),
                    LiteralValue::Boolean(b) => Ok(if *b { "true" } else { "false" }.to_string()),
                    LiteralValue::Null => Ok("null".to_string()),
                }
            }
            Expression::Identifier { name, .. } => {
                // Capitalize first letter for Prolog variables
                let var_name = format!("{}{}", 
                    name.chars().next().unwrap().to_uppercase(),
                    name.chars().skip(1).collect::<String>()
                );
                Ok(var_name)
            }
            Expression::Binary { left, operator, right, .. } => {
                let left_str = self.generate_expression(left)?;
                let right_str = self.generate_expression(right)?;
                match operator {
                    BinaryOperator::Add => Ok(format!("{} + {}", left_str, right_str)),
                    BinaryOperator::Subtract => Ok(format!("{} - {}", left_str, right_str)),
                    BinaryOperator::Multiply => Ok(format!("{} * {}", left_str, right_str)),
                    BinaryOperator::Divide => Ok(format!("{} / {}", left_str, right_str)),
                    BinaryOperator::Equal => Ok(format!("{} = {}", left_str, right_str)),
                    BinaryOperator::NotEqual => Ok(format!("{} \\= {}", left_str, right_str)),
                    BinaryOperator::Less => Ok(format!("{} < {}", left_str, right_str)),
                    BinaryOperator::Greater => Ok(format!("{} > {}", left_str, right_str)),
                    BinaryOperator::LessEqual => Ok(format!("{} =< {}", left_str, right_str)),
                    BinaryOperator::GreaterEqual => Ok(format!("{} >= {}", left_str, right_str)),
                    BinaryOperator::And => Ok(format!("({}, {})", left_str, right_str)),
                    BinaryOperator::Or => Ok(format!("({}; {})", left_str, right_str)),
                    _ => Ok("% unsupported operation %".to_string()),
                }
            }
            Expression::Call { callee, arguments, .. } => {
                let callee_str = match callee.as_ref() {
                    Expression::Identifier { name, .. } => name.clone(),
                    _ => self.generate_expression(callee)?,
                };
                let args: Result<Vec<String>> = arguments.iter()
                    .map(|arg| self.generate_expression(arg))
                    .collect();
                let args_str = args?.join(", ");
                Ok(format!("{}({})", callee_str, args_str))
            }
            Expression::CrossCall { language, function, arguments, .. } => {
                let args: Result<Vec<String>> = arguments.iter()
                    .map(|arg| self.generate_expression(arg))
                    .collect();
                let args_str = args?.join(", ");
                Ok(format!("cross_call('{}', '{}', [{}])", language, function, args_str))
            }
            Expression::Unary { operator, operand, .. } => {
                let operand_str = self.generate_expression(operand)?;
                let op_str = match operator {
                    UnaryOperator::Minus => "-",
                    UnaryOperator::Plus => "+",
                    UnaryOperator::Not => "\\+",
                };
                Ok(format!("{} {}", op_str, operand_str))
            }
            _ => Ok("% Unsupported expression %".to_string()),
        }
    }
}

/// Dart code generator
pub struct DartTransformer;

impl Transformer for DartTransformer {
    fn transform(&self, program: &Program) -> Result<String> {
        let mut output = String::new();
        output.push_str("// Generated by Utopia Compiler - Dart Backend\n");
        output.push_str("// Multi-language support with runtime integration\n");
        output.push_str("// Flutter mobile app development\n\n");
        
        // Imports
        output.push_str("import 'dart:convert';\n");
        output.push_str("import 'dart:async';\n");
        output.push_str("import 'package:flutter/material.dart';\n\n");
        
        // Process language blocks
        for block in &program.language_blocks {
            if block.language == "dart" || block.language == "main" {
                output.push_str(&self.generate_dart_functions(block)?);
            } else {
                output.push_str(&self.generate_cross_language_functions(block)?);
            }
        }
        
        // Global statements in main execution
        if !program.global_statements.is_empty() {
            output.push_str("void main() {\n");
            for statement in &program.global_statements {
                output.push_str(&format!("  {};\n", self.generate_statement(statement)?));
            }
            output.push_str("}\n");
        }
        
        Ok(output)
    }
    
    fn target_name(&self) -> &str {
        "dart"
    }
    
    fn file_extension(&self) -> &str {
        ".dart"
    }
    
    fn supports_language(&self, language: &str) -> bool {
        language == "dart"
    }
}

impl DartTransformer {
    fn generate_dart_functions(&self, block: &LanguageBlock) -> Result<String> {
        let mut output = String::new();
        
        for function in &block.functions {
            output.push_str(&self.generate_function(function)?);
            output.push('\n');
        }
        
        Ok(output)
    }
    
    fn generate_cross_language_functions(&self, block: &LanguageBlock) -> Result<String> {
        let mut output = String::new();
        output.push_str(&format!("// Cross-language block: {}\n", block.language));
        
        for function in &block.functions {
            output.push_str(&format!("dynamic {}(List<dynamic> args) {{\n", function.name));
            output.push_str(&format!(
                "  throw UnimplementedError('Cross-language call to {}::{} not implemented');\n",
                block.language, function.name
            ));
            output.push_str("}\n\n");
        }
        
        Ok(output)
    }
    
    fn generate_function(&self, function: &Function) -> Result<String> {
        let mut output = String::new();
        
        // Function signature
        let return_type = self.convert_return_type(&function.return_type);
        output.push_str(&format!("{} {}(", return_type, function.name));
        
        // Parameters
        for (i, param) in function.parameters.iter().enumerate() {
            if i > 0 {
                output.push_str(", ");
            }
            output.push_str(&format!("{} {}", 
                self.convert_type(param.param_type.as_ref()), param.name));
        }
        
        output.push_str(") {\n");
        
        // Function body
        for statement in &function.body {
            output.push_str(&format!("  {};\n", self.generate_statement(statement)?));
        }
        
        output.push_str("}\n");
        Ok(output)
    }
    
    fn generate_statement(&self, statement: &Statement) -> Result<String> {
        match statement {
            Statement::VariableDeclaration { name, value, .. } => {
                if let Some(expr) = value {
                    Ok(format!("var {} = {}", name, self.generate_expression(expr)?))
                } else {
                    Ok(format!("var {};", name))
                }
            }
            Statement::Return { value, .. } => {
                if let Some(expr) = value {
                    Ok(format!("return {}", self.generate_expression(expr)?))
                } else {
                    Ok("return".to_string())
                }
            }
            Statement::Expression { expression, .. } => {
                self.generate_expression(expression)
            }
            Statement::If { condition, then_branch, else_branch, .. } => {
                let mut output = format!("if ({}) {{\n", self.generate_expression(condition)?);
                for stmt in then_branch {
                    output.push_str(&format!("    {};\n", self.generate_statement(stmt)?));
                }
                output.push_str("  }");
                if let Some(else_stmts) = else_branch {
                    output.push_str(" else {\n");
                    for stmt in else_stmts {
                        output.push_str(&format!("    {};\n", self.generate_statement(stmt)?));
                    }
                    output.push_str("  }");
                }
                Ok(output)
            }
            _ => Ok("// Unsupported statement".to_string()),
        }
    }
    
    fn generate_expression(&self, expression: &Expression) -> Result<String> {
        match expression {
            Expression::Literal { value, .. } => {
                match value {
                    LiteralValue::Number(n) => Ok(n.to_string()),
                    LiteralValue::String(s) => Ok(format!("\"{}\"", s.replace('"', "\\\""))),
                    LiteralValue::Boolean(b) => Ok(b.to_string()),
                    LiteralValue::Null => Ok("null".to_string()),
                }
            }
            Expression::Identifier { name, .. } => Ok(name.clone()),
            Expression::Binary { left, operator, right, .. } => {
                let left_str = self.generate_expression(left)?;
                let right_str = self.generate_expression(right)?;
                let op_str = match operator {
                    BinaryOperator::Add => "+",
                    BinaryOperator::Subtract => "-",
                    BinaryOperator::Multiply => "*",
                    BinaryOperator::Divide => "/",
                    BinaryOperator::Equal => "==",
                    BinaryOperator::NotEqual => "!=",
                    BinaryOperator::Less => "<",
                    BinaryOperator::Greater => ">",
                    BinaryOperator::LessEqual => "<=",
                    BinaryOperator::GreaterEqual => ">=",
                    BinaryOperator::And => "&&",
                    BinaryOperator::Or => "||",
                    _ => "/* unsupported op */",
                };
                Ok(format!("({} {} {})", left_str, op_str, right_str))
            }
            Expression::Call { callee, arguments, .. } => {
                let callee_str = match callee.as_ref() {
                    Expression::Identifier { name, .. } => name.clone(),
                    _ => self.generate_expression(callee)?,
                };
                let args: Result<Vec<String>> = arguments.iter()
                    .map(|arg| self.generate_expression(arg))
                    .collect();
                let args_str = args?.join(", ");
                Ok(format!("{}({})", callee_str, args_str))
            }
            Expression::CrossCall { language, function, arguments, .. } => {
                let args: Result<Vec<String>> = arguments.iter()
                    .map(|arg| self.generate_expression(arg))
                    .collect();
                let args_str = args?.join(", ");
                Ok(format!("crossCall(\"{}\", \"{}\", [{}])", language, function, args_str))
            }
            Expression::Unary { operator, operand, .. } => {
                let operand_str = self.generate_expression(operand)?;
                let op_str = match operator {
                    UnaryOperator::Minus => "-",
                    UnaryOperator::Plus => "+",
                    UnaryOperator::Not => "!",
                };
                Ok(format!("({}{})", op_str, operand_str))
            }
            _ => Ok("/* Unsupported expression */".to_string()),
        }
    }
    
    fn convert_return_type(&self, return_type: &Option<crate::types::Type>) -> String {
        match return_type {
            Some(crate::types::Type::Number) => "double",
            Some(crate::types::Type::String) => "String",
            Some(crate::types::Type::Boolean) => "bool",
            Some(crate::types::Type::Void) => "void",
            Some(crate::types::Type::Array(_)) => "List<dynamic>",
            Some(crate::types::Type::Object(_)) => "Map<String, dynamic>",
            _ => "dynamic",
        }.to_string()
    }
    
    fn convert_type(&self, utopia_type: Option<&crate::types::Type>) -> String {
        match utopia_type {
            Some(crate::types::Type::Number) => "double".to_string(),
            Some(crate::types::Type::String) => "String".to_string(),
            Some(crate::types::Type::Boolean) => "bool".to_string(),
            Some(crate::types::Type::Array(_)) => "List<dynamic>".to_string(),
            Some(crate::types::Type::Object(_)) => "Map<String, dynamic>".to_string(),
            _ => "dynamic".to_string(),
        }
    }
}

/// Lua code generator
pub struct LuaTransformer;

impl Transformer for LuaTransformer {
    fn transform(&self, program: &Program) -> Result<String> {
        let mut output = String::new();
        output.push_str("-- Generated by Utopia Compiler - Lua Backend\n");
        output.push_str("-- Multi-language support with runtime integration\n");
        output.push_str("-- Game scripting and embedded systems\n\n");
        
        // Lua requires
        output.push_str("local json = require('json')\n");
        output.push_str("local socket = require('socket')\n\n");
        
        // Process language blocks
        for block in &program.language_blocks {
            if block.language == "lua" || block.language == "main" {
                output.push_str(&self.generate_lua_functions(block)?);
            } else {
                output.push_str(&self.generate_cross_language_functions(block)?);
            }
        }
        
        // Global statements in main execution
        if !program.global_statements.is_empty() {
            output.push_str("-- Main execution\n");
            for statement in &program.global_statements {
                output.push_str(&format!("{}\n", self.generate_statement(statement)?));
            }
        }
        
        Ok(output)
    }
    
    fn target_name(&self) -> &str {
        "lua"
    }
    
    fn file_extension(&self) -> &str {
        ".lua"
    }
    
    fn supports_language(&self, language: &str) -> bool {
        language == "lua"
    }
}

impl LuaTransformer {
    fn generate_lua_functions(&self, block: &LanguageBlock) -> Result<String> {
        let mut output = String::new();
        
        for function in &block.functions {
            output.push_str(&self.generate_function(function)?);
            output.push('\n');
        }
        
        Ok(output)
    }
    
    fn generate_cross_language_functions(&self, block: &LanguageBlock) -> Result<String> {
        let mut output = String::new();
        output.push_str(&format!("-- Cross-language block: {}\n", block.language));
        
        for function in &block.functions {
            output.push_str(&format!("function {}(...)\n", function.name));
            output.push_str(&format!(
                "  error('Cross-language call to {}::{} not implemented')\n",
                block.language, function.name
            ));
            output.push_str("end\n\n");
        }
        
        Ok(output)
    }
    
    fn generate_function(&self, function: &Function) -> Result<String> {
        let mut output = String::new();
        
        // Function definition
        output.push_str(&format!("function {}(", function.name));
        
        // Parameters
        for (i, param) in function.parameters.iter().enumerate() {
            if i > 0 {
                output.push_str(", ");
            }
            output.push_str(&param.name);
        }
        
        output.push_str(")\n");
        
        // Function body
        for statement in &function.body {
            output.push_str(&format!("  {}\n", self.generate_statement(statement)?));
        }
        
        output.push_str("end\n");
        Ok(output)
    }
    
    fn generate_statement(&self, statement: &Statement) -> Result<String> {
        match statement {
            Statement::VariableDeclaration { name, value, .. } => {
                if let Some(expr) = value {
                    Ok(format!("local {} = {}", name, self.generate_expression(expr)?))
                } else {
                    Ok(format!("local {}", name))
                }
            }
            Statement::Return { value, .. } => {
                if let Some(expr) = value {
                    Ok(format!("return {}", self.generate_expression(expr)?))
                } else {
                    Ok("return".to_string())
                }
            }
            Statement::Expression { expression, .. } => {
                self.generate_expression(expression)
            }
            Statement::If { condition, then_branch, else_branch, .. } => {
                let mut output = format!("if {} then\n", self.generate_expression(condition)?);
                for stmt in then_branch {
                    output.push_str(&format!("    {}\n", self.generate_statement(stmt)?));
                }
                if let Some(else_stmts) = else_branch {
                    output.push_str("  else\n");
                    for stmt in else_stmts {
                        output.push_str(&format!("    {}\n", self.generate_statement(stmt)?));
                    }
                }
                output.push_str("  end");
                Ok(output)
            }
            _ => Ok("-- Unsupported statement".to_string()),
        }
    }
    
    fn generate_expression(&self, expression: &Expression) -> Result<String> {
        match expression {
            Expression::Literal { value, .. } => {
                match value {
                    LiteralValue::Number(n) => Ok(n.to_string()),
                    LiteralValue::String(s) => Ok(format!("\"{}\"", s.replace('"', "\\\""))),
                    LiteralValue::Boolean(b) => Ok(b.to_string()),
                    LiteralValue::Null => Ok("nil".to_string()),
                }
            }
            Expression::Identifier { name, .. } => Ok(name.clone()),
            Expression::Binary { left, operator, right, .. } => {
                let left_str = self.generate_expression(left)?;
                let right_str = self.generate_expression(right)?;
                let op_str = match operator {
                    BinaryOperator::Add => "+",
                    BinaryOperator::Subtract => "-",
                    BinaryOperator::Multiply => "*",
                    BinaryOperator::Divide => "/",
                    BinaryOperator::Equal => "==",
                    BinaryOperator::NotEqual => "~=",
                    BinaryOperator::Less => "<",
                    BinaryOperator::Greater => ">",
                    BinaryOperator::LessEqual => "<=",
                    BinaryOperator::GreaterEqual => ">=",
                    BinaryOperator::And => "and",
                    BinaryOperator::Or => "or",
                    _ => "-- unsupported op --",
                };
                Ok(format!("({} {} {})", left_str, op_str, right_str))
            }
            Expression::Call { callee, arguments, .. } => {
                let callee_str = match callee.as_ref() {
                    Expression::Identifier { name, .. } => name.clone(),
                    _ => self.generate_expression(callee)?,
                };
                let args: Result<Vec<String>> = arguments.iter()
                    .map(|arg| self.generate_expression(arg))
                    .collect();
                let args_str = args?.join(", ");
                Ok(format!("{}({})", callee_str, args_str))
            }
            Expression::CrossCall { language, function, arguments, .. } => {
                let args: Result<Vec<String>> = arguments.iter()
                    .map(|arg| self.generate_expression(arg))
                    .collect();
                let args_str = args?.join(", ");
                Ok(format!("cross_call(\"{}\", \"{}\", {{{}}})", language, function, args_str))
            }
            Expression::Unary { operator, operand, .. } => {
                let operand_str = self.generate_expression(operand)?;
                let op_str = match operator {
                    UnaryOperator::Minus => "-",
                    UnaryOperator::Plus => "+",
                    UnaryOperator::Not => "not ",
                };
                Ok(format!("({}{})", op_str, operand_str))
            }
            _ => Ok("-- Unsupported expression --".to_string()),
        }
    }
}

/// Haskell code generator
pub struct HaskellTransformer;

impl Transformer for HaskellTransformer {
    fn transform(&self, program: &Program) -> Result<String> {
        let mut output = String::new();
        output.push_str("-- Generated by Utopia Compiler - Haskell Backend\n");
        output.push_str("-- Multi-language support with runtime integration\n");
        output.push_str("-- Pure functional programming with lazy evaluation\n\n");
        
        // Module declaration
        output.push_str("module UtopiaGenerated where\n\n");
        
        // Imports
        output.push_str("import Data.List\n");
        output.push_str("import Data.Maybe\n");
        output.push_str("import Control.Monad\n");
        output.push_str("import System.IO\n\n");
        
        // Process language blocks
        for block in &program.language_blocks {
            if block.language == "haskell" || block.language == "hs" || block.language == "main" {
                output.push_str(&self.generate_haskell_functions(block)?);
            } else {
                output.push_str(&self.generate_cross_language_functions(block)?);
            }
        }
        
        // Main function if needed
        if !program.global_statements.is_empty() {
            output.push_str("main :: IO ()\n");
            output.push_str("main = do\n");
            for statement in &program.global_statements {
                output.push_str(&format!("  {}\n", self.generate_statement(statement)?));
            }
        }
        
        Ok(output)
    }
    
    fn target_name(&self) -> &str {
        "haskell"
    }
    
    fn file_extension(&self) -> &str {
        ".hs"
    }
    
    fn supports_language(&self, language: &str) -> bool {
        matches!(language, "haskell" | "hs")
    }
}

impl HaskellTransformer {
    fn generate_haskell_functions(&self, block: &LanguageBlock) -> Result<String> {
        let mut output = String::new();
        
        for function in &block.functions {
            output.push_str(&self.generate_function(function)?);
            output.push('\n');
        }
        
        Ok(output)
    }
    
    fn generate_cross_language_functions(&self, block: &LanguageBlock) -> Result<String> {
        let mut output = String::new();
        output.push_str(&format!("-- Cross-language block: {}\n", block.language));
        
        for function in &block.functions {
            output.push_str(&format!("{} :: a -> String\n", function.name));
            output.push_str(&format!("{} _ = error \"Cross-language call to {}::{} not implemented\"\n\n", 
                function.name, block.language, function.name));
        }
        
        Ok(output)
    }
    
    fn generate_function(&self, function: &Function) -> Result<String> {
        let mut output = String::new();
        
        // Function type signature (simplified)
        let return_type = self.convert_return_type(&function.return_type);
        let param_types = function.parameters.iter()
            .map(|_| "String".to_string()) // Simplified - using String for all params
            .collect::<Vec<_>>()
            .join(" -> ");
        
        if !param_types.is_empty() {
            output.push_str(&format!("{} :: {} -> {}\n", function.name, param_types, return_type));
        } else {
            output.push_str(&format!("{} :: {}\n", function.name, return_type));
        }
        
        // Function definition
        output.push_str(&format!("{}", function.name));
        for param in &function.parameters {
            output.push_str(&format!(" {}", param.name));
        }
        output.push_str(" =\n");
        
        // Function body (simplified - just return the first statement or a default)
        if let Some(first_stmt) = function.body.first() {
            if let Statement::Return { value: Some(expr), .. } = first_stmt {
                output.push_str(&format!("  {}\n", self.generate_expression(expr)?));
            } else {
                output.push_str("  \"function body\"\n");
            }
        } else {
            output.push_str("  \"empty function\"\n");
        }
        
        Ok(output)
    }
    
    fn generate_statement(&self, statement: &Statement) -> Result<String> {
        match statement {
            Statement::VariableDeclaration { name, value, .. } => {
                if let Some(expr) = value {
                    Ok(format!("let {} = {} in", name, self.generate_expression(expr)?))
                } else {
                    Ok(format!("let {} = undefined in", name))
                }
            }
            Statement::Return { value, .. } => {
                if let Some(expr) = value {
                    Ok(format!("return {}", self.generate_expression(expr)?))
                } else {
                    Ok("return ()".to_string())
                }
            }
            Statement::Expression { expression, .. } => {
                match expression {
                    Expression::Call { callee, .. } => {
                        Ok(format!("putStrLn $ show $ {}", self.generate_expression(expression)?))
                    }
                    _ => self.generate_expression(expression)
                }
            }
            _ => Ok("-- Unsupported statement".to_string()),
        }
    }
    
    fn generate_expression(&self, expression: &Expression) -> Result<String> {
        match expression {
            Expression::Literal { value, .. } => {
                match value {
                    LiteralValue::Number(n) => Ok(n.to_string()),
                    LiteralValue::String(s) => Ok(format!("\"{}\"", s.replace('"', "\\\""))),
                    LiteralValue::Boolean(b) => Ok(if *b { "True" } else { "False" }.to_string()),
                    LiteralValue::Null => Ok("Nothing".to_string()),
                }
            }
            Expression::Identifier { name, .. } => Ok(name.clone()),
            Expression::Binary { left, operator, right, .. } => {
                let left_str = self.generate_expression(left)?;
                let right_str = self.generate_expression(right)?;
                let op_str = match operator {
                    BinaryOperator::Add => "++", // String concatenation in Haskell
                    BinaryOperator::Subtract => "-",
                    BinaryOperator::Multiply => "*",
                    BinaryOperator::Divide => "/",
                    BinaryOperator::Equal => "==",
                    BinaryOperator::NotEqual => "/=",
                    BinaryOperator::Less => "<",
                    BinaryOperator::Greater => ">",
                    BinaryOperator::LessEqual => "<=",
                    BinaryOperator::GreaterEqual => ">=",
                    BinaryOperator::And => "&&",
                    BinaryOperator::Or => "||",
                    _ => "-- unsupported op --",
                };
                Ok(format!("({} {} {})", left_str, op_str, right_str))
            }
            Expression::Call { callee, arguments, .. } => {
                let callee_str = match callee.as_ref() {
                    Expression::Identifier { name, .. } => name.clone(),
                    _ => self.generate_expression(callee)?,
                };
                let args: Result<Vec<String>> = arguments.iter()
                    .map(|arg| self.generate_expression(arg))
                    .collect();
                let args_str = args?.join(" ");
                if args_str.is_empty() {
                    Ok(callee_str)
                } else {
                    Ok(format!("({} {})", callee_str, args_str))
                }
            }
            Expression::CrossCall { language, function, arguments, .. } => {
                let args: Result<Vec<String>> = arguments.iter()
                    .map(|arg| self.generate_expression(arg))
                    .collect();
                let args_str = args?.join(" ");
                Ok(format!("crossCall \"{}\" \"{}\" [{}]", language, function, args_str))
            }
            Expression::Unary { operator, operand, .. } => {
                let operand_str = self.generate_expression(operand)?;
                let op_str = match operator {
                    UnaryOperator::Minus => "-",
                    UnaryOperator::Plus => "+",
                    UnaryOperator::Not => "not",
                };
                Ok(format!("({} {})", op_str, operand_str))
            }
            _ => Ok("-- Unsupported expression --".to_string()),
        }
    }
    
    fn convert_return_type(&self, return_type: &Option<crate::types::Type>) -> String {
        match return_type {
            Some(crate::types::Type::Number) => "Double",
            Some(crate::types::Type::String) => "String", 
            Some(crate::types::Type::Boolean) => "Bool",
            Some(crate::types::Type::Void) => "()",
            Some(crate::types::Type::Array(_)) => "[String]",
            Some(crate::types::Type::Object(_)) => "[(String, String)]",
            _ => "String",
        }.to_string()
    }
}

/// Objective-C code generator
pub struct ObjectiveCTransformer;

impl Transformer for ObjectiveCTransformer {
    fn transform(&self, program: &Program) -> Result<String> {
        let mut output = String::new();
        output.push_str("// Generated by Utopia Compiler - Objective-C Backend\n");
        output.push_str("// Multi-language support with runtime integration\n");
        output.push_str("// Legacy iOS/macOS development\n\n");
        
        // Imports
        output.push_str("#import <Foundation/Foundation.h>\n");
        output.push_str("#import <UIKit/UIKit.h>\n");
        output.push_str("#import <CoreFoundation/CoreFoundation.h>\n\n");
        
        // Interface declarations
        output.push_str("@interface UtopiaRuntime : NSObject\n");
        
        // Process language blocks for method declarations
        for block in &program.language_blocks {
            if block.language == "objc" || block.language == "objective-c" || block.language == "main" {
                for function in &block.functions {
                    output.push_str(&format!("+ (id){}", self.generate_method_signature(function)?));
                    output.push_str(";\n");
                }
            }
        }
        
        output.push_str("@end\n\n");
        
        // Implementation
        output.push_str("@implementation UtopiaRuntime\n\n");
        
        for block in &program.language_blocks {
            if block.language == "objc" || block.language == "objective-c" || block.language == "main" {
                output.push_str(&self.generate_objc_methods(block)?);
            } else {
                output.push_str(&self.generate_cross_language_methods(block)?);
            }
        }
        
        // Main function if needed
        if !program.global_statements.is_empty() {
            output.push_str("+ (void)main {\n");
            for statement in &program.global_statements {
                output.push_str(&format!("    {};\n", self.generate_statement(statement)?));
            }
            output.push_str("}\n\n");
        }
        
        output.push_str("@end\n");
        
        Ok(output)
    }
    
    fn target_name(&self) -> &str {
        "objective-c"
    }
    
    fn file_extension(&self) -> &str {
        ".m"
    }
    
    fn supports_language(&self, language: &str) -> bool {
        matches!(language, "objc" | "objective-c" | "objectivec")
    }
}

impl ObjectiveCTransformer {
    fn generate_objc_methods(&self, block: &LanguageBlock) -> Result<String> {
        let mut output = String::new();
        
        for function in &block.functions {
            output.push_str(&self.generate_method(function)?);
            output.push('\n');
        }
        
        Ok(output)
    }
    
    fn generate_cross_language_methods(&self, block: &LanguageBlock) -> Result<String> {
        let mut output = String::new();
        output.push_str(&format!("// Cross-language block: {}\n", block.language));
        
        for function in &block.functions {
            output.push_str(&format!("+ (id){} {{\n", self.generate_method_signature(function)?));
            output.push_str(&format!(
                "    @throw [NSException exceptionWithName:@\"NotImplemented\" reason:@\"Cross-language call to {}::{} not implemented\" userInfo:nil];\n",
                block.language, function.name
            ));
            output.push_str("}\n\n");
        }
        
        Ok(output)
    }
    
    fn generate_method_signature(&self, function: &Function) -> Result<String> {
        let mut signature = String::new();
        
        signature.push_str(&function.name);
        
        if !function.parameters.is_empty() {
            signature.push(':');
            for (i, param) in function.parameters.iter().enumerate() {
                if i == 0 {
                    signature.push_str(&format!("(id){}", param.name));
                } else {
                    signature.push_str(&format!(" {}:(id){}", param.name, param.name));
                }
            }
        }
        
        Ok(signature)
    }
    
    fn generate_method(&self, function: &Function) -> Result<String> {
        let mut output = String::new();
        
        // Method implementation
        output.push_str(&format!("+ (id){} {{\n", self.generate_method_signature(function)?));
        
        // Method body
        for statement in &function.body {
            output.push_str(&format!("    {};\n", self.generate_statement(statement)?));
        }
        
        output.push_str("}\n");
        Ok(output)
    }
    
    fn generate_statement(&self, statement: &Statement) -> Result<String> {
        match statement {
            Statement::VariableDeclaration { name, value, .. } => {
                if let Some(expr) = value {
                    Ok(format!("id {} = {}", name, self.generate_expression(expr)?))
                } else {
                    Ok(format!("id {};", name))
                }
            }
            Statement::Return { value, .. } => {
                if let Some(expr) = value {
                    Ok(format!("return {}", self.generate_expression(expr)?))
                } else {
                    Ok("return nil".to_string())
                }
            }
            Statement::Expression { expression, .. } => {
                self.generate_expression(expression)
            }
            Statement::If { condition, then_branch, else_branch, .. } => {
                let mut output = format!("if ({}) {{\n", self.generate_expression(condition)?);
                for stmt in then_branch {
                    output.push_str(&format!("        {};\n", self.generate_statement(stmt)?));
                }
                output.push_str("    }");
                if let Some(else_stmts) = else_branch {
                    output.push_str(" else {\n");
                    for stmt in else_stmts {
                        output.push_str(&format!("        {};\n", self.generate_statement(stmt)?));
                    }
                    output.push_str("    }");
                }
                Ok(output)
            }
            _ => Ok("// Unsupported statement".to_string()),
        }
    }
    
    fn generate_expression(&self, expression: &Expression) -> Result<String> {
        match expression {
            Expression::Literal { value, .. } => {
                match value {
                    LiteralValue::Number(n) => Ok(format!("@({})", n)),
                    LiteralValue::String(s) => Ok(format!("@\"{}\"", s.replace('"', "\\\""))),
                    LiteralValue::Boolean(b) => Ok(if *b { "@YES" } else { "@NO" }.to_string()),
                    LiteralValue::Null => Ok("nil".to_string()),
                }
            }
            Expression::Identifier { name, .. } => Ok(name.clone()),
            Expression::Binary { left, operator, right, .. } => {
                let left_str = self.generate_expression(left)?;
                let right_str = self.generate_expression(right)?;
                let op_str = match operator {
                    BinaryOperator::Add => "+",
                    BinaryOperator::Subtract => "-",
                    BinaryOperator::Multiply => "*",
                    BinaryOperator::Divide => "/",
                    BinaryOperator::Equal => "==",
                    BinaryOperator::NotEqual => "!=",
                    BinaryOperator::Less => "<",
                    BinaryOperator::Greater => ">",
                    BinaryOperator::LessEqual => "<=",
                    BinaryOperator::GreaterEqual => ">=",
                    BinaryOperator::And => "&&",
                    BinaryOperator::Or => "||",
                    _ => "/* unsupported op */",
                };
                Ok(format!("({} {} {})", left_str, op_str, right_str))
            }
            Expression::Call { callee, arguments, .. } => {
                let callee_str = match callee.as_ref() {
                    Expression::Identifier { name, .. } => name.clone(),
                    _ => self.generate_expression(callee)?,
                };
                let args: Result<Vec<String>> = arguments.iter()
                    .map(|arg| self.generate_expression(arg))
                    .collect();
                let args_vec = args?;
                
                if args_vec.is_empty() {
                    Ok(format!("[UtopiaRuntime {}]", callee_str))
                } else if args_vec.len() == 1 {
                    Ok(format!("[UtopiaRuntime {}:{}]", callee_str, args_vec[0]))
                } else {
                    // Multiple arguments - use labeled parameters
                    let mut call = format!("[UtopiaRuntime {}:{}", callee_str, args_vec[0]);
                    for (i, arg) in args_vec.iter().skip(1).enumerate() {
                        call.push_str(&format!(" arg{}:{}", i + 1, arg));
                    }
                    call.push(']');
                    Ok(call)
                }
            }
            Expression::CrossCall { language, function, arguments, .. } => {
                let args: Result<Vec<String>> = arguments.iter()
                    .map(|arg| self.generate_expression(arg))
                    .collect();
                let args_str = args?.join(", ");
                Ok(format!("crossCall(@\"{}\", @\"{}\", @[{}])", language, function, args_str))
            }
            Expression::Unary { operator, operand, .. } => {
                let operand_str = self.generate_expression(operand)?;
                let op_str = match operator {
                    UnaryOperator::Minus => "-",
                    UnaryOperator::Plus => "+",
                    UnaryOperator::Not => "!",
                };
                Ok(format!("({}{})", op_str, operand_str))
            }
            _ => Ok("/* Unsupported expression */".to_string()),
        }
    }
}

/// Scala code generator
pub struct ScalaTransformer;

impl Transformer for ScalaTransformer {
    fn transform(&self, program: &Program) -> Result<String> {
        let mut output = String::new();
        output.push_str("// Generated by Utopia Compiler - Scala Backend\n");
        output.push_str("// Multi-language support with runtime integration\n");
        output.push_str("// Big data processing and functional programming on JVM\n\n");
        
        // Package and imports
        output.push_str("package utopia.generated\n\n");
        output.push_str("import scala.collection.mutable\n");
        output.push_str("import scala.concurrent.Future\n");
        output.push_str("import scala.util.{Try, Success, Failure}\n");
        output.push_str("import org.apache.spark.sql._\n");
        output.push_str("import play.api.libs.json._\n\n");
        
        // Main object
        output.push_str("object UtopiaProgram {\n\n");
        
        // Process language blocks
        for block in &program.language_blocks {
            if block.language == "scala" || block.language == "main" {
                output.push_str(&self.generate_scala_functions(block)?);
            } else {
                output.push_str(&self.generate_cross_language_functions(block)?);
            }
        }
        
        // Main method if needed
        if !program.global_statements.is_empty() {
            output.push_str("  def main(args: Array[String]): Unit = {\n");
            for statement in &program.global_statements {
                output.push_str(&format!("    {}\n", self.generate_statement(statement)?));
            }
            output.push_str("  }\n\n");
        }
        
        output.push_str("}\n");
        
        Ok(output)
    }
    
    fn target_name(&self) -> &str {
        "scala"
    }
    
    fn file_extension(&self) -> &str {
        ".scala"
    }
    
    fn supports_language(&self, language: &str) -> bool {
        language == "scala"
    }
}

impl ScalaTransformer {
    fn generate_scala_functions(&self, block: &LanguageBlock) -> Result<String> {
        let mut output = String::new();
        
        for function in &block.functions {
            output.push_str(&self.generate_function(function)?);
            output.push('\n');
        }
        
        Ok(output)
    }
    
    fn generate_cross_language_functions(&self, block: &LanguageBlock) -> Result<String> {
        let mut output = String::new();
        output.push_str(&format!("  // Cross-language block: {}\n", block.language));
        
        for function in &block.functions {
            output.push_str(&format!("  def {}(args: Any*): Any = {{\n", function.name));
            output.push_str(&format!(
                "    throw new NotImplementedError(\"Cross-language call to {}::{} not implemented\")\n",
                block.language, function.name
            ));
            output.push_str("  }\n\n");
        }
        
        Ok(output)
    }
    
    fn generate_function(&self, function: &Function) -> Result<String> {
        let mut output = String::new();
        
        // Function signature
        output.push_str(&format!("  def {}(", function.name));
        
        // Parameters
        for (i, param) in function.parameters.iter().enumerate() {
            if i > 0 {
                output.push_str(", ");
            }
            output.push_str(&format!("{}: Any", param.name));
        }
        
        output.push_str("): Any = {\n");
        
        // Function body
        for statement in &function.body {
            output.push_str(&format!("    {}\n", self.generate_statement(statement)?));
        }
        
        output.push_str("  }\n");
        Ok(output)
    }
    
    fn generate_statement(&self, statement: &Statement) -> Result<String> {
        match statement {
            Statement::VariableDeclaration { name, value, .. } => {
                if let Some(expr) = value {
                    Ok(format!("val {} = {}", name, self.generate_expression(expr)?))
                } else {
                    Ok(format!("val {}: Any = null", name))
                }
            }
            Statement::Return { value, .. } => {
                if let Some(expr) = value {
                    self.generate_expression(expr)
                } else {
                    Ok("()".to_string())
                }
            }
            Statement::Expression { expression, .. } => {
                self.generate_expression(expression)
            }
            Statement::If { condition, then_branch, else_branch, .. } => {
                let mut output = format!("if ({}) {{\n", self.generate_expression(condition)?);
                for stmt in then_branch {
                    output.push_str(&format!("      {}\n", self.generate_statement(stmt)?));
                }
                output.push_str("    }");
                if let Some(else_stmts) = else_branch {
                    output.push_str(" else {\n");
                    for stmt in else_stmts {
                        output.push_str(&format!("      {}\n", self.generate_statement(stmt)?));
                    }
                    output.push_str("    }");
                }
                Ok(output)
            }
            _ => Ok("// Unsupported statement".to_string()),
        }
    }
    
    fn generate_expression(&self, expression: &Expression) -> Result<String> {
        match expression {
            Expression::Literal { value, .. } => {
                match value {
                    LiteralValue::Number(n) => Ok(n.to_string()),
                    LiteralValue::String(s) => Ok(format!("\"{}\"", s.replace('"', "\\\""))),
                    LiteralValue::Boolean(b) => Ok(b.to_string()),
                    LiteralValue::Null => Ok("null".to_string()),
                }
            }
            Expression::Identifier { name, .. } => Ok(name.clone()),
            Expression::Binary { left, operator, right, .. } => {
                let left_str = self.generate_expression(left)?;
                let right_str = self.generate_expression(right)?;
                let op_str = match operator {
                    BinaryOperator::Add => "+",
                    BinaryOperator::Subtract => "-",
                    BinaryOperator::Multiply => "*",
                    BinaryOperator::Divide => "/",
                    BinaryOperator::Equal => "==",
                    BinaryOperator::NotEqual => "!=",
                    BinaryOperator::Less => "<",
                    BinaryOperator::Greater => ">",
                    BinaryOperator::LessEqual => "<=",
                    BinaryOperator::GreaterEqual => ">=",
                    BinaryOperator::And => "&&",
                    BinaryOperator::Or => "||",
                    _ => "/* unsupported op */",
                };
                Ok(format!("({} {} {})", left_str, op_str, right_str))
            }
            Expression::Call { callee, arguments, .. } => {
                let callee_str = match callee.as_ref() {
                    Expression::Identifier { name, .. } => name.clone(),
                    _ => self.generate_expression(callee)?,
                };
                let args: Result<Vec<String>> = arguments.iter()
                    .map(|arg| self.generate_expression(arg))
                    .collect();
                let args_str = args?.join(", ");
                Ok(format!("{}({})", callee_str, args_str))
            }
            Expression::CrossCall { language, function, arguments, .. } => {
                let args: Result<Vec<String>> = arguments.iter()
                    .map(|arg| self.generate_expression(arg))
                    .collect();
                let args_str = args?.join(", ");
                Ok(format!("crossCall(\"{}\", \"{}\", List({}))", language, function, args_str))
            }
            Expression::Unary { operator, operand, .. } => {
                let operand_str = self.generate_expression(operand)?;
                let op_str = match operator {
                    UnaryOperator::Minus => "-",
                    UnaryOperator::Plus => "+",
                    UnaryOperator::Not => "!",
                };
                Ok(format!("({}{})", op_str, operand_str))
            }
            _ => Ok("/* Unsupported expression */".to_string()),
        }
    }
}

/// Julia code generator
pub struct JuliaTransformer;

impl Transformer for JuliaTransformer {
    fn transform(&self, program: &Program) -> Result<String> {
        let mut output = String::new();
        output.push_str("# Generated by Utopia Compiler - Julia Backend\n");
        output.push_str("# Multi-language support with runtime integration\n");
        output.push_str("# High-performance scientific computing\n\n");
        
        // Julia imports
        output.push_str("using LinearAlgebra\n");
        output.push_str("using Statistics\n");
        output.push_str("using DataFrames\n");
        output.push_str("using Plots\n");
        output.push_str("using JSON\n\n");
        
        // Process language blocks
        for block in &program.language_blocks {
            if block.language == "julia" || block.language == "jl" || block.language == "main" {
                output.push_str(&self.generate_julia_functions(block)?);
            } else {
                output.push_str(&self.generate_cross_language_functions(block)?);
            }
        }
        
        // Main execution if needed
        if !program.global_statements.is_empty() {
            output.push_str("function main()\n");
            for statement in &program.global_statements {
                output.push_str(&format!("    {}\n", self.generate_statement(statement)?));
            }
            output.push_str("end\n\n");
            output.push_str("main()\n");
        }
        
        Ok(output)
    }
    
    fn target_name(&self) -> &str {
        "julia"
    }
    
    fn file_extension(&self) -> &str {
        ".jl"
    }
    
    fn supports_language(&self, language: &str) -> bool {
        matches!(language, "julia" | "jl")
    }
}

impl JuliaTransformer {
    fn generate_julia_functions(&self, block: &LanguageBlock) -> Result<String> {
        let mut output = String::new();
        
        for function in &block.functions {
            output.push_str(&self.generate_function(function)?);
            output.push('\n');
        }
        
        Ok(output)
    }
    
    fn generate_cross_language_functions(&self, block: &LanguageBlock) -> Result<String> {
        let mut output = String::new();
        output.push_str(&format!("# Cross-language block: {}\n", block.language));
        
        for function in &block.functions {
            output.push_str(&format!("function {}(args...)\n", function.name));
            output.push_str(&format!(
                "    error(\"Cross-language call to {}::{} not implemented\")\n",
                block.language, function.name
            ));
            output.push_str("end\n\n");
        }
        
        Ok(output)
    }
    
    fn generate_function(&self, function: &Function) -> Result<String> {
        let mut output = String::new();
        
        // Function definition
        output.push_str(&format!("function {}(", function.name));
        
        // Parameters
        for (i, param) in function.parameters.iter().enumerate() {
            if i > 0 {
                output.push_str(", ");
            }
            output.push_str(&param.name);
        }
        
        output.push_str(")\n");
        
        // Function body
        for statement in &function.body {
            output.push_str(&format!("    {}\n", self.generate_statement(statement)?));
        }
        
        output.push_str("end\n");
        Ok(output)
    }
    
    fn generate_statement(&self, statement: &Statement) -> Result<String> {
        match statement {
            Statement::VariableDeclaration { name, value, .. } => {
                if let Some(expr) = value {
                    Ok(format!("{} = {}", name, self.generate_expression(expr)?))
                } else {
                    Ok(format!("{} = nothing", name))
                }
            }
            Statement::Return { value, .. } => {
                if let Some(expr) = value {
                    Ok(format!("return {}", self.generate_expression(expr)?))
                } else {
                    Ok("return nothing".to_string())
                }
            }
            Statement::Expression { expression, .. } => {
                self.generate_expression(expression)
            }
            Statement::If { condition, then_branch, else_branch, .. } => {
                let mut output = format!("if {}\n", self.generate_expression(condition)?);
                for stmt in then_branch {
                    output.push_str(&format!("        {}\n", self.generate_statement(stmt)?));
                }
                if let Some(else_stmts) = else_branch {
                    output.push_str("    else\n");
                    for stmt in else_stmts {
                        output.push_str(&format!("        {}\n", self.generate_statement(stmt)?));
                    }
                }
                output.push_str("    end");
                Ok(output)
            }
            _ => Ok("# Unsupported statement".to_string()),
        }
    }
    
    fn generate_expression(&self, expression: &Expression) -> Result<String> {
        match expression {
            Expression::Literal { value, .. } => {
                match value {
                    LiteralValue::Number(n) => Ok(n.to_string()),
                    LiteralValue::String(s) => Ok(format!("\"{}\"", s.replace('"', "\\\""))),
                    LiteralValue::Boolean(b) => Ok(b.to_string()),
                    LiteralValue::Null => Ok("nothing".to_string()),
                }
            }
            Expression::Identifier { name, .. } => Ok(name.clone()),
            Expression::Binary { left, operator, right, .. } => {
                let left_str = self.generate_expression(left)?;
                let right_str = self.generate_expression(right)?;
                let op_str = match operator {
                    BinaryOperator::Add => "+",
                    BinaryOperator::Subtract => "-",
                    BinaryOperator::Multiply => "*",
                    BinaryOperator::Divide => "/",
                    BinaryOperator::Equal => "==",
                    BinaryOperator::NotEqual => "!=",
                    BinaryOperator::Less => "<",
                    BinaryOperator::Greater => ">",
                    BinaryOperator::LessEqual => "<=",
                    BinaryOperator::GreaterEqual => ">=",
                    BinaryOperator::And => "&&",
                    BinaryOperator::Or => "||",
                    _ => "# unsupported op #",
                };
                Ok(format!("({} {} {})", left_str, op_str, right_str))
            }
            Expression::Call { callee, arguments, .. } => {
                let callee_str = match callee.as_ref() {
                    Expression::Identifier { name, .. } => name.clone(),
                    _ => self.generate_expression(callee)?,
                };
                let args: Result<Vec<String>> = arguments.iter()
                    .map(|arg| self.generate_expression(arg))
                    .collect();
                let args_str = args?.join(", ");
                Ok(format!("{}({})", callee_str, args_str))
            }
            Expression::CrossCall { language, function, arguments, .. } => {
                let args: Result<Vec<String>> = arguments.iter()
                    .map(|arg| self.generate_expression(arg))
                    .collect();
                let args_str = args?.join(", ");
                Ok(format!("cross_call(\"{}\", \"{}\", [{}])", language, function, args_str))
            }
            Expression::Unary { operator, operand, .. } => {
                let operand_str = self.generate_expression(operand)?;
                let op_str = match operator {
                    UnaryOperator::Minus => "-",
                    UnaryOperator::Plus => "+",
                    UnaryOperator::Not => "!",
                };
                Ok(format!("({}{})", op_str, operand_str))
            }
            _ => Ok("# Unsupported expression #".to_string()),
        }
    }
}

/// VBScript code generator
pub struct VBScriptTransformer;

impl Transformer for VBScriptTransformer {
    fn transform(&self, program: &Program) -> Result<String> {
        let mut output = String::new();
        output.push_str("' Generated by Utopia Compiler - VBScript Backend\n");
        output.push_str("' Multi-language support with runtime integration\n");
        output.push_str("' Windows automation and scripting\n\n");
        
        // Process language blocks
        for block in &program.language_blocks {
            if block.language == "vbscript" || block.language == "vbs" || block.language == "main" {
                output.push_str(&self.generate_vbscript_functions(block)?);
            } else {
                output.push_str(&self.generate_cross_language_functions(block)?);
            }
        }
        
        // Main execution if needed
        if !program.global_statements.is_empty() {
            output.push_str("' Main execution\n");
            for statement in &program.global_statements {
                output.push_str(&format!("{}\n", self.generate_statement(statement)?));
            }
        }
        
        Ok(output)
    }
    
    fn target_name(&self) -> &str {
        "vbscript"
    }
    
    fn file_extension(&self) -> &str {
        ".vbs"
    }
    
    fn supports_language(&self, language: &str) -> bool {
        matches!(language, "vbscript" | "vbs")
    }
}

impl VBScriptTransformer {
    fn generate_vbscript_functions(&self, block: &LanguageBlock) -> Result<String> {
        let mut output = String::new();
        
        for function in &block.functions {
            output.push_str(&self.generate_function(function)?);
            output.push('\n');
        }
        
        Ok(output)
    }
    
    fn generate_cross_language_functions(&self, block: &LanguageBlock) -> Result<String> {
        let mut output = String::new();
        output.push_str(&format!("' Cross-language block: {}\n", block.language));
        
        for function in &block.functions {
            output.push_str(&format!("Function {}()\n", function.name));
            output.push_str(&format!(
                "    Err.Raise 1, \"NotImplemented\", \"Cross-language call to {}::{} not implemented\"\n",
                block.language, function.name
            ));
            output.push_str("End Function\n\n");
        }
        
        Ok(output)
    }
    
    fn generate_function(&self, function: &Function) -> Result<String> {
        let mut output = String::new();
        
        // Function definition
        let has_return = function.return_type.is_some() && 
            !matches!(function.return_type, Some(crate::types::Type::Void));
        
        if has_return {
            output.push_str(&format!("Function {}(", function.name));
        } else {
            output.push_str(&format!("Sub {}(", function.name));
        }
        
        // Parameters
        for (i, param) in function.parameters.iter().enumerate() {
            if i > 0 {
                output.push_str(", ");
            }
            output.push_str(&param.name);
        }
        
        output.push_str(")\n");
        
        // Function body
        for statement in &function.body {
            output.push_str(&format!("    {}\n", self.generate_statement(statement)?));
        }
        
        if has_return {
            output.push_str("End Function\n");
        } else {
            output.push_str("End Sub\n");
        }
        
        Ok(output)
    }
    
    fn generate_statement(&self, statement: &Statement) -> Result<String> {
        match statement {
            Statement::VariableDeclaration { name, value, .. } => {
                if let Some(expr) = value {
                    Ok(format!("Dim {} : {} = {}", name, name, self.generate_expression(expr)?))
                } else {
                    Ok(format!("Dim {}", name))
                }
            }
            Statement::Return { value, .. } => {
                if let Some(expr) = value {
                    Ok(format!("{} = {}", "ReturnValue", self.generate_expression(expr)?))
                } else {
                    Ok("Exit Function".to_string())
                }
            }
            Statement::Expression { expression, .. } => {
                self.generate_expression(expression)
            }
            Statement::If { condition, then_branch, else_branch, .. } => {
                let mut output = format!("If {} Then\n", self.generate_expression(condition)?);
                for stmt in then_branch {
                    output.push_str(&format!("        {}\n", self.generate_statement(stmt)?));
                }
                if let Some(else_stmts) = else_branch {
                    output.push_str("    Else\n");
                    for stmt in else_stmts {
                        output.push_str(&format!("        {}\n", self.generate_statement(stmt)?));
                    }
                }
                output.push_str("    End If");
                Ok(output)
            }
            _ => Ok("' Unsupported statement".to_string()),
        }
    }
    
    fn generate_expression(&self, expression: &Expression) -> Result<String> {
        match expression {
            Expression::Literal { value, .. } => {
                match value {
                    LiteralValue::Number(n) => Ok(n.to_string()),
                    LiteralValue::String(s) => Ok(format!("\"{}\"", s.replace('"', "\"\""))),
                    LiteralValue::Boolean(b) => Ok(if *b { "True" } else { "False" }.to_string()),
                    LiteralValue::Null => Ok("Nothing".to_string()),
                }
            }
            Expression::Identifier { name, .. } => Ok(name.clone()),
            Expression::Binary { left, operator, right, .. } => {
                let left_str = self.generate_expression(left)?;
                let right_str = self.generate_expression(right)?;
                let op_str = match operator {
                    BinaryOperator::Add => "+",
                    BinaryOperator::Subtract => "-",
                    BinaryOperator::Multiply => "*",
                    BinaryOperator::Divide => "/",
                    BinaryOperator::Equal => "=",
                    BinaryOperator::NotEqual => "<>",
                    BinaryOperator::Less => "<",
                    BinaryOperator::Greater => ">",
                    BinaryOperator::LessEqual => "<=",
                    BinaryOperator::GreaterEqual => ">=",
                    BinaryOperator::And => "And",
                    BinaryOperator::Or => "Or",
                    _ => "' unsupported op '",
                };
                Ok(format!("({} {} {})", left_str, op_str, right_str))
            }
            Expression::Call { callee, arguments, .. } => {
                let callee_str = match callee.as_ref() {
                    Expression::Identifier { name, .. } => name.clone(),
                    _ => self.generate_expression(callee)?,
                };
                let args: Result<Vec<String>> = arguments.iter()
                    .map(|arg| self.generate_expression(arg))
                    .collect();
                let args_str = args?.join(", ");
                if args_str.is_empty() {
                    Ok(format!("{}()", callee_str))
                } else {
                    Ok(format!("{}({})", callee_str, args_str))
                }
            }
            Expression::CrossCall { language, function, arguments, .. } => {
                let args: Result<Vec<String>> = arguments.iter()
                    .map(|arg| self.generate_expression(arg))
                    .collect();
                let args_str = args?.join(", ");
                Ok(format!("CrossCall(\"{}\", \"{}\", Array({}))", language, function, args_str))
            }
            Expression::Unary { operator, operand, .. } => {
                let operand_str = self.generate_expression(operand)?;
                let op_str = match operator {
                    UnaryOperator::Minus => "-",
                    UnaryOperator::Plus => "+",
                    UnaryOperator::Not => "Not ",
                };
                Ok(format!("({}{})", op_str, operand_str))
            }
            _ => Ok("' Unsupported expression '".to_string()),
        }
    }
}

/// Bash shell script generator
pub struct BashTransformer;

impl Transformer for BashTransformer {
    fn transform(&self, program: &Program) -> Result<String> {
        let mut output = String::new();
        output.push_str("#!/bin/bash\n");
        output.push_str("# Generated by Utopia Compiler - Bash Backend\n");
        output.push_str("# Multi-language support with runtime integration\n");
        output.push_str("# Shell scripting and system automation\n\n");
        
        output.push_str("set -euo pipefail  # Exit on error, undefined vars, pipe failures\n\n");
        
        // Process language blocks
        for block in &program.language_blocks {
            if block.language == "bash" || block.language == "sh" || block.language == "shell" || block.language == "main" {
                output.push_str(&self.generate_bash_functions(block)?);
            } else {
                output.push_str(&self.generate_cross_language_functions(block)?);
            }
        }
        
        // Main execution if needed
        if !program.global_statements.is_empty() {
            output.push_str("main() {\n");
            for statement in &program.global_statements {
                output.push_str(&format!("    {}\n", self.generate_statement(statement)?));
            }
            output.push_str("}\n\n");
            output.push_str("main \"$@\"\n");
        }
        
        Ok(output)
    }
    
    fn target_name(&self) -> &str {
        "bash"
    }
    
    fn file_extension(&self) -> &str {
        ".sh"
    }
    
    fn supports_language(&self, language: &str) -> bool {
        matches!(language, "bash" | "sh" | "shell")
    }
}

impl BashTransformer {
    fn generate_bash_functions(&self, block: &LanguageBlock) -> Result<String> {
        let mut output = String::new();
        
        for function in &block.functions {
            output.push_str(&self.generate_function(function)?);
            output.push('\n');
        }
        
        Ok(output)
    }
    
    fn generate_cross_language_functions(&self, block: &LanguageBlock) -> Result<String> {
        let mut output = String::new();
        output.push_str(&format!("# Cross-language block: {}\n", block.language));
        
        for function in &block.functions {
            output.push_str(&format!("{}() {{\n", function.name));
            output.push_str(&format!(
                "    echo \"Error: Cross-language call to {}::{} not implemented\" >&2\n",
                block.language, function.name
            ));
            output.push_str("    return 1\n");
            output.push_str("}\n\n");
        }
        
        Ok(output)
    }
    
    fn generate_function(&self, function: &Function) -> Result<String> {
        let mut output = String::new();
        
        // Function definition
        output.push_str(&format!("{}() {{\n", function.name));
        
        // Parameters (bash functions use $1, $2, etc.)
        for (i, param) in function.parameters.iter().enumerate() {
            output.push_str(&format!("    local {}=${}\n", param.name, i + 1));
        }
        
        if !function.parameters.is_empty() {
            output.push('\n');
        }
        
        // Function body
        for statement in &function.body {
            output.push_str(&format!("    {}\n", self.generate_statement(statement)?));
        }
        
        output.push_str("}\n");
        Ok(output)
    }
    
    fn generate_statement(&self, statement: &Statement) -> Result<String> {
        match statement {
            Statement::VariableDeclaration { name, value, .. } => {
                if let Some(expr) = value {
                    Ok(format!("local {}={}", name, self.generate_expression(expr)?))
                } else {
                    Ok(format!("local {}", name))
                }
            }
            Statement::Return { value, .. } => {
                if let Some(expr) = value {
                    Ok(format!("echo {}", self.generate_expression(expr)?))
                } else {
                    Ok("return".to_string())
                }
            }
            Statement::Expression { expression, .. } => {
                self.generate_expression(expression)
            }
            Statement::If { condition, then_branch, else_branch, .. } => {
                let mut output = format!("if [[ {} ]]; then\n", self.generate_expression(condition)?);
                for stmt in then_branch {
                    output.push_str(&format!("        {}\n", self.generate_statement(stmt)?));
                }
                if let Some(else_stmts) = else_branch {
                    output.push_str("    else\n");
                    for stmt in else_stmts {
                        output.push_str(&format!("        {}\n", self.generate_statement(stmt)?));
                    }
                }
                output.push_str("    fi");
                Ok(output)
            }
            _ => Ok("# Unsupported statement".to_string()),
        }
    }
    
    fn generate_expression(&self, expression: &Expression) -> Result<String> {
        match expression {
            Expression::Literal { value, .. } => {
                match value {
                    LiteralValue::Number(n) => Ok(n.to_string()),
                    LiteralValue::String(s) => Ok(format!("\"{}\"", s.replace('"', "\\\""))),
                    LiteralValue::Boolean(b) => Ok(if *b { "true" } else { "false" }.to_string()),
                    LiteralValue::Null => Ok("\"\"".to_string()),
                }
            }
            Expression::Identifier { name, .. } => Ok(format!("${}", name)),
            Expression::Binary { left, operator, right, .. } => {
                let left_str = self.generate_expression(left)?;
                let right_str = self.generate_expression(right)?;
                match operator {
                    BinaryOperator::Add => Ok(format!("$(({} + {}))", left_str.trim_start_matches('$'), right_str.trim_start_matches('$'))),
                    BinaryOperator::Subtract => Ok(format!("$(({} - {}))", left_str.trim_start_matches('$'), right_str.trim_start_matches('$'))),
                    BinaryOperator::Multiply => Ok(format!("$(({} * {}))", left_str.trim_start_matches('$'), right_str.trim_start_matches('$'))),
                    BinaryOperator::Divide => Ok(format!("$(({} / {}))", left_str.trim_start_matches('$'), right_str.trim_start_matches('$'))),
                    BinaryOperator::Equal => Ok(format!("{} == {}", left_str, right_str)),
                    BinaryOperator::NotEqual => Ok(format!("{} != {}", left_str, right_str)),
                    BinaryOperator::Less => Ok(format!("{} -lt {}", left_str, right_str)),
                    BinaryOperator::Greater => Ok(format!("{} -gt {}", left_str, right_str)),
                    BinaryOperator::LessEqual => Ok(format!("{} -le {}", left_str, right_str)),
                    BinaryOperator::GreaterEqual => Ok(format!("{} -ge {}", left_str, right_str)),
                    BinaryOperator::And => Ok(format!("{} && {}", left_str, right_str)),
                    BinaryOperator::Or => Ok(format!("{} || {}", left_str, right_str)),
                    _ => Ok("# unsupported op #".to_string()),
                }
            }
            Expression::Call { callee, arguments, .. } => {
                let callee_str = match callee.as_ref() {
                    Expression::Identifier { name, .. } => name.clone(),
                    _ => self.generate_expression(callee)?,
                };
                let args: Result<Vec<String>> = arguments.iter()
                    .map(|arg| self.generate_expression(arg))
                    .collect();
                let args_str = args?.join(" ");
                if args_str.is_empty() {
                    Ok(format!("$({})", callee_str))
                } else {
                    Ok(format!("$({} {})", callee_str, args_str))
                }
            }
            Expression::CrossCall { language, function, arguments, .. } => {
                let args: Result<Vec<String>> = arguments.iter()
                    .map(|arg| self.generate_expression(arg))
                    .collect();
                let args_str = args?.join(" ");
                Ok(format!("$(cross_call \"{}\" \"{}\" {})", language, function, args_str))
            }
            Expression::Unary { operator, operand, .. } => {
                let operand_str = self.generate_expression(operand)?;
                match operator {
                    UnaryOperator::Minus => Ok(format!("$((-{}))", operand_str.trim_start_matches('$'))),
                    UnaryOperator::Plus => Ok(format!("$((+{}))", operand_str.trim_start_matches('$'))),
                    UnaryOperator::Not => Ok(format!("! {}", operand_str)),
                }
            }
            _ => Ok("# Unsupported expression #".to_string()),
        }
    }
}

/// Nim code generator
pub struct NimTransformer;

impl Transformer for NimTransformer {
    fn transform(&self, program: &Program) -> Result<String> {
        let mut output = String::new();
        output.push_str("# Generated by Utopia Compiler - Nim Backend\n");
        output.push_str("# Multi-language support with runtime integration\n");
        output.push_str("# Efficient compiled language with Python-like syntax\n\n");
        
        // Nim imports
        output.push_str("import json, strutils, sequtils, tables, math\n");
        output.push_str("import asyncdispatch, httpclient\n\n");
        
        // Process language blocks
        for block in &program.language_blocks {
            if block.language == "nim" || block.language == "main" {
                output.push_str(&self.generate_nim_functions(block)?);
            } else {
                output.push_str(&self.generate_cross_language_functions(block)?);
            }
        }
        
        // Main execution if needed
        if !program.global_statements.is_empty() {
            output.push_str("when isMainModule:\n");
            for statement in &program.global_statements {
                output.push_str(&format!("  {}\n", self.generate_statement(statement)?));
            }
        }
        
        Ok(output)
    }
    
    fn target_name(&self) -> &str {
        "nim"
    }
    
    fn file_extension(&self) -> &str {
        ".nim"
    }
    
    fn supports_language(&self, language: &str) -> bool {
        language == "nim"
    }
}

impl NimTransformer {
    fn generate_nim_functions(&self, block: &LanguageBlock) -> Result<String> {
        let mut output = String::new();
        
        for function in &block.functions {
            output.push_str(&self.generate_function(function)?);
            output.push('\n');
        }
        
        Ok(output)
    }
    
    fn generate_cross_language_functions(&self, block: &LanguageBlock) -> Result<String> {
        let mut output = String::new();
        output.push_str(&format!("# Cross-language block: {}\n", block.language));
        
        for function in &block.functions {
            output.push_str(&format!("proc {}*(args: varargs[string]): string =\n", function.name));
            output.push_str(&format!(
                "  raise newException(ValueError, \"Cross-language call to {}::{} not implemented\")\n\n",
                block.language, function.name
            ));
        }
        
        Ok(output)
    }
    
    fn generate_function(&self, function: &Function) -> Result<String> {
        let mut output = String::new();
        
        // Function definition
        output.push_str(&format!("proc {}*(", function.name));
        
        // Parameters
        for (i, param) in function.parameters.iter().enumerate() {
            if i > 0 {
                output.push_str(", ");
            }
            output.push_str(&format!("{}: string", param.name));
        }
        
        output.push_str("): string =\n");
        
        // Function body
        for statement in &function.body {
            output.push_str(&format!("  {}\n", self.generate_statement(statement)?));
        }
        
        Ok(output)
    }
    
    fn generate_statement(&self, statement: &Statement) -> Result<String> {
        match statement {
            Statement::VariableDeclaration { name, value, .. } => {
                if let Some(expr) = value {
                    Ok(format!("let {} = {}", name, self.generate_expression(expr)?))
                } else {
                    Ok(format!("var {}: string", name))
                }
            }
            Statement::Return { value, .. } => {
                if let Some(expr) = value {
                    Ok(format!("return {}", self.generate_expression(expr)?))
                } else {
                    Ok("return \"\"".to_string())
                }
            }
            Statement::Expression { expression, .. } => {
                self.generate_expression(expression)
            }
            Statement::If { condition, then_branch, else_branch, .. } => {
                let mut output = format!("if {}:\n", self.generate_expression(condition)?);
                for stmt in then_branch {
                    output.push_str(&format!("    {}\n", self.generate_statement(stmt)?));
                }
                if let Some(else_stmts) = else_branch {
                    output.push_str("  else:\n");
                    for stmt in else_stmts {
                        output.push_str(&format!("    {}\n", self.generate_statement(stmt)?));
                    }
                }
                Ok(output.trim_end().to_string())
            }
            _ => Ok("# Unsupported statement".to_string()),
        }
    }
    
    fn generate_expression(&self, expression: &Expression) -> Result<String> {
        match expression {
            Expression::Literal { value, .. } => {
                match value {
                    LiteralValue::Number(n) => Ok(format!("\"{}\"", n)), // Convert to string for simplicity
                    LiteralValue::String(s) => Ok(format!("\"{}\"", s.replace('"', "\\\""))),
                    LiteralValue::Boolean(b) => Ok(if *b { "\"true\"" } else { "\"false\"" }.to_string()),
                    LiteralValue::Null => Ok("\"\"".to_string()),
                }
            }
            Expression::Identifier { name, .. } => Ok(name.clone()),
            Expression::Binary { left, operator, right, .. } => {
                let left_str = self.generate_expression(left)?;
                let right_str = self.generate_expression(right)?;
                let op_str = match operator {
                    BinaryOperator::Add => "&", // String concatenation in Nim
                    BinaryOperator::Subtract => "-",
                    BinaryOperator::Multiply => "*",
                    BinaryOperator::Divide => "/",
                    BinaryOperator::Equal => "==",
                    BinaryOperator::NotEqual => "!=",
                    BinaryOperator::Less => "<",
                    BinaryOperator::Greater => ">",
                    BinaryOperator::LessEqual => "<=",
                    BinaryOperator::GreaterEqual => ">=",
                    BinaryOperator::And => "and",
                    BinaryOperator::Or => "or",
                    _ => "# unsupported op #",
                };
                Ok(format!("({} {} {})", left_str, op_str, right_str))
            }
            Expression::Call { callee, arguments, .. } => {
                let callee_str = match callee.as_ref() {
                    Expression::Identifier { name, .. } => name.clone(),
                    _ => self.generate_expression(callee)?,
                };
                let args: Result<Vec<String>> = arguments.iter()
                    .map(|arg| self.generate_expression(arg))
                    .collect();
                let args_str = args?.join(", ");
                Ok(format!("{}({})", callee_str, args_str))
            }
            Expression::CrossCall { language, function, arguments, .. } => {
                let args: Result<Vec<String>> = arguments.iter()
                    .map(|arg| self.generate_expression(arg))
                    .collect();
                let args_str = args?.join(", ");
                Ok(format!("crossCall(\"{}\", \"{}\", @[{}])", language, function, args_str))
            }
            Expression::Unary { operator, operand, .. } => {
                let operand_str = self.generate_expression(operand)?;
                let op_str = match operator {
                    UnaryOperator::Minus => "-",
                    UnaryOperator::Plus => "+",
                    UnaryOperator::Not => "not ",
                };
                Ok(format!("({}{})", op_str, operand_str))
            }
            _ => Ok("# Unsupported expression #".to_string()),
        }
    }
}

/// Crystal code generator
pub struct CrystalTransformer;

impl Transformer for CrystalTransformer {
    fn transform(&self, program: &Program) -> Result<String> {
        let mut output = String::new();
        output.push_str("# Generated by Utopia Compiler - Crystal Backend\n");
        output.push_str("# Multi-language support with runtime integration\n");
        output.push_str("# Ruby-like syntax with C-like performance\n\n");
        
        // Crystal requires
        output.push_str("require \"json\"\n");
        output.push_str("require \"http/client\"\n");
        output.push_str("require \"fiber\"\n\n");
        
        // Process language blocks
        for block in &program.language_blocks {
            if block.language == "crystal" || block.language == "cr" || block.language == "main" {
                output.push_str(&self.generate_crystal_functions(block)?);
            } else {
                output.push_str(&self.generate_cross_language_functions(block)?);
            }
        }
        
        // Main execution if needed
        if !program.global_statements.is_empty() {
            for statement in &program.global_statements {
                output.push_str(&format!("{}\n", self.generate_statement(statement)?));
            }
        }
        
        Ok(output)
    }
    
    fn target_name(&self) -> &str {
        "crystal"
    }
    
    fn file_extension(&self) -> &str {
        ".cr"
    }
    
    fn supports_language(&self, language: &str) -> bool {
        matches!(language, "crystal" | "cr")
    }
}

impl CrystalTransformer {
    fn generate_crystal_functions(&self, block: &LanguageBlock) -> Result<String> {
        let mut output = String::new();
        
        for function in &block.functions {
            output.push_str(&self.generate_function(function)?);
            output.push('\n');
        }
        
        Ok(output)
    }
    
    fn generate_cross_language_functions(&self, block: &LanguageBlock) -> Result<String> {
        let mut output = String::new();
        output.push_str(&format!("# Cross-language block: {}\n", block.language));
        
        for function in &block.functions {
            output.push_str(&format!("def {}(*args)\n", function.name));
            output.push_str(&format!(
                "  raise \"Cross-language call to {}::{} not implemented\"\n",
                block.language, function.name
            ));
            output.push_str("end\n\n");
        }
        
        Ok(output)
    }
    
    fn generate_function(&self, function: &Function) -> Result<String> {
        let mut output = String::new();
        
        // Function definition
        output.push_str(&format!("def {}(", function.name));
        
        // Parameters
        for (i, param) in function.parameters.iter().enumerate() {
            if i > 0 {
                output.push_str(", ");
            }
            output.push_str(&format!("{} : String", param.name));
        }
        
        output.push_str(") : String\n");
        
        // Function body
        for statement in &function.body {
            output.push_str(&format!("  {}\n", self.generate_statement(statement)?));
        }
        
        output.push_str("end\n");
        Ok(output)
    }
    
    fn generate_statement(&self, statement: &Statement) -> Result<String> {
        match statement {
            Statement::VariableDeclaration { name, value, .. } => {
                if let Some(expr) = value {
                    Ok(format!("{} = {}", name, self.generate_expression(expr)?))
                } else {
                    Ok(format!("{} = \"\"", name))
                }
            }
            Statement::Return { value, .. } => {
                if let Some(expr) = value {
                    Ok(format!("return {}", self.generate_expression(expr)?))
                } else {
                    Ok("return \"\"".to_string())
                }
            }
            Statement::Expression { expression, .. } => {
                self.generate_expression(expression)
            }
            Statement::If { condition, then_branch, else_branch, .. } => {
                let mut output = format!("if {}\n", self.generate_expression(condition)?);
                for stmt in then_branch {
                    output.push_str(&format!("    {}\n", self.generate_statement(stmt)?));
                }
                if let Some(else_stmts) = else_branch {
                    output.push_str("  else\n");
                    for stmt in else_stmts {
                        output.push_str(&format!("    {}\n", self.generate_statement(stmt)?));
                    }
                }
                output.push_str("  end");
                Ok(output)
            }
            _ => Ok("# Unsupported statement".to_string()),
        }
    }
    
    fn generate_expression(&self, expression: &Expression) -> Result<String> {
        match expression {
            Expression::Literal { value, .. } => {
                match value {
                    LiteralValue::Number(n) => Ok(format!("\"{}\"", n)), // Convert to string
                    LiteralValue::String(s) => Ok(format!("\"{}\"", s.replace('"', "\\\""))),
                    LiteralValue::Boolean(b) => Ok(if *b { "\"true\"" } else { "\"false\"" }.to_string()),
                    LiteralValue::Null => Ok("\"\"".to_string()),
                }
            }
            Expression::Identifier { name, .. } => Ok(name.clone()),
            Expression::Binary { left, operator, right, .. } => {
                let left_str = self.generate_expression(left)?;
                let right_str = self.generate_expression(right)?;
                let op_str = match operator {
                    BinaryOperator::Add => "+", // String concatenation
                    BinaryOperator::Subtract => "-",
                    BinaryOperator::Multiply => "*",
                    BinaryOperator::Divide => "/",
                    BinaryOperator::Equal => "==",
                    BinaryOperator::NotEqual => "!=",
                    BinaryOperator::Less => "<",
                    BinaryOperator::Greater => ">",
                    BinaryOperator::LessEqual => "<=",
                    BinaryOperator::GreaterEqual => ">=",
                    BinaryOperator::And => "&&",
                    BinaryOperator::Or => "||",
                    _ => "# unsupported op #",
                };
                Ok(format!("({} {} {})", left_str, op_str, right_str))
            }
            Expression::Call { callee, arguments, .. } => {
                let callee_str = match callee.as_ref() {
                    Expression::Identifier { name, .. } => name.clone(),
                    _ => self.generate_expression(callee)?,
                };
                let args: Result<Vec<String>> = arguments.iter()
                    .map(|arg| self.generate_expression(arg))
                    .collect();
                let args_str = args?.join(", ");
                Ok(format!("{}({})", callee_str, args_str))
            }
            Expression::CrossCall { language, function, arguments, .. } => {
                let args: Result<Vec<String>> = arguments.iter()
                    .map(|arg| self.generate_expression(arg))
                    .collect();
                let args_str = args?.join(", ");
                Ok(format!("cross_call(\"{}\", \"{}\", [{}])", language, function, args_str))
            }
            Expression::Unary { operator, operand, .. } => {
                let operand_str = self.generate_expression(operand)?;
                let op_str = match operator {
                    UnaryOperator::Minus => "-",
                    UnaryOperator::Plus => "+",
                    UnaryOperator::Not => "!",
                };
                Ok(format!("({}{})", op_str, operand_str))
            }
            _ => Ok("# Unsupported expression #".to_string()),
        }
    }
}

/// Zig code generator
pub struct ZigTransformer;

impl Transformer for ZigTransformer {
    fn transform(&self, program: &Program) -> Result<String> {
        let mut output = String::new();
        output.push_str("// Generated by Utopia Compiler - Zig Backend\n");
        output.push_str("// Multi-language support with runtime integration\n");
        output.push_str("// Systems programming with safety and performance\n\n");
        
        // Zig imports
        output.push_str("const std = @import(\"std\");\n");
        output.push_str("const print = std.debug.print;\n");
        output.push_str("const allocator = std.heap.page_allocator;\n\n");
        
        // Process language blocks
        for block in &program.language_blocks {
            if block.language == "zig" || block.language == "main" {
                output.push_str(&self.generate_zig_functions(block)?);
            } else {
                output.push_str(&self.generate_cross_language_functions(block)?);
            }
        }
        
        // Main function if needed
        if !program.global_statements.is_empty() {
            output.push_str("pub fn main() !void {\n");
            for statement in &program.global_statements {
                output.push_str(&format!("    {};\n", self.generate_statement(statement)?));
            }
            output.push_str("}\n");
        }
        
        Ok(output)
    }
    
    fn target_name(&self) -> &str {
        "zig"
    }
    
    fn file_extension(&self) -> &str {
        ".zig"
    }
    
    fn supports_language(&self, language: &str) -> bool {
        language == "zig"
    }
}

impl ZigTransformer {
    fn generate_zig_functions(&self, block: &LanguageBlock) -> Result<String> {
        let mut output = String::new();
        
        for function in &block.functions {
            output.push_str(&self.generate_function(function)?);
            output.push('\n');
        }
        
        Ok(output)
    }
    
    fn generate_cross_language_functions(&self, block: &LanguageBlock) -> Result<String> {
        let mut output = String::new();
        output.push_str(&format!("// Cross-language block: {}\n", block.language));
        
        for function in &block.functions {
            output.push_str(&format!("fn {}(args: anytype) []const u8 {{\n", function.name));
            output.push_str(&format!(
                "    _ = args; // Suppress unused variable warning\n"
            ));
            output.push_str(&format!(
                "    return \"Cross-language call to {}::{} not implemented\";\n",
                block.language, function.name
            ));
            output.push_str("}\n\n");
        }
        
        Ok(output)
    }
    
    fn generate_function(&self, function: &Function) -> Result<String> {
        let mut output = String::new();
        
        // Function definition
        output.push_str(&format!("fn {}(", function.name));
        
        // Parameters
        for (i, param) in function.parameters.iter().enumerate() {
            if i > 0 {
                output.push_str(", ");
            }
            output.push_str(&format!("{}: []const u8", param.name));
        }
        
        output.push_str(") []const u8 {\n");
        
        // Function body
        for statement in &function.body {
            output.push_str(&format!("    {};\n", self.generate_statement(statement)?));
        }
        
        output.push_str("}\n");
        Ok(output)
    }
    
    fn generate_statement(&self, statement: &Statement) -> Result<String> {
        match statement {
            Statement::VariableDeclaration { name, value, .. } => {
                if let Some(expr) = value {
                    Ok(format!("const {} = {}", name, self.generate_expression(expr)?))
                } else {
                    Ok(format!("var {}: []const u8 = \"\"", name))
                }
            }
            Statement::Return { value, .. } => {
                if let Some(expr) = value {
                    Ok(format!("return {}", self.generate_expression(expr)?))
                } else {
                    Ok("return \"\"".to_string())
                }
            }
            Statement::Expression { expression, .. } => {
                self.generate_expression(expression)
            }
            Statement::If { condition, then_branch, else_branch, .. } => {
                let mut output = format!("if ({}) {{\n", self.generate_expression(condition)?);
                for stmt in then_branch {
                    output.push_str(&format!("        {};\n", self.generate_statement(stmt)?));
                }
                output.push_str("    }");
                if let Some(else_stmts) = else_branch {
                    output.push_str(" else {\n");
                    for stmt in else_stmts {
                        output.push_str(&format!("        {};\n", self.generate_statement(stmt)?));
                    }
                    output.push_str("    }");
                }
                Ok(output)
            }
            _ => Ok("// Unsupported statement".to_string()),
        }
    }
    
    fn generate_expression(&self, expression: &Expression) -> Result<String> {
        match expression {
            Expression::Literal { value, .. } => {
                match value {
                    LiteralValue::Number(n) => Ok(format!("\"{}\"", n)), // Convert to string
                    LiteralValue::String(s) => Ok(format!("\"{}\"", s.replace('"', "\\\""))),
                    LiteralValue::Boolean(b) => Ok(if *b { "\"true\"" } else { "\"false\"" }.to_string()),
                    LiteralValue::Null => Ok("\"\"".to_string()),
                }
            }
            Expression::Identifier { name, .. } => Ok(name.clone()),
            Expression::Binary { left, operator, right, .. } => {
                let left_str = self.generate_expression(left)?;
                let right_str = self.generate_expression(right)?;
                match operator {
                    BinaryOperator::Add => Ok(format!("std.fmt.allocPrint(allocator, \"{{}}{{}}\", .{{ {}, {} }}) catch \"\"", left_str, right_str)),
                    BinaryOperator::Equal => Ok(format!("std.mem.eql(u8, {}, {})", left_str, right_str)),
                    BinaryOperator::NotEqual => Ok(format!("!std.mem.eql(u8, {}, {})", left_str, right_str)),
                    BinaryOperator::And => Ok(format!("({} and {})", left_str, right_str)),
                    BinaryOperator::Or => Ok(format!("({} or {})", left_str, right_str)),
                    _ => Ok(format!("// Unsupported operator: {} {} {}", left_str, "op", right_str)),
                }
            }
            Expression::Call { callee, arguments, .. } => {
                let callee_str = match callee.as_ref() {
                    Expression::Identifier { name, .. } => name.clone(),
                    _ => self.generate_expression(callee)?,
                };
                let args: Result<Vec<String>> = arguments.iter()
                    .map(|arg| self.generate_expression(arg))
                    .collect();
                let args_str = args?.join(", ");
                Ok(format!("{}({})", callee_str, args_str))
            }
            Expression::CrossCall { language, function, arguments, .. } => {
                let args: Result<Vec<String>> = arguments.iter()
                    .map(|arg| self.generate_expression(arg))
                    .collect();
                let args_str = args?.join(", ");
                Ok(format!("crossCall(\"{}\", \"{}\", .{{ {} }})", language, function, args_str))
            }
            Expression::Unary { operator, operand, .. } => {
                let operand_str = self.generate_expression(operand)?;
                match operator {
                    UnaryOperator::Not => Ok(format!("!{}", operand_str)),
                    _ => Ok(format!("// Unsupported unary: {}{}", "op", operand_str)),
                }
            }
            _ => Ok("\"// Unsupported expression\"".to_string()),
        }
    }
}

/// Elixir code generator
pub struct ElixirTransformer;

impl Transformer for ElixirTransformer {
    fn transform(&self, program: &Program) -> Result<String> {
        let mut output = String::new();
        output.push_str("# Generated by Utopia Compiler - Elixir Backend\n");
        output.push_str("# Multi-language support with runtime integration\n");
        output.push_str("# Actor model concurrency and fault tolerance\n\n");
        
        output.push_str("defmodule UtopiaGenerated do\n");
        output.push_str("  use GenServer\n");
        output.push_str("  require Logger\n\n");
        
        // Process language blocks
        for block in &program.language_blocks {
            if block.language == "elixir" || block.language == "ex" || block.language == "main" {
                output.push_str(&self.generate_elixir_functions(block)?);
            } else {
                output.push_str(&self.generate_cross_language_functions(block)?);
            }
        }
        
        // Main execution if needed
        if !program.global_statements.is_empty() {
            output.push_str("  def main do\n");
            for statement in &program.global_statements {
                output.push_str(&format!("    {}\n", self.generate_statement(statement)?));
            }
            output.push_str("  end\n");
        }
        
        output.push_str("end\n");
        
        Ok(output)
    }
    
    fn target_name(&self) -> &str {
        "elixir"
    }
    
    fn file_extension(&self) -> &str {
        ".ex"
    }
    
    fn supports_language(&self, language: &str) -> bool {
        matches!(language, "elixir" | "ex")
    }
}

impl ElixirTransformer {
    fn generate_elixir_functions(&self, block: &LanguageBlock) -> Result<String> {
        let mut output = String::new();
        
        for function in &block.functions {
            output.push_str(&self.generate_function(function)?);
            output.push('\n');
        }
        
        Ok(output)
    }
    
    fn generate_cross_language_functions(&self, block: &LanguageBlock) -> Result<String> {
        let mut output = String::new();
        output.push_str(&format!("  # Cross-language block: {}\n", block.language));
        
        for function in &block.functions {
            output.push_str(&format!("  def {}(args \\\\ []) do\n", function.name));
            output.push_str(&format!(
                "    raise \"Cross-language call to {}::{} not implemented\"\n",
                block.language, function.name
            ));
            output.push_str("  end\n\n");
        }
        
        Ok(output)
    }
    
    fn generate_function(&self, function: &Function) -> Result<String> {
        let mut output = String::new();
        
        // Function definition
        output.push_str(&format!("  def {}(", function.name));
        
        // Parameters
        for (i, param) in function.parameters.iter().enumerate() {
            if i > 0 {
                output.push_str(", ");
            }
            output.push_str(&param.name);
        }
        
        output.push_str(") do\n");
        
        // Function body
        for statement in &function.body {
            output.push_str(&format!("    {}\n", self.generate_statement(statement)?));
        }
        
        output.push_str("  end\n");
        Ok(output)
    }
    
    fn generate_statement(&self, statement: &Statement) -> Result<String> {
        match statement {
            Statement::VariableDeclaration { name, value, .. } => {
                if let Some(expr) = value {
                    Ok(format!("{} = {}", name, self.generate_expression(expr)?))
                } else {
                    Ok(format!("{} = nil", name))
                }
            }
            Statement::Return { value, .. } => {
                if let Some(expr) = value {
                    self.generate_expression(expr)
                } else {
                    Ok("nil".to_string())
                }
            }
            Statement::Expression { expression, .. } => {
                self.generate_expression(expression)
            }
            Statement::If { condition, then_branch, else_branch, .. } => {
                let mut output = format!("if {} do\n", self.generate_expression(condition)?);
                for stmt in then_branch {
                    output.push_str(&format!("      {}\n", self.generate_statement(stmt)?));
                }
                if let Some(else_stmts) = else_branch {
                    output.push_str("    else\n");
                    for stmt in else_stmts {
                        output.push_str(&format!("      {}\n", self.generate_statement(stmt)?));
                    }
                }
                output.push_str("    end");
                Ok(output)
            }
            _ => Ok("# Unsupported statement".to_string()),
        }
    }
    
    fn generate_expression(&self, expression: &Expression) -> Result<String> {
        match expression {
            Expression::Literal { value, .. } => {
                match value {
                    LiteralValue::Number(n) => Ok(n.to_string()),
                    LiteralValue::String(s) => Ok(format!("\"{}\"", s.replace('"', "\\\""))),
                    LiteralValue::Boolean(b) => Ok(b.to_string()),
                    LiteralValue::Null => Ok("nil".to_string()),
                }
            }
            Expression::Identifier { name, .. } => Ok(name.clone()),
            Expression::Binary { left, operator, right, .. } => {
                let left_str = self.generate_expression(left)?;
                let right_str = self.generate_expression(right)?;
                let op_str = match operator {
                    BinaryOperator::Add => "<>", // String concatenation in Elixir
                    BinaryOperator::Subtract => "-",
                    BinaryOperator::Multiply => "*",
                    BinaryOperator::Divide => "/",
                    BinaryOperator::Equal => "==",
                    BinaryOperator::NotEqual => "!=",
                    BinaryOperator::Less => "<",
                    BinaryOperator::Greater => ">",
                    BinaryOperator::LessEqual => "<=",
                    BinaryOperator::GreaterEqual => ">=",
                    BinaryOperator::And => "and",
                    BinaryOperator::Or => "or",
                    _ => "# unsupported op #",
                };
                Ok(format!("({} {} {})", left_str, op_str, right_str))
            }
            Expression::Call { callee, arguments, .. } => {
                let callee_str = match callee.as_ref() {
                    Expression::Identifier { name, .. } => name.clone(),
                    _ => self.generate_expression(callee)?,
                };
                let args: Result<Vec<String>> = arguments.iter()
                    .map(|arg| self.generate_expression(arg))
                    .collect();
                let args_str = args?.join(", ");
                Ok(format!("{}({})", callee_str, args_str))
            }
            Expression::CrossCall { language, function, arguments, .. } => {
                let args: Result<Vec<String>> = arguments.iter()
                    .map(|arg| self.generate_expression(arg))
                    .collect();
                let args_str = args?.join(", ");
                Ok(format!("cross_call(\"{}\", \"{}\", [{}])", language, function, args_str))
            }
            Expression::Unary { operator, operand, .. } => {
                let operand_str = self.generate_expression(operand)?;
                let op_str = match operator {
                    UnaryOperator::Minus => "-",
                    UnaryOperator::Plus => "+",
                    UnaryOperator::Not => "not ",
                };
                Ok(format!("({}{})", op_str, operand_str))
            }
            _ => Ok("# Unsupported expression #".to_string()),
        }
    }
}

/// F# code generator
pub struct FSharpTransformer;

impl Transformer for FSharpTransformer {
    fn transform(&self, program: &Program) -> Result<String> {
        let mut output = String::new();
        output.push_str("// Generated by Utopia Compiler - F# Backend\n");
        output.push_str("// Multi-language support with runtime integration\n");
        output.push_str("// Functional-first .NET programming\n\n");
        
        output.push_str("module UtopiaGenerated\n\n");
        output.push_str("open System\n");
        output.push_str("open System.Collections.Generic\n\n");
        
        // Process language blocks
        for block in &program.language_blocks {
            if block.language == "fsharp" || block.language == "fs" || block.language == "f#" || block.language == "main" {
                output.push_str(&self.generate_fsharp_functions(block)?);
            } else {
                output.push_str(&self.generate_cross_language_functions(block)?);
            }
        }
        
        // Main execution if needed
        if !program.global_statements.is_empty() {
            output.push_str("[<EntryPoint>]\n");
            output.push_str("let main argv =\n");
            for statement in &program.global_statements {
                output.push_str(&format!("    {} |> ignore\n", self.generate_statement(statement)?));
            }
            output.push_str("    0\n");
        }
        
        Ok(output)
    }
    
    fn target_name(&self) -> &str {
        "fsharp"
    }
    
    fn file_extension(&self) -> &str {
        ".fs"
    }
    
    fn supports_language(&self, language: &str) -> bool {
        matches!(language, "fsharp" | "fs" | "f#")
    }
}

impl FSharpTransformer {
    fn generate_fsharp_functions(&self, block: &LanguageBlock) -> Result<String> {
        let mut output = String::new();
        
        for function in &block.functions {
            output.push_str(&self.generate_function(function)?);
            output.push('\n');
        }
        
        Ok(output)
    }
    
    fn generate_cross_language_functions(&self, block: &LanguageBlock) -> Result<String> {
        let mut output = String::new();
        output.push_str(&format!("// Cross-language block: {}\n", block.language));
        
        for function in &block.functions {
            output.push_str(&format!("let {} args =\n", function.name));
            output.push_str(&format!(
                "    failwith \"Cross-language call to {}::{} not implemented\"\n\n",
                block.language, function.name
            ));
        }
        
        Ok(output)
    }
    
    fn generate_function(&self, function: &Function) -> Result<String> {
        let mut output = String::new();
        
        // Function definition
        output.push_str(&format!("let {} ", function.name));
        
        // Parameters
        for param in &function.parameters {
            output.push_str(&format!("{} ", param.name));
        }
        
        output.push_str("=\n");
        
        // Function body (simplified for F# functional style)
        if let Some(first_stmt) = function.body.first() {
            if let Statement::Return { value: Some(expr), .. } = first_stmt {
                output.push_str(&format!("    {}\n", self.generate_expression(expr)?));
            } else {
                output.push_str("    \"function result\"\n");
            }
        } else {
            output.push_str("    \"empty function\"\n");
        }
        
        Ok(output)
    }
    
    fn generate_statement(&self, statement: &Statement) -> Result<String> {
        match statement {
            Statement::VariableDeclaration { name, value, .. } => {
                if let Some(expr) = value {
                    Ok(format!("let {} = {}", name, self.generate_expression(expr)?))
                } else {
                    Ok(format!("let {} = \"\"", name))
                }
            }
            Statement::Return { value, .. } => {
                if let Some(expr) = value {
                    self.generate_expression(expr)
                } else {
                    Ok("\"\"".to_string())
                }
            }
            Statement::Expression { expression, .. } => {
                self.generate_expression(expression)
            }
            _ => Ok("// Unsupported statement".to_string()),
        }
    }
    
    fn generate_expression(&self, expression: &Expression) -> Result<String> {
        match expression {
            Expression::Literal { value, .. } => {
                match value {
                    LiteralValue::Number(n) => Ok(n.to_string()),
                    LiteralValue::String(s) => Ok(format!("\"{}\"", s.replace('"', "\\\""))),
                    LiteralValue::Boolean(b) => Ok(b.to_string()),
                    LiteralValue::Null => Ok("None".to_string()),
                }
            }
            Expression::Identifier { name, .. } => Ok(name.clone()),
            Expression::Binary { left, operator, right, .. } => {
                let left_str = self.generate_expression(left)?;
                let right_str = self.generate_expression(right)?;
                let op_str = match operator {
                    BinaryOperator::Add => "+", // String concatenation
                    BinaryOperator::Subtract => "-",
                    BinaryOperator::Multiply => "*",
                    BinaryOperator::Divide => "/",
                    BinaryOperator::Equal => "=",
                    BinaryOperator::NotEqual => "<>",
                    BinaryOperator::Less => "<",
                    BinaryOperator::Greater => ">",
                    BinaryOperator::LessEqual => "<=",
                    BinaryOperator::GreaterEqual => ">=",
                    BinaryOperator::And => "&&",
                    BinaryOperator::Or => "||",
                    _ => "// unsupported op //",
                };
                Ok(format!("({} {} {})", left_str, op_str, right_str))
            }
            Expression::Call { callee, arguments, .. } => {
                let callee_str = match callee.as_ref() {
                    Expression::Identifier { name, .. } => name.clone(),
                    _ => self.generate_expression(callee)?,
                };
                let args: Result<Vec<String>> = arguments.iter()
                    .map(|arg| self.generate_expression(arg))
                    .collect();
                let args_str = args?.join(" ");
                if args_str.is_empty() {
                    Ok(format!("{} ()", callee_str))
                } else {
                    Ok(format!("{} {}", callee_str, args_str))
                }
            }
            Expression::CrossCall { language, function, arguments, .. } => {
                let args: Result<Vec<String>> = arguments.iter()
                    .map(|arg| self.generate_expression(arg))
                    .collect();
                let args_str = args?.join("; ");
                Ok(format!("crossCall \"{}\" \"{}\" [{}]", language, function, args_str))
            }
            Expression::Unary { operator, operand, .. } => {
                let operand_str = self.generate_expression(operand)?;
                let op_str = match operator {
                    UnaryOperator::Minus => "-",
                    UnaryOperator::Plus => "+",
                    UnaryOperator::Not => "not ",
                };
                Ok(format!("({}{})", op_str, operand_str))
            }
            _ => Ok("// Unsupported expression //".to_string()),
        }
    }
}

/// Clojure code generator
pub struct ClojureTransformer;

impl Transformer for ClojureTransformer {
    fn transform(&self, program: &Program) -> Result<String> {
        let mut output = String::new();
        output.push_str(";; Generated by Utopia Compiler - Clojure Backend\n");
        output.push_str(";; Multi-language support with runtime integration\n");
        output.push_str(";; Lisp dialect on JVM with immutable data structures\n\n");
        
        output.push_str("(ns utopia.generated\n");
        output.push_str("  (:require [clojure.string :as str]\n");
        output.push_str("            [clojure.data.json :as json]))\n\n");
        
        // Process language blocks
        for block in &program.language_blocks {
            if block.language == "clojure" || block.language == "clj" || block.language == "main" {
                output.push_str(&self.generate_clojure_functions(block)?);
            } else {
                output.push_str(&self.generate_cross_language_functions(block)?);
            }
        }
        
        // Main execution if needed
        if !program.global_statements.is_empty() {
            output.push_str("(defn -main [& args]\n");
            for statement in &program.global_statements {
                output.push_str(&format!("  {}\n", self.generate_statement(statement)?));
            }
            output.push_str(")\n");
        }
        
        Ok(output)
    }
    
    fn target_name(&self) -> &str {
        "clojure"
    }
    
    fn file_extension(&self) -> &str {
        ".clj"
    }
    
    fn supports_language(&self, language: &str) -> bool {
        matches!(language, "clojure" | "clj")
    }
}

impl ClojureTransformer {
    fn generate_clojure_functions(&self, block: &LanguageBlock) -> Result<String> {
        let mut output = String::new();
        
        for function in &block.functions {
            output.push_str(&self.generate_function(function)?);
            output.push('\n');
        }
        
        Ok(output)
    }
    
    fn generate_cross_language_functions(&self, block: &LanguageBlock) -> Result<String> {
        let mut output = String::new();
        output.push_str(&format!(";; Cross-language block: {}\n", block.language));
        
        for function in &block.functions {
            output.push_str(&format!("(defn {} [& args]\n", function.name));
            output.push_str(&format!(
                "  (throw (Exception. \"Cross-language call to {}::{} not implemented\")))\n\n",
                block.language, function.name
            ));
        }
        
        Ok(output)
    }
    
    fn generate_function(&self, function: &Function) -> Result<String> {
        let mut output = String::new();
        
        // Function definition
        output.push_str(&format!("(defn {} [", function.name));
        
        // Parameters
        for (i, param) in function.parameters.iter().enumerate() {
            if i > 0 {
                output.push(' ');
            }
            output.push_str(&param.name);
        }
        
        output.push_str("]\n");
        
        // Function body
        for statement in &function.body {
            output.push_str(&format!("  {})\n", self.generate_statement(statement)?));
        }
        
        Ok(output)
    }
    
    fn generate_statement(&self, statement: &Statement) -> Result<String> {
        match statement {
            Statement::VariableDeclaration { name, value, .. } => {
                if let Some(expr) = value {
                    Ok(format!("(def {} {})", name, self.generate_expression(expr)?))
                } else {
                    Ok(format!("(def {} nil)", name))
                }
            }
            Statement::Return { value, .. } => {
                if let Some(expr) = value {
                    self.generate_expression(expr)
                } else {
                    Ok("nil".to_string())
                }
            }
            Statement::Expression { expression, .. } => {
                self.generate_expression(expression)
            }
            _ => Ok(";; Unsupported statement".to_string()),
        }
    }
    
    fn generate_expression(&self, expression: &Expression) -> Result<String> {
        match expression {
            Expression::Literal { value, .. } => {
                match value {
                    LiteralValue::Number(n) => Ok(n.to_string()),
                    LiteralValue::String(s) => Ok(format!("\"{}\"", s.replace('"', "\\\""))),
                    LiteralValue::Boolean(b) => Ok(b.to_string()),
                    LiteralValue::Null => Ok("nil".to_string()),
                }
            }
            Expression::Identifier { name, .. } => Ok(name.clone()),
            Expression::Binary { left, operator, right, .. } => {
                let left_str = self.generate_expression(left)?;
                let right_str = self.generate_expression(right)?;
                let op_str = match operator {
                    BinaryOperator::Add => "str",
                    BinaryOperator::Subtract => "-",
                    BinaryOperator::Multiply => "*",
                    BinaryOperator::Divide => "/",
                    BinaryOperator::Equal => "=",
                    BinaryOperator::NotEqual => "not=",
                    BinaryOperator::Less => "<",
                    BinaryOperator::Greater => ">",
                    BinaryOperator::LessEqual => "<=",
                    BinaryOperator::GreaterEqual => ">=",
                    BinaryOperator::And => "and",
                    BinaryOperator::Or => "or",
                    _ => ";; unsupported op ;;",
                };
                Ok(format!("({} {} {})", op_str, left_str, right_str))
            }
            Expression::Call { callee, arguments, .. } => {
                let callee_str = match callee.as_ref() {
                    Expression::Identifier { name, .. } => name.clone(),
                    _ => self.generate_expression(callee)?,
                };
                let args: Result<Vec<String>> = arguments.iter()
                    .map(|arg| self.generate_expression(arg))
                    .collect();
                let args_str = args?.join(" ");
                Ok(format!("({} {})", callee_str, args_str))
            }
            Expression::CrossCall { language, function, arguments, .. } => {
                let args: Result<Vec<String>> = arguments.iter()
                    .map(|arg| self.generate_expression(arg))
                    .collect();
                let args_str = args?.join(" ");
                Ok(format!("(cross-call \"{}\" \"{}\" [{}])", language, function, args_str))
            }
            Expression::Unary { operator, operand, .. } => {
                let operand_str = self.generate_expression(operand)?;
                let op_str = match operator {
                    UnaryOperator::Minus => "-",
                    UnaryOperator::Plus => "+",
                    UnaryOperator::Not => "not",
                };
                Ok(format!("({} {})", op_str, operand_str))
            }
            _ => Ok(";; Unsupported expression ;;".to_string()),
        }
    }
}

/// Erlang code generator
pub struct ErlangTransformer;

impl Transformer for ErlangTransformer {
    fn transform(&self, program: &Program) -> Result<String> {
        let mut output = String::new();
        output.push_str("% Generated by Utopia Compiler - Erlang Backend\n");
        output.push_str("% Multi-language support with runtime integration\n");
        output.push_str("% Concurrent systems with actor model\n\n");
        
        output.push_str("-module(utopia_generated).\n");
        output.push_str("-export([start/0]).\n\n");
        
        // Process language blocks
        for block in &program.language_blocks {
            if block.language == "erlang" || block.language == "erl" || block.language == "main" {
                output.push_str(&self.generate_erlang_functions(block)?);
            } else {
                output.push_str(&self.generate_cross_language_functions(block)?);
            }
        }
        
        // Main execution if needed
        if !program.global_statements.is_empty() {
            output.push_str("start() ->\n");
            for statement in &program.global_statements {
                output.push_str(&format!("    {},\n", self.generate_statement(statement)?));
            }
            output.push_str("    ok.\n");
        }
        
        Ok(output)
    }
    
    fn target_name(&self) -> &str {
        "erlang"
    }
    
    fn file_extension(&self) -> &str {
        ".erl"
    }
    
    fn supports_language(&self, language: &str) -> bool {
        matches!(language, "erlang" | "erl")
    }
}

impl ErlangTransformer {
    fn generate_erlang_functions(&self, block: &LanguageBlock) -> Result<String> {
        let mut output = String::new();
        
        for function in &block.functions {
            output.push_str(&self.generate_function(function)?);
            output.push('\n');
        }
        
        Ok(output)
    }
    
    fn generate_cross_language_functions(&self, block: &LanguageBlock) -> Result<String> {
        let mut output = String::new();
        output.push_str(&format!("% Cross-language block: {}\n", block.language));
        
        for function in &block.functions {
            output.push_str(&format!("{}(Args) ->\n", function.name));
            output.push_str(&format!(
                "    error({{not_implemented, \"Cross-language call to {}::{} not implemented\"}}).\n\n",
                block.language, function.name
            ));
        }
        
        Ok(output)
    }
    
    fn generate_function(&self, function: &Function) -> Result<String> {
        let mut output = String::new();
        
        // Function definition
        output.push_str(&format!("{}(", function.name));
        
        // Parameters
        for (i, param) in function.parameters.iter().enumerate() {
            if i > 0 {
                output.push_str(", ");
            }
            // Capitalize first letter for Erlang variable convention
            let capitalized = format!("{}{}", param.name.chars().next().unwrap().to_uppercase().collect::<String>(), &param.name[1..]);
            output.push_str(&capitalized);
        }
        
        output.push_str(") ->\n");
        
        // Function body
        for statement in &function.body {
            output.push_str(&format!("    {}.\n", self.generate_statement(statement)?));
        }
        
        Ok(output)
    }
    
    fn generate_statement(&self, statement: &Statement) -> Result<String> {
        match statement {
            Statement::VariableDeclaration { name, value, .. } => {
                if let Some(expr) = value {
                    let capitalized = format!("{}{}", name.chars().next().unwrap().to_uppercase().collect::<String>(), &name[1..]);
                    Ok(format!("{} = {}", capitalized, self.generate_expression(expr)?))
                } else {
                    Ok(format!("{} = undefined", name))
                }
            }
            Statement::Return { value, .. } => {
                if let Some(expr) = value {
                    self.generate_expression(expr)
                } else {
                    Ok("ok".to_string())
                }
            }
            Statement::Expression { expression, .. } => {
                self.generate_expression(expression)
            }
            _ => Ok("% Unsupported statement".to_string()),
        }
    }
    
    fn generate_expression(&self, expression: &Expression) -> Result<String> {
        match expression {
            Expression::Literal { value, .. } => {
                match value {
                    LiteralValue::Number(n) => Ok(n.to_string()),
                    LiteralValue::String(s) => Ok(format!("\"{}\"", s.replace('"', "\\\""))),
                    LiteralValue::Boolean(b) => Ok(b.to_string()),
                    LiteralValue::Null => Ok("undefined".to_string()),
                }
            }
            Expression::Identifier { name, .. } => {
                let capitalized = format!("{}{}", name.chars().next().unwrap().to_uppercase().collect::<String>(), &name[1..]);
                Ok(capitalized)
            }
            Expression::Binary { left, operator, right, .. } => {
                let left_str = self.generate_expression(left)?;
                let right_str = self.generate_expression(right)?;
                match operator {
                    BinaryOperator::Add => Ok(format!("string:concat({}, {})", left_str, right_str)),
                    BinaryOperator::Equal => Ok(format!("{} =:= {}", left_str, right_str)),
                    BinaryOperator::NotEqual => Ok(format!("{} =/= {}", left_str, right_str)),
                    BinaryOperator::And => Ok(format!("{} andalso {}", left_str, right_str)),
                    BinaryOperator::Or => Ok(format!("{} orelse {}", left_str, right_str)),
                    _ => Ok(format!("% Unsupported operator: {} op {}", left_str, right_str)),
                }
            }
            Expression::Call { callee, arguments, .. } => {
                let callee_str = match callee.as_ref() {
                    Expression::Identifier { name, .. } => name.clone(),
                    _ => self.generate_expression(callee)?,
                };
                let args: Result<Vec<String>> = arguments.iter()
                    .map(|arg| self.generate_expression(arg))
                    .collect();
                let args_str = args?.join(", ");
                Ok(format!("{}({})", callee_str, args_str))
            }
            Expression::CrossCall { language, function, arguments, .. } => {
                let args: Result<Vec<String>> = arguments.iter()
                    .map(|arg| self.generate_expression(arg))
                    .collect();
                let args_str = args?.join(", ");
                Ok(format!("cross_call(\"{}\", \"{}\", [{}])", language, function, args_str))
            }
            _ => Ok("% Unsupported expression".to_string()),
        }
    }
}

/// OCaml code generator
pub struct OCamlTransformer;

impl Transformer for OCamlTransformer {
    fn transform(&self, program: &Program) -> Result<String> {
        let mut output = String::new();
        output.push_str("(* Generated by Utopia Compiler - OCaml Backend *)\n");
        output.push_str("(* Multi-language support with runtime integration *)\n");
        output.push_str("(* Functional programming with type inference *)\n\n");
        
        output.push_str("open Printf\n");
        output.push_str("open String\n\n");
        
        // Process language blocks
        for block in &program.language_blocks {
            if block.language == "ocaml" || block.language == "ml" || block.language == "main" {
                output.push_str(&self.generate_ocaml_functions(block)?);
            } else {
                output.push_str(&self.generate_cross_language_functions(block)?);
            }
        }
        
        // Main execution if needed
        if !program.global_statements.is_empty() {
            output.push_str("let () =\n");
            for statement in &program.global_statements {
                output.push_str(&format!("  {} |> ignore;\n", self.generate_statement(statement)?));
            }
        }
        
        Ok(output)
    }
    
    fn target_name(&self) -> &str {
        "ocaml"
    }
    
    fn file_extension(&self) -> &str {
        ".ml"
    }
    
    fn supports_language(&self, language: &str) -> bool {
        matches!(language, "ocaml" | "ml")
    }
}

impl OCamlTransformer {
    fn generate_ocaml_functions(&self, block: &LanguageBlock) -> Result<String> {
        let mut output = String::new();
        
        for function in &block.functions {
            output.push_str(&self.generate_function(function)?);
            output.push('\n');
        }
        
        Ok(output)
    }
    
    fn generate_cross_language_functions(&self, block: &LanguageBlock) -> Result<String> {
        let mut output = String::new();
        output.push_str(&format!("(* Cross-language block: {} *)\n", block.language));
        
        for function in &block.functions {
            output.push_str(&format!("let {} args =\n", function.name));
            output.push_str(&format!(
                "  failwith \"Cross-language call to {}::{} not implemented\"\n\n",
                block.language, function.name
            ));
        }
        
        Ok(output)
    }
    
    fn generate_function(&self, function: &Function) -> Result<String> {
        let mut output = String::new();
        
        // Function definition
        output.push_str(&format!("let {} ", function.name));
        
        // Parameters
        for param in &function.parameters {
            output.push_str(&format!("{} ", param.name));
        }
        
        output.push_str("=\n");
        
        // Function body (simplified)
        if let Some(first_stmt) = function.body.first() {
            if let Statement::Return { value: Some(expr), .. } = first_stmt {
                output.push_str(&format!("  {}\n", self.generate_expression(expr)?));
            } else {
                output.push_str("  \"function result\"\n");
            }
        } else {
            output.push_str("  \"empty function\"\n");
        }
        
        Ok(output)
    }
    
    fn generate_statement(&self, statement: &Statement) -> Result<String> {
        match statement {
            Statement::VariableDeclaration { name, value, .. } => {
                if let Some(expr) = value {
                    Ok(format!("let {} = {}", name, self.generate_expression(expr)?))
                } else {
                    Ok(format!("let {} = \"\"", name))
                }
            }
            Statement::Return { value, .. } => {
                if let Some(expr) = value {
                    self.generate_expression(expr)
                } else {
                    Ok("\"\"".to_string())
                }
            }
            Statement::Expression { expression, .. } => {
                self.generate_expression(expression)
            }
            _ => Ok("(* Unsupported statement *)".to_string()),
        }
    }
    
    fn generate_expression(&self, expression: &Expression) -> Result<String> {
        match expression {
            Expression::Literal { value, .. } => {
                match value {
                    LiteralValue::Number(n) => Ok(n.to_string()),
                    LiteralValue::String(s) => Ok(format!("\"{}\"", s.replace('"', "\\\""))),
                    LiteralValue::Boolean(b) => Ok(b.to_string()),
                    LiteralValue::Null => Ok("None".to_string()),
                }
            }
            Expression::Identifier { name, .. } => Ok(name.clone()),
            Expression::Binary { left, operator, right, .. } => {
                let left_str = self.generate_expression(left)?;
                let right_str = self.generate_expression(right)?;
                let op_str = match operator {
                    BinaryOperator::Add => "^", // String concatenation in OCaml
                    BinaryOperator::Equal => "=",
                    BinaryOperator::NotEqual => "<>",
                    BinaryOperator::And => "&&",
                    BinaryOperator::Or => "||",
                    _ => "(* unsupported op *)",
                };
                Ok(format!("({} {} {})", left_str, op_str, right_str))
            }
            Expression::Call { callee, arguments, .. } => {
                let callee_str = match callee.as_ref() {
                    Expression::Identifier { name, .. } => name.clone(),
                    _ => self.generate_expression(callee)?,
                };
                let args: Result<Vec<String>> = arguments.iter()
                    .map(|arg| self.generate_expression(arg))
                    .collect();
                let args_str = args?.join(" ");
                if args_str.is_empty() {
                    Ok(format!("{} ()", callee_str))
                } else {
                    Ok(format!("{} {}", callee_str, args_str))
                }
            }
            _ => Ok("(* Unsupported expression *)".to_string()),
        }
    }
}

/// Scheme code generator
pub struct SchemeTransformer;

impl Transformer for SchemeTransformer {
    fn transform(&self, program: &Program) -> Result<String> {
        let mut output = String::new();
        output.push_str(";; Generated by Utopia Compiler - Scheme Backend\n");
        output.push_str(";; Multi-language support with runtime integration\n");
        output.push_str(";; Minimalist Lisp dialect\n\n");
        
        // Process language blocks
        for block in &program.language_blocks {
            if block.language == "scheme" || block.language == "scm" || block.language == "main" {
                output.push_str(&self.generate_scheme_functions(block)?);
            } else {
                output.push_str(&self.generate_cross_language_functions(block)?);
            }
        }
        
        // Main execution
        if !program.global_statements.is_empty() {
            for statement in &program.global_statements {
                output.push_str(&format!("{}\n", self.generate_statement(statement)?));
            }
        }
        
        Ok(output)
    }
    
    fn target_name(&self) -> &str {
        "scheme"
    }
    
    fn file_extension(&self) -> &str {
        ".scm"
    }
    
    fn supports_language(&self, language: &str) -> bool {
        matches!(language, "scheme" | "scm")
    }
}

impl SchemeTransformer {
    fn generate_scheme_functions(&self, block: &LanguageBlock) -> Result<String> {
        let mut output = String::new();
        
        for function in &block.functions {
            output.push_str(&self.generate_function(function)?);
            output.push('\n');
        }
        
        Ok(output)
    }
    
    fn generate_cross_language_functions(&self, block: &LanguageBlock) -> Result<String> {
        let mut output = String::new();
        output.push_str(&format!(";; Cross-language block: {}\n", block.language));
        
        for function in &block.functions {
            output.push_str(&format!("(define ({} . args)\n", function.name));
            output.push_str(&format!(
                "  (error \"Cross-language call to {}::{} not implemented\"))\n\n",
                block.language, function.name
            ));
        }
        
        Ok(output)
    }
    
    fn generate_function(&self, function: &Function) -> Result<String> {
        let mut output = String::new();
        
        // Function definition
        output.push_str(&format!("(define ({}", function.name));
        
        // Parameters
        for param in &function.parameters {
            output.push_str(&format!(" {}", param.name));
        }
        
        output.push_str(")\n");
        
        // Function body (simplified for Scheme)
        if let Some(first_stmt) = function.body.first() {
            if let Statement::Return { value: Some(expr), .. } = first_stmt {
                output.push_str(&format!("  {})\n", self.generate_expression(expr)?));
            } else {
                output.push_str("  \"function result\")\n");
            }
        } else {
            output.push_str("  \"empty function\")\n");
        }
        
        Ok(output)
    }
    
    fn generate_statement(&self, statement: &Statement) -> Result<String> {
        match statement {
            Statement::VariableDeclaration { name, value, .. } => {
                if let Some(expr) = value {
                    Ok(format!("(define {} {})", name, self.generate_expression(expr)?))
                } else {
                    Ok(format!("(define {} #f)", name))
                }
            }
            Statement::Return { value, .. } => {
                if let Some(expr) = value {
                    self.generate_expression(expr)
                } else {
                    Ok("#f".to_string())
                }
            }
            Statement::Expression { expression, .. } => {
                self.generate_expression(expression)
            }
            _ => Ok(";; Unsupported statement".to_string()),
        }
    }
    
    fn generate_expression(&self, expression: &Expression) -> Result<String> {
        match expression {
            Expression::Literal { value, .. } => {
                match value {
                    LiteralValue::Number(n) => Ok(n.to_string()),
                    LiteralValue::String(s) => Ok(format!("\"{}\"", s.replace('"', "\\\""))),
                    LiteralValue::Boolean(b) => Ok(if *b { "#t" } else { "#f" }.to_string()),
                    LiteralValue::Null => Ok("#f".to_string()),
                }
            }
            Expression::Identifier { name, .. } => Ok(name.clone()),
            Expression::Binary { left, operator, right, .. } => {
                let left_str = self.generate_expression(left)?;
                let right_str = self.generate_expression(right)?;
                let op_str = match operator {
                    BinaryOperator::Add => "string-append",
                    BinaryOperator::Subtract => "-",
                    BinaryOperator::Multiply => "*",
                    BinaryOperator::Divide => "/",
                    BinaryOperator::Equal => "equal?",
                    BinaryOperator::Less => "<",
                    BinaryOperator::Greater => ">",
                    BinaryOperator::LessEqual => "<=",
                    BinaryOperator::GreaterEqual => ">=",
                    BinaryOperator::And => "and",
                    BinaryOperator::Or => "or",
                    _ => ";; unsupported ;;",
                };
                Ok(format!("({} {} {})", op_str, left_str, right_str))
            }
            Expression::Call { callee, arguments, .. } => {
                let callee_str = match callee.as_ref() {
                    Expression::Identifier { name, .. } => name.clone(),
                    _ => self.generate_expression(callee)?,
                };
                let args: Result<Vec<String>> = arguments.iter()
                    .map(|arg| self.generate_expression(arg))
                    .collect();
                let args_str = args?.join(" ");
                Ok(format!("({} {})", callee_str, args_str))
            }
            _ => Ok(";; Unsupported expression ;;".to_string()),
        }
    }
}

/// Racket code generator  
pub struct RacketTransformer;

impl Transformer for RacketTransformer {
    fn transform(&self, program: &Program) -> Result<String> {
        let mut output = String::new();
        output.push_str(";; Generated by Utopia Compiler - Racket Backend\n");
        output.push_str(";; Multi-language support with runtime integration\n");
        output.push_str(";; General-purpose Lisp with extensive libraries\n\n");
        
        output.push_str("#lang racket\n\n");
        output.push_str("(require racket/string)\n");
        output.push_str("(require json)\n\n");
        
        // Process language blocks
        for block in &program.language_blocks {
            if block.language == "racket" || block.language == "rkt" || block.language == "main" {
                output.push_str(&self.generate_racket_functions(block)?);
            } else {
                output.push_str(&self.generate_cross_language_functions(block)?);
            }
        }
        
        // Main execution
        if !program.global_statements.is_empty() {
            for statement in &program.global_statements {
                output.push_str(&format!("{}\n", self.generate_statement(statement)?));
            }
        }
        
        Ok(output)
    }
    
    fn target_name(&self) -> &str {
        "racket"
    }
    
    fn file_extension(&self) -> &str {
        ".rkt"
    }
    
    fn supports_language(&self, language: &str) -> bool {
        matches!(language, "racket" | "rkt")
    }
}

impl RacketTransformer {
    fn generate_racket_functions(&self, block: &LanguageBlock) -> Result<String> {
        let mut output = String::new();
        
        for function in &block.functions {
            output.push_str(&self.generate_function(function)?);
            output.push('\n');
        }
        
        Ok(output)
    }
    
    fn generate_cross_language_functions(&self, block: &LanguageBlock) -> Result<String> {
        let mut output = String::new();
        output.push_str(&format!(";; Cross-language block: {}\n", block.language));
        
        for function in &block.functions {
            output.push_str(&format!("(define ({} . args)\n", function.name));
            output.push_str(&format!(
                "  (error \"Cross-language call to {}::{} not implemented\"))\n\n",
                block.language, function.name
            ));
        }
        
        Ok(output)
    }
    
    fn generate_function(&self, function: &Function) -> Result<String> {
        let mut output = String::new();
        
        // Function definition
        output.push_str(&format!("(define ({}", function.name));
        
        // Parameters
        for param in &function.parameters {
            output.push_str(&format!(" {}", param.name));
        }
        
        output.push_str(")\n");
        
        // Function body
        if let Some(first_stmt) = function.body.first() {
            if let Statement::Return { value: Some(expr), .. } = first_stmt {
                output.push_str(&format!("  {})\n", self.generate_expression(expr)?));
            } else {
                output.push_str("  \"function result\")\n");
            }
        } else {
            output.push_str("  \"empty function\")\n");
        }
        
        Ok(output)
    }
    
    fn generate_statement(&self, statement: &Statement) -> Result<String> {
        match statement {
            Statement::VariableDeclaration { name, value, .. } => {
                if let Some(expr) = value {
                    Ok(format!("(define {} {})", name, self.generate_expression(expr)?))
                } else {
                    Ok(format!("(define {} #f)", name))
                }
            }
            Statement::Return { value, .. } => {
                if let Some(expr) = value {
                    self.generate_expression(expr)
                } else {
                    Ok("#f".to_string())
                }
            }
            Statement::Expression { expression, .. } => {
                self.generate_expression(expression)
            }
            _ => Ok(";; Unsupported statement".to_string()),
        }
    }
    
    fn generate_expression(&self, expression: &Expression) -> Result<String> {
        match expression {
            Expression::Literal { value, .. } => {
                match value {
                    LiteralValue::Number(n) => Ok(n.to_string()),
                    LiteralValue::String(s) => Ok(format!("\"{}\"", s.replace('"', "\\\""))),
                    LiteralValue::Boolean(b) => Ok(if *b { "#t" } else { "#f" }.to_string()),
                    LiteralValue::Null => Ok("#f".to_string()),
                }
            }
            Expression::Identifier { name, .. } => Ok(name.clone()),
            Expression::Binary { left, operator, right, .. } => {
                let left_str = self.generate_expression(left)?;
                let right_str = self.generate_expression(right)?;
                let op_str = match operator {
                    BinaryOperator::Add => "string-append",
                    BinaryOperator::Equal => "equal?",
                    BinaryOperator::And => "and",
                    BinaryOperator::Or => "or",
                    _ => ";; unsupported ;;",
                };
                Ok(format!("({} {} {})", op_str, left_str, right_str))
            }
            Expression::Call { callee, arguments, .. } => {
                let callee_str = match callee.as_ref() {
                    Expression::Identifier { name, .. } => name.clone(),
                    _ => self.generate_expression(callee)?,
                };
                let args: Result<Vec<String>> = arguments.iter()
                    .map(|arg| self.generate_expression(arg))
                    .collect();
                let args_str = args?.join(" ");
                Ok(format!("({} {})", callee_str, args_str))
            }
            _ => Ok(";; Unsupported expression ;;".to_string()),
        }
    }
}

/// Smalltalk code generator
pub struct SmalltalkTransformer;

impl Transformer for SmalltalkTransformer {
    fn transform(&self, program: &Program) -> Result<String> {
        let mut output = String::new();
        output.push_str("\"Generated by Utopia Compiler - Smalltalk Backend\"\n");
        output.push_str("\"Multi-language support with runtime integration\"\n");
        output.push_str("\"Pure object-oriented programming\"\n\n");
        
        output.push_str("Object subclass: #UtopiaGenerated\n");
        output.push_str("    instanceVariableNames: ''\n");
        output.push_str("    classVariableNames: ''\n");
        output.push_str("    poolDictionaries: ''\n");
        output.push_str("    category: 'Utopia-Generated'\n\n");
        
        // Process language blocks
        for block in &program.language_blocks {
            if block.language == "smalltalk" || block.language == "st" || block.language == "main" {
                output.push_str(&self.generate_smalltalk_methods(block)?);
            } else {
                output.push_str(&self.generate_cross_language_methods(block)?);
            }
        }
        
        // Main execution
        if !program.global_statements.is_empty() {
            output.push_str("main\n");
            for statement in &program.global_statements {
                output.push_str(&format!("    {}.\n", self.generate_statement(statement)?));
            }
            output.push_str("    ^ self\n\n");
        }
        
        Ok(output)
    }
    
    fn target_name(&self) -> &str {
        "smalltalk"
    }
    
    fn file_extension(&self) -> &str {
        ".st"
    }
    
    fn supports_language(&self, language: &str) -> bool {
        matches!(language, "smalltalk" | "st")
    }
}

impl SmalltalkTransformer {
    fn generate_smalltalk_methods(&self, block: &LanguageBlock) -> Result<String> {
        let mut output = String::new();
        
        for function in &block.functions {
            output.push_str(&self.generate_method(function)?);
            output.push('\n');
        }
        
        Ok(output)
    }
    
    fn generate_cross_language_methods(&self, block: &LanguageBlock) -> Result<String> {
        let mut output = String::new();
        output.push_str(&format!("\"Cross-language block: {}\"\n", block.language));
        
        for function in &block.functions {
            output.push_str(&format!("{}:\n", function.name));
            output.push_str(&format!(
                "    self error: 'Cross-language call to {}::{} not implemented'.\n\n",
                block.language, function.name
            ));
        }
        
        Ok(output)
    }
    
    fn generate_method(&self, function: &Function) -> Result<String> {
        let mut output = String::new();
        
        // Method definition
        if function.parameters.is_empty() {
            output.push_str(&format!("{}\n", function.name));
        } else {
            output.push_str(&format!("{}:", function.name));
            for (i, param) in function.parameters.iter().enumerate() {
                if i == 0 {
                    output.push_str(&format!(" {}", param.name));
                } else {
                    output.push_str(&format!(" {}:", param.name));
                }
            }
            output.push('\n');
        }
        
        // Method body
        if let Some(first_stmt) = function.body.first() {
            if let Statement::Return { value: Some(expr), .. } = first_stmt {
                output.push_str(&format!("    ^ {}\n", self.generate_expression(expr)?));
            } else {
                output.push_str("    ^ 'function result'\n");
            }
        } else {
            output.push_str("    ^ 'empty function'\n");
        }
        
        Ok(output)
    }
    
    fn generate_statement(&self, statement: &Statement) -> Result<String> {
        match statement {
            Statement::VariableDeclaration { name, value, .. } => {
                if let Some(expr) = value {
                    Ok(format!("{} := {}", name, self.generate_expression(expr)?))
                } else {
                    Ok(format!("{} := nil", name))
                }
            }
            Statement::Return { value, .. } => {
                if let Some(expr) = value {
                    Ok(format!("^ {}", self.generate_expression(expr)?))
                } else {
                    Ok("^ nil".to_string())
                }
            }
            Statement::Expression { expression, .. } => {
                self.generate_expression(expression)
            }
            _ => Ok("\"Unsupported statement\"".to_string()),
        }
    }
    
    fn generate_expression(&self, expression: &Expression) -> Result<String> {
        match expression {
            Expression::Literal { value, .. } => {
                match value {
                    LiteralValue::Number(n) => Ok(n.to_string()),
                    LiteralValue::String(s) => Ok(format!("'{}'", s.replace('\'', "''"))),
                    LiteralValue::Boolean(b) => Ok(b.to_string()),
                    LiteralValue::Null => Ok("nil".to_string()),
                }
            }
            Expression::Identifier { name, .. } => Ok(name.clone()),
            Expression::Binary { left, operator, right, .. } => {
                let left_str = self.generate_expression(left)?;
                let right_str = self.generate_expression(right)?;
                match operator {
                    BinaryOperator::Add => Ok(format!("{} , {}", left_str, right_str)),
                    BinaryOperator::Equal => Ok(format!("{} = {}", left_str, right_str)),
                    _ => Ok(format!("({} \"unsupported op\" {})", left_str, right_str)),
                }
            }
            Expression::Call { callee, arguments, .. } => {
                let callee_str = match callee.as_ref() {
                    Expression::Identifier { name, .. } => name.clone(),
                    _ => self.generate_expression(callee)?,
                };
                if arguments.is_empty() {
                    Ok(format!("self {}", callee_str))
                } else {
                    let args: Result<Vec<String>> = arguments.iter()
                        .map(|arg| self.generate_expression(arg))
                        .collect();
                    let args_str = args?.join(" ");
                    Ok(format!("self {}: {}", callee_str, args_str))
                }
            }
            _ => Ok("'Unsupported expression'".to_string()),
        }
    }
}

/// Pascal code generator
pub struct PascalTransformer;

impl Transformer for PascalTransformer {
    fn transform(&self, program: &Program) -> Result<String> {
        let mut output = String::new();
        output.push_str("{ Generated by Utopia Compiler - Pascal Backend }\n");
        output.push_str("{ Multi-language support with runtime integration }\n");
        output.push_str("{ Structured programming with strong typing }\n\n");
        
        output.push_str("program UtopiaGenerated;\n\n");
        output.push_str("uses\n");
        output.push_str("  SysUtils, Classes;\n\n");
        
        // Process language blocks
        for block in &program.language_blocks {
            if block.language == "pascal" || block.language == "pas" || block.language == "main" {
                output.push_str(&self.generate_pascal_functions(block)?);
            } else {
                output.push_str(&self.generate_cross_language_functions(block)?);
            }
        }
        
        // Main execution
        output.push_str("begin\n");
        if !program.global_statements.is_empty() {
            for statement in &program.global_statements {
                output.push_str(&format!("  {};\n", self.generate_statement(statement)?));
            }
        }
        output.push_str("end.\n");
        
        Ok(output)
    }
    
    fn target_name(&self) -> &str {
        "pascal"
    }
    
    fn file_extension(&self) -> &str {
        ".pas"
    }
    
    fn supports_language(&self, language: &str) -> bool {
        matches!(language, "pascal" | "pas")
    }
}

impl PascalTransformer {
    fn generate_pascal_functions(&self, block: &LanguageBlock) -> Result<String> {
        let mut output = String::new();
        
        for function in &block.functions {
            output.push_str(&self.generate_function(function)?);
            output.push('\n');
        }
        
        Ok(output)
    }
    
    fn generate_cross_language_functions(&self, block: &LanguageBlock) -> Result<String> {
        let mut output = String::new();
        output.push_str(&format!("{{ Cross-language block: {} }}\n", block.language));
        
        for function in &block.functions {
            output.push_str(&format!("function {}(args: string): string;\n", function.name));
            output.push_str("begin\n");
            output.push_str(&format!(
                "  raise Exception.Create('Cross-language call to {}::{} not implemented');\n",
                block.language, function.name
            ));
            output.push_str("end;\n\n");
        }
        
        Ok(output)
    }
    
    fn generate_function(&self, function: &Function) -> Result<String> {
        let mut output = String::new();
        
        // Function definition
        output.push_str(&format!("function {}(", function.name));
        
        // Parameters
        for (i, param) in function.parameters.iter().enumerate() {
            if i > 0 {
                output.push_str("; ");
            }
            output.push_str(&format!("{}: string", param.name));
        }
        
        output.push_str("): string;\n");
        output.push_str("begin\n");
        
        // Function body
        if let Some(first_stmt) = function.body.first() {
            if let Statement::Return { value: Some(expr), .. } = first_stmt {
                output.push_str(&format!("  Result := {};\n", self.generate_expression(expr)?));
            } else {
                output.push_str("  Result := 'function result';\n");
            }
        } else {
            output.push_str("  Result := 'empty function';\n");
        }
        
        output.push_str("end;\n");
        Ok(output)
    }
    
    fn generate_statement(&self, statement: &Statement) -> Result<String> {
        match statement {
            Statement::VariableDeclaration { name, value, .. } => {
                if let Some(expr) = value {
                    Ok(format!("{} := {}", name, self.generate_expression(expr)?))
                } else {
                    Ok(format!("{} := ''", name))
                }
            }
            Statement::Return { value, .. } => {
                if let Some(expr) = value {
                    Ok(format!("Result := {}", self.generate_expression(expr)?))
                } else {
                    Ok("Result := ''".to_string())
                }
            }
            Statement::Expression { expression, .. } => {
                self.generate_expression(expression)
            }
            _ => Ok("{{ Unsupported statement }}".to_string()),
        }
    }
    
    fn generate_expression(&self, expression: &Expression) -> Result<String> {
        match expression {
            Expression::Literal { value, .. } => {
                match value {
                    LiteralValue::Number(n) => Ok(format!("'{}'", n)),
                    LiteralValue::String(s) => Ok(format!("'{}'", s.replace('\'', "''"))),
                    LiteralValue::Boolean(b) => Ok(if *b { "'True'" } else { "'False'" }.to_string()),
                    LiteralValue::Null => Ok("''".to_string()),
                }
            }
            Expression::Identifier { name, .. } => Ok(name.clone()),
            Expression::Binary { left, operator, right, .. } => {
                let left_str = self.generate_expression(left)?;
                let right_str = self.generate_expression(right)?;
                match operator {
                    BinaryOperator::Add => Ok(format!("{} + {}", left_str, right_str)),
                    BinaryOperator::Equal => Ok(format!("{} = {}", left_str, right_str)),
                    _ => Ok(format!("(* unsupported: {} op {} *)", left_str, right_str)),
                }
            }
            Expression::Call { callee, arguments, .. } => {
                let callee_str = match callee.as_ref() {
                    Expression::Identifier { name, .. } => name.clone(),
                    _ => self.generate_expression(callee)?,
                };
                let args: Result<Vec<String>> = arguments.iter()
                    .map(|arg| self.generate_expression(arg))
                    .collect();
                let args_str = args?.join(", ");
                Ok(format!("{}({})", callee_str, args_str))
            }
            _ => Ok("'Unsupported expression'".to_string()),
        }
    }
}

/// BASIC code generator
pub struct BasicTransformer;

impl Transformer for BasicTransformer {
    fn transform(&self, program: &Program) -> Result<String> {
        let mut output = String::new();
        output.push_str("REM Generated by Utopia Compiler - BASIC Backend\n");
        output.push_str("REM Multi-language support with runtime integration\n");
        output.push_str("REM Beginner's All-purpose Symbolic Instruction Code\n\n");
        
        let mut line_number = 10;
        
        // Process language blocks
        for block in &program.language_blocks {
            if block.language == "basic" || block.language == "bas" || block.language == "main" {
                let functions_code = self.generate_basic_functions(block, &mut line_number)?;
                output.push_str(&functions_code);
            } else {
                let cross_code = self.generate_cross_language_functions(block, &mut line_number)?;
                output.push_str(&cross_code);
            }
        }
        
        // Main execution
        if !program.global_statements.is_empty() {
            for statement in &program.global_statements {
                output.push_str(&format!("{} {}\n", line_number, self.generate_statement(statement)?));
                line_number += 10;
            }
        }
        
        output.push_str(&format!("{} END\n", line_number));
        
        Ok(output)
    }
    
    fn target_name(&self) -> &str {
        "basic"
    }
    
    fn file_extension(&self) -> &str {
        ".bas"
    }
    
    fn supports_language(&self, language: &str) -> bool {
        matches!(language, "basic" | "bas")
    }
}

impl BasicTransformer {
    fn generate_basic_functions(&self, block: &LanguageBlock, line_number: &mut i32) -> Result<String> {
        let mut output = String::new();
        
        for function in &block.functions {
            let func_code = self.generate_function(function, line_number)?;
            output.push_str(&func_code);
            output.push('\n');
        }
        
        Ok(output)
    }
    
    fn generate_cross_language_functions(&self, block: &LanguageBlock, line_number: &mut i32) -> Result<String> {
        let mut output = String::new();
        output.push_str(&format!("{} REM Cross-language block: {}\n", *line_number, block.language));
        *line_number += 10;
        
        for function in &block.functions {
            output.push_str(&format!("{} REM Function: {}\n", *line_number, function.name));
            *line_number += 10;
            output.push_str(&format!("{} PRINT \"Cross-language call to {}::{} not implemented\"\n", 
                *line_number, block.language, function.name));
            *line_number += 10;
            output.push_str(&format!("{} RETURN\n", *line_number));
            *line_number += 10;
            output.push('\n');
        }
        
        Ok(output)
    }
    
    fn generate_function(&self, function: &Function, line_number: &mut i32) -> Result<String> {
        let mut output = String::new();
        
        // Function label
        output.push_str(&format!("{} REM Function: {}\n", *line_number, function.name));
        *line_number += 10;
        
        // Function body
        if let Some(first_stmt) = function.body.first() {
            if let Statement::Return { value: Some(expr), .. } = first_stmt {
                output.push_str(&format!("{} RESULT$ = {}\n", *line_number, self.generate_expression(expr)?));
                *line_number += 10;
            } else {
                output.push_str(&format!("{} RESULT$ = \"function result\"\n", *line_number));
                *line_number += 10;
            }
        } else {
            output.push_str(&format!("{} RESULT$ = \"empty function\"\n", *line_number));
            *line_number += 10;
        }
        
        output.push_str(&format!("{} RETURN\n", *line_number));
        *line_number += 10;
        
        Ok(output)
    }
    
    fn generate_statement(&self, statement: &Statement) -> Result<String> {
        match statement {
            Statement::VariableDeclaration { name, value, .. } => {
                if let Some(expr) = value {
                    Ok(format!("LET {}$ = {}", name.to_uppercase(), self.generate_expression(expr)?))
                } else {
                    Ok(format!("LET {}$ = \"\"", name.to_uppercase()))
                }
            }
            Statement::Return { value, .. } => {
                if let Some(expr) = value {
                    Ok(format!("RESULT$ = {}", self.generate_expression(expr)?))
                } else {
                    Ok("RESULT$ = \"\"".to_string())
                }
            }
            Statement::Expression { expression, .. } => {
                match expression {
                    Expression::Call { .. } => {
                        Ok(format!("PRINT {}", self.generate_expression(expression)?))
                    }
                    _ => self.generate_expression(expression)
                }
            }
            _ => Ok("REM Unsupported statement".to_string()),
        }
    }
    
    fn generate_expression(&self, expression: &Expression) -> Result<String> {
        match expression {
            Expression::Literal { value, .. } => {
                match value {
                    LiteralValue::Number(n) => Ok(format!("\"{}\"", n)),
                    LiteralValue::String(s) => Ok(format!("\"{}\"", s.replace('"', "\"\""))),
                    LiteralValue::Boolean(b) => Ok(if *b { "\"TRUE\"" } else { "\"FALSE\"" }.to_string()),
                    LiteralValue::Null => Ok("\"\"".to_string()),
                }
            }
            Expression::Identifier { name, .. } => Ok(format!("{}$", name.to_uppercase())),
            Expression::Binary { left, operator, right, .. } => {
                let left_str = self.generate_expression(left)?;
                let right_str = self.generate_expression(right)?;
                match operator {
                    BinaryOperator::Add => Ok(format!("{} + {}", left_str, right_str)),
                    _ => Ok(format!("REM unsupported: {} op {}", left_str, right_str)),
                }
            }
            Expression::Call { callee, arguments, .. } => {
                let callee_str = match callee.as_ref() {
                    Expression::Identifier { name, .. } => name.clone(),
                    _ => self.generate_expression(callee)?,
                };
                let args: Result<Vec<String>> = arguments.iter()
                    .map(|arg| self.generate_expression(arg))
                    .collect();
                let args_str = args?.join(" + ");
                Ok(format!("\"{}({})\"", callee_str, args_str))
            }
            _ => Ok("\"Unsupported expression\"".to_string()),
        }
    }
}

/// CUDA code generator
pub struct CudaTransformer;

impl Transformer for CudaTransformer {
    fn transform(&self, _program: &Program) -> Result<String> {
        let mut output = String::new();
        
        output.push_str("// Generated by Utopia Compiler - CUDA Backend\n");
        output.push_str("// GPU acceleration with NVIDIA CUDA\n\n");
        
        output.push_str("#include <cuda_runtime.h>\n");
        output.push_str("#include <cuda.h>\n");
        output.push_str("#include <device_launch_parameters.h>\n");
        output.push_str("#include <stdio.h>\n");
        output.push_str("#include <stdlib.h>\n\n");
        
        output.push_str("#define CUDA_CHECK(call) \\\n");
        output.push_str("    do { \\\n");
        output.push_str("        cudaError_t err = call; \\\n");
        output.push_str("        if (err != cudaSuccess) { \\\n");
        output.push_str("            fprintf(stderr, \"CUDA error at %s:%d - %s\\n\", __FILE__, __LINE__, cudaGetErrorString(err)); \\\n");
        output.push_str("            exit(1); \\\n");
        output.push_str("        } \\\n");
        output.push_str("    } while(0)\n\n");
        
        // Process language blocks
        for block in &_program.language_blocks {
            if block.language == "cuda" {
                output.push_str(&self.generate_cuda_block(block)?);
            } else {
                output.push_str(&format!("// Cross-language block: {}\n", block.language));
            }
        }
        
        // Main function for CUDA setup
        output.push_str("int main() {\n");
        output.push_str("    int device_count = 0;\n");
        output.push_str("    CUDA_CHECK(cudaGetDeviceCount(&device_count));\n");
        output.push_str("    printf(\"Found %d CUDA devices\\n\", device_count);\n");
        output.push_str("    \n");
        output.push_str("    if (device_count > 0) {\n");
        output.push_str("        CUDA_CHECK(cudaSetDevice(0));\n");
        output.push_str("        printf(\"Hello from Utopia CUDA!\\n\");\n");
        output.push_str("        // Your kernel calls here\n");
        output.push_str("    }\n");
        output.push_str("    \n");
        output.push_str("    return 0;\n");
        output.push_str("}\n");
        
        Ok(output)
    }
    
    fn target_name(&self) -> &str {
        "cuda"
    }
    
    fn file_extension(&self) -> &str {
        ".cu"
    }
    
    fn supports_language(&self, language: &str) -> bool {
        language == "cuda" || language == "gpu"
    }
}

impl CudaTransformer {
    fn generate_cuda_block(&self, block: &LanguageBlock) -> Result<String> {
        let mut output = String::new();
        
        for function in &block.functions {
            output.push_str(&self.generate_kernel(function)?);
            output.push('\n');
        }
        
        Ok(output)
    }
    
    fn generate_kernel(&self, function: &Function) -> Result<String> {
        let mut output = String::new();
        
        // Kernel definition
        output.push_str("__global__ void ");
        output.push_str(&function.name);
        output.push('(');
        
        // Parameters
        for (i, param) in function.parameters.iter().enumerate() {
            if i > 0 {
                output.push_str(", ");
            }
            output.push_str(&self.convert_type(param.param_type.as_ref()));
            output.push(' ');
            output.push_str(&param.name);
        }
        
        output.push_str(") {\n");
        
        // Thread index calculations
        output.push_str("    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n");
        output.push_str("    int stride = blockDim.x * gridDim.x;\n");
        output.push_str("    \n");
        
        // Function body
        if function.body.is_empty() {
            output.push_str("    // Empty kernel\n");
        } else {
            output.push_str("    // Kernel body\n");
        }
        
        output.push_str("}\n");
        Ok(output)
    }
    
    fn convert_type(&self, utopia_type: Option<&crate::types::Type>) -> String {
        match utopia_type {
            Some(crate::types::Type::Number) => "float".to_string(),
            Some(crate::types::Type::String) => "char*".to_string(),
            Some(crate::types::Type::Boolean) => "bool".to_string(),
            Some(crate::types::Type::Array(_)) => "float*".to_string(), // GPU arrays are typically float pointers
            _ => "float".to_string(),
        }
    }
}

/// Embedded C code generator
pub struct EmbeddedCTransformer;

impl Transformer for EmbeddedCTransformer {
    fn transform(&self, program: &Program) -> Result<String> {
        let mut output = String::new();
        
        output.push_str("// Generated by Utopia Compiler - Embedded C Backend\n");
        output.push_str("// Optimized for microcontrollers and IoT devices\n\n");
        
        output.push_str("#include <stdint.h>\n");
        output.push_str("#include <stdbool.h>\n");
        output.push_str("#include <string.h>\n");
        output.push_str("#ifdef ARDUINO\n");
        output.push_str("#include <Arduino.h>\n");
        output.push_str("#endif\n\n");
        
        // Memory-efficient value type for embedded systems
        output.push_str("typedef union {\n");
        output.push_str("    int32_t i;\n");
        output.push_str("    float f;\n");
        output.push_str("    bool b;\n");
        output.push_str("    char* s;\n");
        output.push_str("} utopia_value_t;\n\n");
        
        output.push_str("typedef struct {\n");
        output.push_str("    utopia_value_t value;\n");
        output.push_str("    uint8_t type; // 0=int, 1=float, 2=bool, 3=string\n");
        output.push_str("} utopia_typed_value_t;\n\n");
        
        // Process language blocks
        for block in &program.language_blocks {
            if block.language == "embedded_c" || block.language == "embedded-c" {
                output.push_str(&self.generate_embedded_block(block)?);
            } else {
                output.push_str(&format!("// Cross-language block: {} (not supported in embedded)\n", block.language));
            }
        }
        
        // Main function for embedded
        output.push_str("int main(void) {\n");
        output.push_str("#ifdef ARDUINO\n");
        output.push_str("    setup();\n");
        output.push_str("    while(1) {\n");
        output.push_str("        loop();\n");
        output.push_str("    }\n");
        output.push_str("#else\n");
        output.push_str("    // Embedded main loop\n");
        output.push_str("    while(1) {\n");
        output.push_str("        // Your embedded code here\n");
        output.push_str("    }\n");
        output.push_str("#endif\n");
        output.push_str("    return 0;\n");
        output.push_str("}\n");
        
        Ok(output)
    }
    
    fn target_name(&self) -> &str {
        "embedded-c"
    }
    
    fn file_extension(&self) -> &str {
        ".c"
    }
    
    fn supports_language(&self, language: &str) -> bool {
        language == "embedded_c" || language == "embedded-c" || language == "arduino"
    }
}

impl EmbeddedCTransformer {
    fn generate_embedded_block(&self, block: &LanguageBlock) -> Result<String> {
        let mut output = String::new();
        
        for function in &block.functions {
            output.push_str(&self.generate_function(function)?);
            output.push('\n');
        }
        
        Ok(output)
    }
    
    fn generate_function(&self, function: &Function) -> Result<String> {
        let mut output = String::new();
        
        // Function signature with memory-efficient types
        if let Some(ref return_type) = function.return_type {
            output.push_str(&self.convert_type(Some(return_type)));
        } else {
            output.push_str("void");
        }
        
        output.push(' ');
        output.push_str(&function.name);
        output.push('(');
        
        // Parameters
        for (i, param) in function.parameters.iter().enumerate() {
            if i > 0 {
                output.push_str(", ");
            }
            output.push_str(&self.convert_type(param.param_type.as_ref()));
            output.push(' ');
            output.push_str(&param.name);
        }
        
        if function.parameters.is_empty() {
            output.push_str("void");
        }
        
        output.push_str(") {\n");
        
        // Function body
        if function.body.is_empty() {
            output.push_str("    // Empty function\n");
        } else {
            output.push_str("    // Function body\n");
        }
        
        output.push_str("}\n");
        Ok(output)
    }
    
    fn convert_type(&self, utopia_type: Option<&crate::types::Type>) -> String {
        match utopia_type {
            Some(crate::types::Type::Number) => "float".to_string(),
            Some(crate::types::Type::String) => "char*".to_string(),
            Some(crate::types::Type::Boolean) => "bool".to_string(),
            Some(crate::types::Type::Void) => "void".to_string(),
            Some(crate::types::Type::Array(_)) => "utopia_typed_value_t*".to_string(),
            _ => "utopia_typed_value_t".to_string(),
        }
    }
}

/// Backend manager that handles all code generation
pub struct TransformerManager {
    backends: HashMap<String, Box<dyn Transformer>>,
}

impl TransformerManager {
    pub fn new() -> Self {
        let mut backends: HashMap<String, Box<dyn Transformer>> = HashMap::new();
        
        // Add all backends
        backends.insert("python".to_string(), Box::new(PythonTransformer));
        backends.insert("py".to_string(), Box::new(PythonTransformer));
        
        backends.insert("javascript".to_string(), Box::new(JavaScriptTransformer::new(false)));
        backends.insert("js".to_string(), Box::new(JavaScriptTransformer::new(false)));
        
        backends.insert("typescript".to_string(), Box::new(JavaScriptTransformer::new(true)));
        backends.insert("ts".to_string(), Box::new(JavaScriptTransformer::new(true)));
        
        backends.insert("assembly".to_string(), Box::new(AssemblyTransformer));
        backends.insert("asm".to_string(), Box::new(AssemblyTransformer));
        backends.insert("x86_64".to_string(), Box::new(AssemblyTransformer));
        
        backends.insert("c".to_string(), Box::new(CTransformer));
        
        backends.insert("cpp".to_string(), Box::new(CppTransformer));
        backends.insert("c++".to_string(), Box::new(CppTransformer));
        backends.insert("cxx".to_string(), Box::new(CppTransformer));
        
        backends.insert("llvm".to_string(), Box::new(LLVMTransformer));
        backends.insert("llvm-ir".to_string(), Box::new(LLVMTransformer));
        
        backends.insert("wasm".to_string(), Box::new(WasmTransformer));
        backends.insert("webassembly".to_string(), Box::new(WasmTransformer));
        
        // New backends
        backends.insert("rust".to_string(), Box::new(RustTransformer));
        backends.insert("rs".to_string(), Box::new(RustTransformer));
        
        backends.insert("go".to_string(), Box::new(GoTransformer));
        backends.insert("golang".to_string(), Box::new(GoTransformer));
        
        backends.insert("java".to_string(), Box::new(JavaTransformer));
        
        backends.insert("csharp".to_string(), Box::new(CSharpTransformer));
        backends.insert("c#".to_string(), Box::new(CSharpTransformer));
        backends.insert("cs".to_string(), Box::new(CSharpTransformer));
        
        backends.insert("visualbasic".to_string(), Box::new(VisualBasicTransformer));
        backends.insert("vb".to_string(), Box::new(VisualBasicTransformer));
        backends.insert("vbnet".to_string(), Box::new(VisualBasicTransformer));
        
        backends.insert("perl".to_string(), Box::new(PerlTransformer));
        backends.insert("pl".to_string(), Box::new(PerlTransformer));
        
        backends.insert("php".to_string(), Box::new(PHPTransformer));
        
        backends.insert("ada".to_string(), Box::new(AdaTransformer));
        
        backends.insert("delphi".to_string(), Box::new(DelphiTransformer));
        backends.insert("pascal".to_string(), Box::new(DelphiTransformer));
        
        backends.insert("fortran".to_string(), Box::new(FortranTransformer));
        backends.insert("f90".to_string(), Box::new(FortranTransformer));
        backends.insert("f95".to_string(), Box::new(FortranTransformer));
        
        backends.insert("sql".to_string(), Box::new(SQLTransformer));
        
        backends.insert("r".to_string(), Box::new(RTransformer));
        
        backends.insert("matlab".to_string(), Box::new(MatlabTransformer));
        backends.insert("m".to_string(), Box::new(MatlabTransformer));
        
        backends.insert("kotlin".to_string(), Box::new(KotlinTransformer));
        backends.insert("kt".to_string(), Box::new(KotlinTransformer));
        
        backends.insert("swift".to_string(), Box::new(SwiftTransformer));
        
        backends.insert("cobol".to_string(), Box::new(CobolTransformer));
        backends.insert("cob".to_string(), Box::new(CobolTransformer));
        
        backends.insert("ruby".to_string(), Box::new(RubyTransformer));
        backends.insert("rb".to_string(), Box::new(RubyTransformer));
        
        backends.insert("lisp".to_string(), Box::new(LispTransformer));
        backends.insert("cl".to_string(), Box::new(LispTransformer));
        
        backends.insert("prolog".to_string(), Box::new(PrologTransformer));
        backends.insert("pl".to_string(), Box::new(PrologTransformer));
        
        backends.insert("dart".to_string(), Box::new(DartTransformer));
        
        backends.insert("lua".to_string(), Box::new(LuaTransformer));
        
        backends.insert("haskell".to_string(), Box::new(HaskellTransformer));
        backends.insert("hs".to_string(), Box::new(HaskellTransformer));
        
        backends.insert("objective-c".to_string(), Box::new(ObjectiveCTransformer));
        backends.insert("objc".to_string(), Box::new(ObjectiveCTransformer));
        backends.insert("objectivec".to_string(), Box::new(ObjectiveCTransformer));
        
        backends.insert("scala".to_string(), Box::new(ScalaTransformer));
        
        backends.insert("julia".to_string(), Box::new(JuliaTransformer));
        backends.insert("jl".to_string(), Box::new(JuliaTransformer));
        
        backends.insert("vbscript".to_string(), Box::new(VBScriptTransformer));
        backends.insert("vbs".to_string(), Box::new(VBScriptTransformer));
        
        backends.insert("bash".to_string(), Box::new(BashTransformer));
        backends.insert("sh".to_string(), Box::new(BashTransformer));
        backends.insert("shell".to_string(), Box::new(BashTransformer));
        
        backends.insert("nim".to_string(), Box::new(NimTransformer));
        
        backends.insert("crystal".to_string(), Box::new(CrystalTransformer));
        backends.insert("cr".to_string(), Box::new(CrystalTransformer));
        
        backends.insert("zig".to_string(), Box::new(ZigTransformer));
        
        backends.insert("elixir".to_string(), Box::new(ElixirTransformer));
        backends.insert("ex".to_string(), Box::new(ElixirTransformer));
        
        backends.insert("fsharp".to_string(), Box::new(FSharpTransformer));
        backends.insert("fs".to_string(), Box::new(FSharpTransformer));
        backends.insert("f#".to_string(), Box::new(FSharpTransformer));
        
        backends.insert("clojure".to_string(), Box::new(ClojureTransformer));
        backends.insert("clj".to_string(), Box::new(ClojureTransformer));
        
        backends.insert("erlang".to_string(), Box::new(ErlangTransformer));
        backends.insert("erl".to_string(), Box::new(ErlangTransformer));
        
        backends.insert("ocaml".to_string(), Box::new(OCamlTransformer));
        backends.insert("ml".to_string(), Box::new(OCamlTransformer));
        
        backends.insert("scheme".to_string(), Box::new(SchemeTransformer));
        backends.insert("scm".to_string(), Box::new(SchemeTransformer));
        
        backends.insert("racket".to_string(), Box::new(RacketTransformer));
        backends.insert("rkt".to_string(), Box::new(RacketTransformer));
        
        backends.insert("smalltalk".to_string(), Box::new(SmalltalkTransformer));
        backends.insert("st".to_string(), Box::new(SmalltalkTransformer));
        
        backends.insert("pascal".to_string(), Box::new(PascalTransformer));
        backends.insert("pas".to_string(), Box::new(PascalTransformer));
        
        backends.insert("basic".to_string(), Box::new(BasicTransformer));
        backends.insert("bas".to_string(), Box::new(BasicTransformer));
        
        backends.insert("cuda".to_string(), Box::new(CudaTransformer));
        backends.insert("gpu".to_string(), Box::new(CudaTransformer));
        
        backends.insert("embedded-c".to_string(), Box::new(EmbeddedCTransformer));
        backends.insert("embedded_c".to_string(), Box::new(EmbeddedCTransformer));
        backends.insert("arduino".to_string(), Box::new(EmbeddedCTransformer));
        
        Self { backends }
    }
    
    pub fn transform(&self, target: &str, program: &Program) -> Result<String> {
        if let Some(backend) = self.backends.get(target) {
            backend.transform(program)
        } else {
            Err(format!("Unsupported target: {}", target).into())
        }
    }
    
    pub fn supported_targets(&self) -> Vec<String> {
        self.backends.keys().cloned().collect()
    }
    
    pub fn get_file_extension(&self, target: &str) -> Option<String> {
        self.backends.get(target).map(|b| b.file_extension().to_string())
    }
}

impl Default for TransformerManager {
    fn default() -> Self {
        Self::new()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::Span;

    #[test]
    fn test_python_backend() {
        let backend = PythonTransformer;
        let span = Span::new(0, 10, 1, 1);
        let program = Program::new(span);
        
        let result = backend.transform(&program);
        assert!(result.is_ok());
        
        let code = result.unwrap();
        assert!(code.contains("#!/usr/bin/env python3"));
        assert!(code.contains("Generated by Utopia Compiler"));
    }

    #[test]
    fn test_javascript_backend() {
        let backend = JavaScriptTransformer::new(false);
        let span = Span::new(0, 10, 1, 1);
        let program = Program::new(span);
        
        let result = backend.transform(&program);
        assert!(result.is_ok());
        
        let code = result.unwrap();
        assert!(code.contains("JavaScript Backend"));
    }

    #[test]
    fn test_backend_manager() {
        let manager = TransformerManager::new();
        let targets = manager.supported_targets();
        
        assert!(targets.contains(&"python".to_string()));
        assert!(targets.contains(&"javascript".to_string()));
        assert!(targets.contains(&"assembly".to_string()));
        assert!(targets.contains(&"c".to_string()));
        assert!(targets.contains(&"llvm".to_string()));
        assert!(targets.contains(&"wasm".to_string()));
    }

    #[test]
    fn test_csharp_backend() {
        let backend = CSharpTransformer;
        let span = Span::new(0, 10, 1, 1);
        let program = Program::new(span);
        
        let result = backend.transform(&program);
        assert!(result.is_ok());
        
        let code = result.unwrap();
        assert!(code.contains("// Generated by Utopia Compiler - C# Backend"));
        assert!(code.contains("using System;"));
        assert!(code.contains("namespace Utopia.Generated"));
        assert!(code.contains("public class Program"));
    }

    #[test]
    fn test_visualbasic_backend() {
        let backend = VisualBasicTransformer;
        let span = Span::new(0, 10, 1, 1);
        let program = Program::new(span);
        
        let result = backend.transform(&program);
        assert!(result.is_ok());
        
        let code = result.unwrap();
        assert!(code.contains("' Generated by Utopia Compiler - Visual Basic .NET Backend"));
        assert!(code.contains("Imports System"));
        assert!(code.contains("Namespace Utopia.Generated"));
        assert!(code.contains("Public Module Program"));
    }

    #[test]
    fn test_ada_backend() {
        let backend = AdaTransformer;
        let span = Span::new(0, 10, 1, 1);
        let program = Program::new(span);
        
        let result = backend.transform(&program);
        assert!(result.is_ok());
        
        let code = result.unwrap();
        assert!(code.contains("-- Generated by Utopia Compiler - Ada Backend"));
        assert!(code.contains("with Ada.Text_IO;"));
        assert!(code.contains("package Utopia_Generated is"));
        assert!(code.contains("package body Utopia_Generated is"));
    }

    #[test]
    fn test_delphi_backend() {
        let backend = DelphiTransformer;
        let span = Span::new(0, 10, 1, 1);
        let program = Program::new(span);
        
        let result = backend.transform(&program);
        assert!(result.is_ok());
        
        let code = result.unwrap();
        assert!(code.contains("{ Generated by Utopia Compiler - Delphi/Object Pascal Backend }"));
        assert!(code.contains("unit UtopiaGenerated;"));
        assert!(code.contains("interface"));
        assert!(code.contains("implementation"));
        assert!(code.contains("uses"));
    }

    #[test]
    fn test_sql_backend() {
        let backend = SQLTransformer;
        let span = Span::new(0, 10, 1, 1);
        let program = Program::new(span);
        
        let result = backend.transform(&program);
        assert!(result.is_ok());
        
        let code = result.unwrap();
        assert!(code.contains("-- Generated by Utopia Compiler - SQL Backend"));
        assert!(code.contains("-- Database schema and procedures"));
        assert!(code.contains("-- Note: Adapt connection strings"));
    }

    #[test]
    fn test_r_backend() {
        let backend = RTransformer;
        let span = Span::new(0, 10, 1, 1);
        let program = Program::new(span);
        
        let result = backend.transform(&program);
        assert!(result.is_ok());
        
        let code = result.unwrap();
        assert!(code.contains("# Generated by Utopia Compiler - R Backend"));
        assert!(code.contains("library(jsonlite)"));
        assert!(code.contains("library(httr)"));
    }

    #[test]
    fn test_matlab_backend() {
        let backend = MatlabTransformer;
        let span = Span::new(0, 10, 1, 1);
        let program = Program::new(span);
        
        let result = backend.transform(&program);
        assert!(result.is_ok());
        
        let code = result.unwrap();
        assert!(code.contains("% Generated by Utopia Compiler - MATLAB Backend"));
        assert!(code.contains("% Multi-language support"));
    }

    #[test]
    fn test_kotlin_backend() {
        let backend = KotlinTransformer;
        let span = Span::new(0, 10, 1, 1);
        let program = Program::new(span);
        
        let result = backend.transform(&program);
        assert!(result.is_ok());
        
        let code = result.unwrap();
        assert!(code.contains("// Generated by Utopia Compiler - Kotlin Backend"));
        assert!(code.contains("package utopia.generated"));
        assert!(code.contains("import kotlinx.coroutines.*"));
    }

    #[test]
    fn test_swift_backend() {
        let backend = SwiftTransformer;
        let span = Span::new(0, 10, 1, 1);
        let program = Program::new(span);
        
        let result = backend.transform(&program);
        assert!(result.is_ok());
        
        let code = result.unwrap();
        assert!(code.contains("// Generated by Utopia Compiler - Swift Backend"));
        assert!(code.contains("import Foundation"));
        assert!(code.contains("import UIKit"));
        assert!(code.contains("import SwiftUI"));
    }

    #[test]
    fn test_cobol_backend() {
        let backend = CobolTransformer;
        let span = Span::new(0, 10, 1, 1);
        let program = Program::new(span);
        
        let result = backend.transform(&program);
        assert!(result.is_ok());
        
        let code = result.unwrap();
        assert!(code.contains("* Generated by Utopia Compiler - COBOL Backend"));
        assert!(code.contains("IDENTIFICATION DIVISION"));
        assert!(code.contains("PROGRAM-ID. UTOPIA-GENERATED"));
        assert!(code.contains("PROCEDURE DIVISION"));
        assert!(code.contains("STOP RUN"));
    }

    #[test]
    fn test_ruby_backend() {
        let backend = RubyTransformer;
        let span = Span::new(0, 10, 1, 1);
        let program = Program::new(span);
        
        let result = backend.transform(&program);
        assert!(result.is_ok());
        
        let code = result.unwrap();
        assert!(code.contains("# Generated by Utopia Compiler - Ruby Backend"));
        assert!(code.contains("require 'json'"));
        assert!(code.contains("require 'net/http'"));
        assert!(code.contains("# Ruby on Rails"));
    }

    #[test]
    fn test_lisp_backend() {
        let backend = LispTransformer;
        let span = Span::new(0, 10, 1, 1);
        let program = Program::new(span);
        
        let result = backend.transform(&program);
        assert!(result.is_ok());
        
        let code = result.unwrap();
        assert!(code.contains(";; Generated by Utopia Compiler - Lisp Backend"));
        assert!(code.contains("(require 'cl-lib)"));
        assert!(code.contains("(require 'json)"));
        assert!(code.contains(";; AI research"));
    }

    #[test]
    fn test_prolog_backend() {
        let backend = PrologTransformer;
        let span = Span::new(0, 10, 1, 1);
        let program = Program::new(span);
        
        let result = backend.transform(&program);
        assert!(result.is_ok());
        
        let code = result.unwrap();
        assert!(code.contains("% Generated by Utopia Compiler - Prolog Backend"));
        assert!(code.contains(":- use_module(library(lists))"));
        assert!(code.contains("% Logic programming"));
    }

    #[test]
    fn test_dart_backend() {
        let backend = DartTransformer;
        let span = Span::new(0, 10, 1, 1);
        let program = Program::new(span);
        
        let result = backend.transform(&program);
        assert!(result.is_ok());
        
        let code = result.unwrap();
        assert!(code.contains("// Generated by Utopia Compiler - Dart Backend"));
        assert!(code.contains("import 'dart:convert';"));
        assert!(code.contains("import 'package:flutter/material.dart';"));
        assert!(code.contains("// Flutter mobile app"));
    }

    #[test]
    fn test_lua_backend() {
        let backend = LuaTransformer;
        let span = Span::new(0, 10, 1, 1);
        let program = Program::new(span);
        
        let result = backend.transform(&program);
        assert!(result.is_ok());
        
        let code = result.unwrap();
        assert!(code.contains("-- Generated by Utopia Compiler - Lua Backend"));
        assert!(code.contains("local json = require('json')"));
        assert!(code.contains("-- Game scripting"));
    }

    #[test]
    fn test_haskell_backend() {
        let backend = HaskellTransformer;
        let span = Span::new(0, 10, 1, 1);
        let program = Program::new(span);
        
        let result = backend.transform(&program);
        assert!(result.is_ok());
        
        let code = result.unwrap();
        assert!(code.contains("-- Generated by Utopia Compiler - Haskell Backend"));
        assert!(code.contains("module UtopiaGenerated where"));
        assert!(code.contains("import Data.List"));
        assert!(code.contains("-- Pure functional programming"));
    }

    #[test]
    fn test_objective_c_backend() {
        let backend = ObjectiveCTransformer;
        let span = Span::new(0, 10, 1, 1);
        let program = Program::new(span);
        
        let result = backend.transform(&program);
        assert!(result.is_ok());
        
        let code = result.unwrap();
        assert!(code.contains("// Generated by Utopia Compiler - Objective-C Backend"));
        assert!(code.contains("#import <Foundation/Foundation.h>"));
        assert!(code.contains("@interface UtopiaRuntime : NSObject"));
        assert!(code.contains("@implementation UtopiaRuntime"));
        assert!(code.contains("// Legacy iOS/macOS"));
    }

    #[test]
    fn test_scala_backend() {
        let backend = ScalaTransformer;
        let span = Span::new(0, 10, 1, 1);
        let program = Program::new(span);
        
        let result = backend.transform(&program);
        assert!(result.is_ok());
        
        let code = result.unwrap();
        assert!(code.contains("// Generated by Utopia Compiler - Scala Backend"));
        assert!(code.contains("package utopia.generated"));
        assert!(code.contains("import scala.collection.mutable"));
        assert!(code.contains("object UtopiaProgram"));
        assert!(code.contains("// Big data processing"));
    }

    #[test]
    fn test_julia_backend() {
        let backend = JuliaTransformer;
        let span = Span::new(0, 10, 1, 1);
        let program = Program::new(span);
        
        let result = backend.transform(&program);
        assert!(result.is_ok());
        
        let code = result.unwrap();
        assert!(code.contains("# Generated by Utopia Compiler - Julia Backend"));
        assert!(code.contains("using LinearAlgebra"));
        assert!(code.contains("using Statistics"));
        assert!(code.contains("# High-performance scientific computing"));
    }

    #[test]
    fn test_vbscript_backend() {
        let backend = VBScriptTransformer;
        let span = Span::new(0, 10, 1, 1);
        let program = Program::new(span);
        
        let result = backend.transform(&program);
        assert!(result.is_ok());
        
        let code = result.unwrap();
        assert!(code.contains("' Generated by Utopia Compiler - VBScript Backend"));
        assert!(code.contains("' Windows automation"));
    }

    #[test]
    fn test_bash_backend() {
        let backend = BashTransformer;
        let span = Span::new(0, 10, 1, 1);
        let program = Program::new(span);
        
        let result = backend.transform(&program);
        assert!(result.is_ok());
        
        let code = result.unwrap();
        assert!(code.contains("#!/bin/bash"));
        assert!(code.contains("# Generated by Utopia Compiler - Bash Backend"));
        assert!(code.contains("# Shell scripting"));
        assert!(code.contains("set -euo pipefail"));
    }

    #[test]
    fn test_nim_backend() {
        let backend = NimTransformer;
        let span = Span::new(0, 10, 1, 1);
        let program = Program::new(span);
        
        let result = backend.transform(&program);
        assert!(result.is_ok());
        
        let code = result.unwrap();
        assert!(code.contains("# Generated by Utopia Compiler - Nim Backend"));
        assert!(code.contains("import json, strutils"));
        assert!(code.contains("# Efficient compiled language"));
    }

    #[test]
    fn test_crystal_backend() {
        let backend = CrystalTransformer;
        let span = Span::new(0, 10, 1, 1);
        let program = Program::new(span);
        
        let result = backend.transform(&program);
        assert!(result.is_ok());
        
        let code = result.unwrap();
        assert!(code.contains("# Generated by Utopia Compiler - Crystal Backend"));
        assert!(code.contains("require \"json\""));
        assert!(code.contains("# Ruby-like syntax"));
    }

    #[test]
    fn test_zig_backend() {
        let backend = ZigTransformer;
        let span = Span::new(0, 10, 1, 1);
        let program = Program::new(span);
        
        let result = backend.transform(&program);
        assert!(result.is_ok());
        
        let code = result.unwrap();
        assert!(code.contains("// Generated by Utopia Compiler - Zig Backend"));
        assert!(code.contains("const std = @import(\"std\");"));
        assert!(code.contains("// Systems programming"));
    }

    #[test]
    fn test_elixir_backend() {
        let backend = ElixirTransformer;
        let span = Span::new(0, 10, 1, 1);
        let program = Program::new(span);
        
        let result = backend.transform(&program);
        assert!(result.is_ok());
        
        let code = result.unwrap();
        assert!(code.contains("# Generated by Utopia Compiler - Elixir Backend"));
        assert!(code.contains("defmodule UtopiaGenerated do"));
        assert!(code.contains("# Actor model concurrency"));
    }

    #[test]
    fn test_fsharp_backend() {
        let backend = FSharpTransformer;
        let span = Span::new(0, 10, 1, 1);
        let program = Program::new(span);
        
        let result = backend.transform(&program);
        assert!(result.is_ok());
        
        let code = result.unwrap();
        assert!(code.contains("// Generated by Utopia Compiler - F# Backend"));
        assert!(code.contains("module UtopiaGenerated"));
        assert!(code.contains("// Functional-first .NET"));
    }

    #[test]
    fn test_cpp_backend() {
        let backend = CppTransformer;
        let span = Span::new(0, 10, 1, 1);
        let program = Program::new(span);
        
        let result = backend.transform(&program);
        assert!(result.is_ok());
        
        let code = result.unwrap();
        assert!(code.contains("// Generated by Utopia Compiler - C++ Backend"));
        assert!(code.contains("#include <iostream>"));
        assert!(code.contains("class UtopiaRuntime"));
        assert!(code.contains("// Object-oriented systems programming"));
    }

    #[test]
    fn test_file_extensions() {
        let manager = TransformerManager::new();
        
        assert_eq!(manager.get_file_extension("python"), Some(".py".to_string()));
        assert_eq!(manager.get_file_extension("javascript"), Some(".js".to_string()));
        assert_eq!(manager.get_file_extension("typescript"), Some(".ts".to_string()));
        assert_eq!(manager.get_file_extension("c"), Some(".c".to_string()));
        assert_eq!(manager.get_file_extension("cpp"), Some(".cpp".to_string()));
        assert_eq!(manager.get_file_extension("c++"), Some(".cpp".to_string()));
        assert_eq!(manager.get_file_extension("csharp"), Some(".cs".to_string()));
        assert_eq!(manager.get_file_extension("c#"), Some(".cs".to_string()));
        assert_eq!(manager.get_file_extension("visualbasic"), Some(".vb".to_string()));
        assert_eq!(manager.get_file_extension("vb"), Some(".vb".to_string()));
        assert_eq!(manager.get_file_extension("ada"), Some(".adb".to_string()));
        assert_eq!(manager.get_file_extension("delphi"), Some(".pas".to_string()));
        assert_eq!(manager.get_file_extension("pascal"), Some(".pas".to_string()));
        assert_eq!(manager.get_file_extension("fortran"), Some(".f90".to_string()));
        assert_eq!(manager.get_file_extension("sql"), Some(".sql".to_string()));
        assert_eq!(manager.get_file_extension("r"), Some(".R".to_string()));
        assert_eq!(manager.get_file_extension("matlab"), Some(".m".to_string()));
        assert_eq!(manager.get_file_extension("m"), Some(".m".to_string()));
        assert_eq!(manager.get_file_extension("kotlin"), Some(".kt".to_string()));
        assert_eq!(manager.get_file_extension("kt"), Some(".kt".to_string()));
        assert_eq!(manager.get_file_extension("swift"), Some(".swift".to_string()));
        assert_eq!(manager.get_file_extension("cobol"), Some(".cob".to_string()));
        assert_eq!(manager.get_file_extension("cob"), Some(".cob".to_string()));
        assert_eq!(manager.get_file_extension("ruby"), Some(".rb".to_string()));
        assert_eq!(manager.get_file_extension("rb"), Some(".rb".to_string()));
        assert_eq!(manager.get_file_extension("lisp"), Some(".lisp".to_string()));
        assert_eq!(manager.get_file_extension("cl"), Some(".lisp".to_string()));
        assert_eq!(manager.get_file_extension("prolog"), Some(".pl".to_string()));
        assert_eq!(manager.get_file_extension("pl"), Some(".pl".to_string()));
        assert_eq!(manager.get_file_extension("dart"), Some(".dart".to_string()));
        assert_eq!(manager.get_file_extension("lua"), Some(".lua".to_string()));
        assert_eq!(manager.get_file_extension("haskell"), Some(".hs".to_string()));
        assert_eq!(manager.get_file_extension("hs"), Some(".hs".to_string()));
        assert_eq!(manager.get_file_extension("objective-c"), Some(".m".to_string()));
        assert_eq!(manager.get_file_extension("objc"), Some(".m".to_string()));
        assert_eq!(manager.get_file_extension("scala"), Some(".scala".to_string()));
        assert_eq!(manager.get_file_extension("julia"), Some(".jl".to_string()));
        assert_eq!(manager.get_file_extension("jl"), Some(".jl".to_string()));
        assert_eq!(manager.get_file_extension("vbscript"), Some(".vbs".to_string()));
        assert_eq!(manager.get_file_extension("vbs"), Some(".vbs".to_string()));
        assert_eq!(manager.get_file_extension("bash"), Some(".sh".to_string()));
        assert_eq!(manager.get_file_extension("sh"), Some(".sh".to_string()));
        assert_eq!(manager.get_file_extension("nim"), Some(".nim".to_string()));
        assert_eq!(manager.get_file_extension("crystal"), Some(".cr".to_string()));
        assert_eq!(manager.get_file_extension("cr"), Some(".cr".to_string()));
        assert_eq!(manager.get_file_extension("zig"), Some(".zig".to_string()));
        assert_eq!(manager.get_file_extension("elixir"), Some(".ex".to_string()));
        assert_eq!(manager.get_file_extension("ex"), Some(".ex".to_string()));
        assert_eq!(manager.get_file_extension("fsharp"), Some(".fs".to_string()));
        assert_eq!(manager.get_file_extension("fs"), Some(".fs".to_string()));
        assert_eq!(manager.get_file_extension("clojure"), Some(".clj".to_string()));
        assert_eq!(manager.get_file_extension("clj"), Some(".clj".to_string()));
        assert_eq!(manager.get_file_extension("erlang"), Some(".erl".to_string()));
        assert_eq!(manager.get_file_extension("erl"), Some(".erl".to_string()));
        assert_eq!(manager.get_file_extension("ocaml"), Some(".ml".to_string()));
        assert_eq!(manager.get_file_extension("ml"), Some(".ml".to_string()));
        assert_eq!(manager.get_file_extension("scheme"), Some(".scm".to_string()));
        assert_eq!(manager.get_file_extension("scm"), Some(".scm".to_string()));
        assert_eq!(manager.get_file_extension("racket"), Some(".rkt".to_string()));
        assert_eq!(manager.get_file_extension("rkt"), Some(".rkt".to_string()));
        assert_eq!(manager.get_file_extension("smalltalk"), Some(".st".to_string()));
        assert_eq!(manager.get_file_extension("st"), Some(".st".to_string()));
        assert_eq!(manager.get_file_extension("pascal"), Some(".pas".to_string()));
        assert_eq!(manager.get_file_extension("pas"), Some(".pas".to_string()));
        assert_eq!(manager.get_file_extension("basic"), Some(".bas".to_string()));
        assert_eq!(manager.get_file_extension("bas"), Some(".bas".to_string()));
        assert_eq!(manager.get_file_extension("assembly"), Some(".s".to_string()));
        assert_eq!(manager.get_file_extension("llvm"), Some(".ll".to_string()));
        assert_eq!(manager.get_file_extension("wasm"), Some(".wat".to_string()));
    }
} 